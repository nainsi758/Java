<html>
    <head>
        <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
        <title>Java</title>
        <style>
            h1 {
                color: red;
            }
            h3 {
                color: darkblue;
            }
            h6 {
                color:crimson; 
            }
            h5 {
                color:darkmagenta;
            }
            table th {
                text-align: center;
            }
        </style>
    </head>
    <body>
        <h1>Language Fundamentals</h1>
        <h3>1. Identifiers</h3> a name which can be used for identification purpose. It can be class name, function name and label name </p>
        <mark>We can't use reserved word as identifiers.
        Predefined class name and interface names can be used as identifiers</mark>
        
        <h3>2. Reserved Words</h3>
        <p>Some words are reserved to represent some meaning or functionality called reserved words.</p>
        <mark>Total 53 reserved words are there.
             In them 50 are keywords and 3 are reserved literals.
        </mark>
        <h5>keyword(Unused keywords - goto const)</h5>
        <p>If the reserved word associated with functionality. 48 keywords are used keywords and 2 are unused.</p>
        <p><h5>Reserved literals(true false null)</h5>If the reserved word only to represent value.
        

        <div class="container-fluid">
            <div class="row">
                <div class="col-sm-1" style="background-color:lavender;"><h6>Keywords for data types(8)</h6><p>byte<br>short<br>int<br>long<br>float<br>double<br>boolean<br>char</p></div>                  
                <div class="col-sm-1" style="background-color:lavenderblush;"><h6>Keywords for flow control(11)</h6><p>if<br>else<br>switch<br>case<br>default<br>while<br>do<br>for<br>break<br>continue<br>return</p></div>
                <div class="col-sm-1" style="background-color:lavender;"><h6>Keywords for modifiers(11)</h6><p>public<br>private<br>protected<br>static<br>final<br>abstract<br>synchronized<br>native<br>strictfp<br>transient<br>volatile</p></div>
                <div class="col-sm-1" style="background-color:lavenderblush;"><h6>Keywords for exception handling(6)</h6><p>try<br>catch<br>finally<br>throw<br>throws<br>assert</p></div>
                <div class="col-sm-1" style="background-color:lavender;"><h6>Class related keywors(6)</h6><p>class<br>interface<br>extends<br>implements<br>package<br>import</p></div>
                <div class="col-sm-1" style="background-color:lavenderblush;"><h6>Object related keywords(4)</h6><p>new<br>instanceof<br>super<br>this</p></div>
                <div class="col-sm-1" style="background-color:lavender;"><h6>Void return type keyword(1)</h6><p>void</p></div>
                <div class="col-sm-1" style="background-color:lavenderblush;"><h6>Enum Keyword(1)</h6><p>Enum</p></div>
                <div class="col-sm-1" style="background-color:lavender;"><h6>Unused keywords(2)</h6><p>goto<br>const</p></div>
                <div class="col-sm-1" style="background-color:lavenderblush;"><h6>Reserved literals(3)</h6><p>true<br>false<br>null</p></div>
            </div>
        </div>
        <mark>Delete keyword is not there because destruction of the object is responsibility of garbage collector</mark>
        <p>We can use enum to define a group of named constants</p>
        <mark>In java return type is mandatory</mark>
        <h3>3. Data Types</h3>
        <p>In java every variable and every expression has some type. Each and every datatype is clearly defined. Every assignment should be checked by compiler for type compatibility because of above reasons we can conclude java language is strongly typed  programming language</p>
        <div class="container-fluid">
            <p class="bg-warning text-white">Is java pure oop language or not?</p>
        
            <p>Java is not considered as pure oop language because several oop feature is not supported by java. Like operator overloading and multiple inheritance etc. We are depending on primitive data types which are non-object</p>
        </div>

        <h5>Primitive data types(8)</h5>
        <p>Numeric data types - Data types which can be used to represent only numbers</p>
        <p>Non-Numeric data types - Data types which can be used to represent non-numeric data like char and boolean</p>
        <p>Except char and boolean remaining data types are signed data types because we can represent both positive and negative numbers.</p>
        <p>0 represents positive number and 1 represents negative number. Positive numers will be represented directly in a memory whereas as negative numbers will be represented in 2's compliment form.</p>
        <p> If we want to handle data in terms of streams either from the file or from the network. file supported form or the the network supported form is byte data type</p>
        <p>Short is the most rarely used data type in java</p>
        <p>If we want 5 to 6 decimal places of accuracy go for float. Float follows single precision.</p>
        <p>If we want 14 to 15 decimal places of accuracy go for double. Double follows double precision</p>
        <table class="table table-striped" >
            <thead class="thead-dark">
              <tr>
                <th colspan="3">Primitive data types(8)</th>
              </tr>
              <tr>
                <th colspan="2">Numeric Data Type</th>
                <th>Non numeric Data Type</th>
              </tr>
              <tr>
                <th>Integral Data Type</th>
                <th>Floating Point Data Type</th>
                <th></th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Byte(size 1 bytes 8 bits) -128 to +127 Wrapper class-Byte Default value-0</td>
                <td>float(size 4 bytes) -3.4e38 to 3.4e38 means (-3.4*10<sup>38</sup> to 3.4*10<sup>38</sup>) Wrapper class-Float Default value-0.0</td>
                <td>character(2 bytes) 0 to 65535 Wrapper class-Character Default value-0(represents space character)</td>
              </tr>
              <tr>
                <td>Short(2 bytes 16 bits) -2<sup>15</sup>to 2<sup>15</sup>-1(-32768 to 32767) Wrapper class-Short Default value-0</td>
                <td>double(size 8 bytes) -1.7e308 to 1.7e308 Wrapper class-Double Default value-0.0</td>
                <td>boolean(true and false) Wrapper class-Boolean Default value-false</td>
              </tr>
              <tr>
                <td>Int(4 bytes 32 bits) -2<sup>31</sup>to 2<sup>31</sup>-1(-2147483648 to 2147483647) Wrapper class-Integer Default value-0</td>
              </tr>
              <tr>
                <td>Long(8 bytes 64 bits) -2<sup>63</sup>to 2<sup>63</sup>-1 Wrapper class-Long Default value-0</td>
              </tr>
            </tbody>
          </table>

          <code>
              <pre>
                  int x=1;
                  if(x) {
                      SOP("Hii");
                  } else {
                      SOP("Bye");
                  }
                </pre>
             </code>
             
             <p class="text-primary"> This code will give error because this was possible in old languages. Here it is expecting boolean so provide boolean only</p>
             </div>
        <div class="container-fluid">
            <p class="bg-warning text-white">Why java uses 2 byte instead of 1 byte for char?</p>
            <p>Because java uses unicode, old language uses ascii code</p>
        </div>

        <mark>Null is the default value for object reference so we can't use it for primitive types</mark>

        <h3>4. Literals</h3>

        
        
        <p>A constant value wich can be assigned to the variable is called literal</p>
        <code>int x = 10;</code>
        <p>Here 10 is literal</p>

        <h5>Integral Literals</h5> <p>For integral data types byte short int long we can specify literal value in the following ways.</p>

        <h5>Decimal Form (base-10 means allowed digits are 0 to 9)</h5>
        <p>Bydefault decmal only</p>
        <h5>Octal value(base-8 means allowed digits are 0 to 7)</h5>
        <p>If a number prefixed with 0 is considered as octal value</p>
        <h5>Hexadecimal form(base-16 means allowed digits are 0 to 9 and A to F)</h5>
        <p>Java is case sensitive, here for extra digits(a to f) we can use both lower case and upper case characters. This is one of very few areas where java is not case sensitive. For prefix also x can be uppercase or lowercase.</p>

        <p>If a number prefixed with 0x is considered as hexadecimal value</p>
        
        <code>
          int x = 10;
          int y = 010;
          int z = 0x10;
        </code>

        <output>Output : 10 8 16</output>
        
        <p>By default every integral literal is of int type but we can specify explicitly as long type by suffixed with l or L</p>

        <code>
          int x = 10L;
        </code>
        <output>Wrong because assigning 8 byte to 4 byte</output>

        <h5>Floating Point Literals</h5>

        <p>By default every Floating type literal is of type double type and hence we cant assign directly to the float variable but we can specify floating point literal as float type by suffixed with f or F</p>
        <code>float f = 123.456f;</code>

        <p>Floating point literals we can specify only in decimal form</p>
        <p>We can't use octal and hexa with floating point literals only can use with integral literal type</p>
        <code>double d = 0123.456</code><output>Valid(treated as Decimal only)</output><br>
        <code>double d = 0x123.456</code><output>Not Valid</output><br>
        <code>double d = 0786</code><output>No decimal point is there so treated as integral type only and as being integral it is prefixed with 0 so it will be treated as octal hence octal allows (0 -7) here 8 is there CE: Integer number too large</output><br>
        <code>double d = 0xFace</code><output>Valid It is integral literal. Starts with 0x so hexadecimal. Face is allowed value. And we can assign integral literal directly to floating point variable and that integral literal can be specified either in decimal or octal or hexadecimal.</output><br>
        <code>double d = 10</code><output>10.0</output><br>
        <code>double d = 0xFace.0</code><output>Invalid</output><br>
        <code>double d = 0777</code><output>Valid</output><br>
        <code>double d = 1.2e3</code><output>Valid</output><br>  
        
        <h5>Boolean Literals</h5>
        <p>Only allowed values for boolean literals are true or false</p>

        <h5>Char Literals</h5>
        <p>We can specify char literal as integral literal which represents unicode value of the character and that integral literal can be specified either in decimat or octal or hexa forms but allowed range is 65535</p>
        <code>char ch = "a"</code><output>Invalid string not allowed</output><br>
        <code>char ch = 'abc'</code><output>Unclosed character literal, not a java statement</output><br>
        <code>char ch = '97'</code><output>a</output><br>
        <code>char ch = 65536</code><output>Found int req char</output>

        <table class="table table-striped" >
          <thead class="thead-dark">
            <tr>
              <th>Escape characters</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>\n</td>
              <td>new line</td>
            </tr>
            <tr>
              <td>\t</td>
              <td>Horizontal tab</td>
            </tr>
            <tr>
              <td>\r</td>
              <td>carriage return</td>
            </tr>
            <tr>
              <td>\b</td>
              <td>backspace character</td>
            </tr>
            <tr>
              <td>\f</td>
              <td>form feed</td>
            </tr>
            <tr>
              <td>\'</td>
              <td>Single quote</td>
            </tr>
            <tr>
              <td>\"</td>
              <td>Double quote</td>
            </tr>
            <tr>
              <td>\\</td>
              <td>backslash character</td>
            </tr>
          </tbody>
        </table>

        <h5>String Literals</h5>
        <code>string s = "a"</code><output></output>
        <h5>Binary Literals(from 1.7v onwards)</h5>
        <code>int b = 0b1111</code><output>15</output>

        <h5>Using underscore with numeric literals for readibility(from 1.7v onwards)</h5>
        <code>double d = 1_23_456.7_8_9</code>
        <p>At the time of compilation these underscores symbols will be removed automatically
          hence after compilation above lines will become 
        </p>
        <code>double d = 123456.789;</code><br>
        <code>double d = 1_____23_____456.7_8_9</code><br>
        <output>ALso valid</output><br>
        <code>double d = _1_23_456.7_8_9</code><output>Invalid</output>
        <p>We can use underscore symbols only with in the digits</p>

        <p>byte(1B)-----> short(2B) ------> int(4B) -----> long(8B) -----> float(4B) -----> double(8B)</p>
        <p>char(2B) -----> int(4B) -----> long(8B) -----> float(4B) -----> double(8B)</p>

        <p>8 byte long value we can assign to 4 B float variable bcoz both are following diff memory representation internally.</p>
        <h3>5. Arrays</h3>
        <h5>Introduction</h5>
        <p>An array is an indexed collection of fixed number of homogeneous data elements.</p> 
        <p>The main advantage of array is we can represent huge number of values by using single variable so that readibility of the code will
          be improved. 
        </p>
        <p>The main disadvantage of the array is fixed in size i.e once we creates an array there is no chance of increasing 
          or decreasing of size based on our requirement. Hence to use arrays concept compulsory we should know the size in advance which may not possible always.
        </p>

        <h5>Array Declaration</h5>
        <h6>1-D array declaration</h6>
        <code>int[] x;</code>(recommended because name is clearly separated from type.)<br>
        <code>int []x;</code><br>
        <code>int x[];</code><br>

        <code>int[6] x;</code>(Invalid)
        <p>At the time of declaration we cant specify the size o/w we will get compile time error</p>


        <h6>2-D array declaration</h6>
        <code>int[][] x;</code>(recommended)<br>
        <code>int [][]x;</code><br>
        <code>int x[][];</code><br>
        <code>int[] []x;</code><br>
        <code>int[] x[];</code><br>
        <code>int []x[];</code><br>

        <code>int[] a, b;</code>(a-1D b-1D)<br>
        <code>int[] a[],b;</code>(a-2D b-1D)<br>
        <code>int[] a[], b[];</code>(a-2D b-2D)<br>
        <code>int[] []a, b;</code>(a-2D b-2D)<br>
        <code>int[] []a, b[];</code>(a-2D b-3D)<br>
        <code>int[] []a, []b;</code>(Invalid compilation error)<br>
        <p>If we want to specify dimension before the variable that facility is applicable only for first variable in a declaration.
          If we are trying to apply for remaining variable we will get Compile time error
        </p>

        <h6>3-D array declaration</h6>
        <code>int[][][] x;</code><br>
        <code>int [][][]x;</code><br>
        <code>int x[][][];</code><br>
        <code>int[] [][]x;</code><br>
        <code>int[] x[][];</code><br>
        <code>int[] []x[];</code><br>
        <code>int[][] []x;</code><br>
        <code>int [][]x[];</code><br>
        <code>int []x[][];</code><br>

        <h5>Array Creation</h5>
        <h6>1-D Array Creation</h6>
        <code>int[] x = new int[3];</code><br>
        <p>Every array in java is an object only hence we can create arrays by using new operator.</p>
        <p>For every array type corresponding classes are available and these classes are part of java language and not available to the programmer level.</p>
        <code>SOP(a.getClass().getName());</code><output>[I</output><br>

        <table class="table table-striped" >
          <thead class="thead-dark">
            <tr>
              <th>Array Type</th>
              <th>Corresponding Class Type</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>int[]</td>
              <td>[I</td>
            </tr>
            <tr>
              <td>int[][]</td>
              <td>[[I</td>
            </tr>
            <tr>
              <td>double[]</td>
              <td>[D</td>
            </tr>
            <tr>
              <td>short[]</td>
              <td>[S</td>
            </tr>
            <tr>
              <td>byte[]</td>
              <td>[B</td>
            </tr>
            <tr>
              <td>boolean[]</td>
              <td>[Z</td>
            </tr>
          </tbody>
        </table>

        <h6>Loophole 1: </h6>
        <p>At the time of array Creation compulsory we should specify the size o/w how the jvm will reserve the size and hence CE will come.</p>
        <code>int[] x = new int[];</code>(CE)<br>
        <code>int[] x = new int[6];</code>(Valid)<br>
        <code>int[] x = new int[0];</code>(valid)<br>
        <code>int[] x = new int[-3];</code>(valid at compile time but run time exception - negative array size exception)<br>
        <code>int[] x = new int['a'];</code>(valid - char to int promotion acceptable so size will be 97)<br>

        <p>byte(1B)-----> short(2B) ------> int(4B)</p>
        <p>char(2B) -----> int(4B)</p>

        <p>Only integer value allowed for size so till int every data type is acceptable means whose promotion to int is acceptable</p>

        <code>int[] x = new int[10l];</code>(Invalid becuse long cant get promoted to int so we will get compile time error)<br>

        <p>The maximum allowed array size in java is 2147483647(int max size). Even in this case we can get run time error if sufficient heap memory is not available</p>
        
        <h6>2-D Array Creation</h6>
        <h6>Array of arrays</h6>
        <p>In java 2D array not implemented by using matrix style some people followed array of arrays approach for multi dimensional array creation, the main adv of this approach is memory utilization will be improved</p>

        <pre><code>
        int[][] x = new int[2][];
        x[0] = new int[2];
        x[1] = new int[3];
      </code></pre>

      <h6>3-D Array Creation</h6>
      <pre><code>
        int[][][] x = new int[2][][];
        x[0] = new int[3][];
        x[0][0] = new int[1];
        x[0][1] = new int[2];
        x[0][2] = new int[3];
        x[1] = new int[2][2];
      </code></pre>

      <mark>Once we creates an array every array element by default initialized by value 0</mark>
      <mark>Whenever we are trying to print any reference variable internally toString() method will be called which is implemented by default to return the string in classname@hashcode_in_hexadecimalform</mark>

      <pre><code>
        int[][] x = new int[2][];
        SOP(x);
        SOP(x[0]);
        SOP(x[0][0]);
      </code></pre>

      <output>Output - [[I@0u5b7a null Null pointer Exception</output>
      
      <p>If we are trying to perform any operation on null then we will get RE by saying null pointer exception</p>

        <h5>Array declaration, Creation and Initialization in a single line</h5>
        <code>int[] x = {10, 20, 30};</code><br>
        <code>int[][] x = {{10, 20}, {30, 40, 50}};</code><br>
        <code>int[][][] x = {{{10, 20, 30}, {40, 50, 60}, {{70, 80}, {90, 100}}};</code><br>

        <h5>length vs length()</h5>
        <pre><code>
        int[] x = new int[6];
        SOP(x.length());
      </code></pre>

      <output>Cannot find symbol method length in location class int[] type</output>

      <pre><code>
        int[] x = new int[6];
        SOP(x.length);
      </code></pre>

      <output>Output - 6</output><br>

      <mark>Length is a final variable applicable for arrays. length variable represents the size of the array.</mark>

      <pre><code>
        String s = "durga";
        SOP(s.length);
      </code></pre>

      <output>Cant find symbol variable length class java.lang.String</output>

      <pre><code>
        String s = "durga";
        SOP(s.length());
      </code></pre>

      <output>Output - 5</output><br>

      <p>length() method is a final method applicable for string objects. length() returns number of characters present in the string</p>

      <pre><code>
        String s = {"a", "aa", "aaa"};
        SOP(s.length);
        SOP(s.length());
        SOP(s[0].length);
        SOP(s[0].length());
      </code></pre>

      <output>Output: 3 CE CE 1</output><br>

      <pre><code>
        int[][] x = new int[6][3];
        SOP(x.length);
        SOP(x[0].length());
      </code></pre>

      <output>Output: 6 3</output><br>

      <mark>In multidimensional arrays length variable represents only base size but not total size.</mark>
      <p>There is no direct way to find total length of multidimensional array but indirectly we can find as follows</p>
      <p>x[0].length + x[1].length + x[2].length.............</p>

        <h5>Annonymous arrays</h5>
        <p>Sometimes we can declare an array without name such type of nameless arrays are called annonymous arrays</p>
        <p>The main purpose of annonymous arrays is just for instant use(one time usage)</p>
        <p>We can create annonymous arrays as follows- new int[]{10, 20, 30};</p>
        <p>While creating annonymous arrays we can't create the size o/w we will get compile time error</p>
        
        <code>new int[]{10, 20, 30, 40, 50};</code>Valid<br>
        <code>new int[5]{10, 20, 30, 40, 50};</code>Invalid

        <pre><code>
          class Test {
            p s v m(String[] args) {
              sum(new int[] {10, 20, 30, 40, 50});
            }
            p s v sum(int[] x) {
                int total = 0;
                for(int x1 : x) {
                    total = total + x1;
                }
                SOP("The sum : " + total);
            }
          }
          </code></pre>

        <p>In the above example just to call sum method we required an array but after completing sum method call we are not using that array anymore hence for this one time requirement annonymous array is the best choice</p>

        <p>We can create multidimensional annonymous arrays as follows- new int[][]{{10, 20}, {30, 40, 50}};</p>
        
        <p>Based on our requirement we can give the name for annonymous array then it is no longer annonymous</p>
        <code>int[] x = new int[]{10, 20, 30};</code>


        <h5>Array element assignments</h5>
        <p>In the case of object type arrays as array elements we can provide either declared type objects or its child class objects</p>
        <pre><code>
        Object[] a = new Object[10];
        a[0] = new Object();
        a[1] = new String("durga");
        a[2] = new Integer(10);
        </code></pre>

        <pre><code>
          Number[] a = new Number[10];
          a[0] = new Integer(10);
          a[1] = new Double(10.5);
          a[2] = new String("Durga");
        </code></pre>

        <p>Here a[2] is invalid because String is not the child class of Number</p>

        <p>For interface type arrays as array elements its implementation class objects are allowed</p>
        <pre><code>
          Runnable[] r = new Runnable[10];
          r[0] = new Thread();
          r[1] = new String("durga");
        </code></pre>

        <table class="table table-striped" >
          <thead class="thead-dark">
            <tr>
              <th>Array Type</th>
              <th>Allowed Element Types</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Primitive Arrays</td>
              <td>Array type which can be implicitly promoted to declared type.</td>
            </tr>
            <tr>
              <td>Object Type Arrays</td>
              <td>Either declared type or its child class objects.</td>
            </tr>
            <tr>
              <td>Abstract class type arrays</td>
              <td>Its child class objects are allowed(Example - Number is an abstract class)</td>
            </tr>
            <tr>
              <td>Interface type array</td>
              <td>Its implementation class objects are allowed</td>
            </tr>
          </tbody>
        </table>

        <h5>Array variabe assignments</h5>
        <p>Element level promotion are not applicable at array level. For example char element can be promoted to int type whereas char array cant be promoted to int array</p>
        <pre><code>
          int[] x = {10, 20, 30, 40};
          char[] ch = {'a', 'b', 'c', 'd'};
          int[] b = x;(valid)
          int[] c = ch;(CE: found char[] required int[])
        </code></pre>

        <div class="container">
        <p class="bg-warning text-white">Which of the following promotions will be performed automatically</p>
        <pre><code>
        char     ---> int       (valid)
        char[]   ---> int[]     (invalid)
        int      ---> double    (valid)
        int[]    ---> double[]  (invalid)
        float    ---> int       (invalid)
        float[]  ---> int[]     (invalid)
        String   ---> Object    (Valid)
        String[] ---> Object[]  (valid)
        </code></pre>
        <p>But in the case of object type arrays child class type array can be promoted to parent class type array.</p>
        <pre><code>
          String[] s = {'a', 'b', 'c'};
          Object[] a = s;  (valid)
        </code></pre> 
        
        <p>Whenever we are assigning one array to another array intrenal elements wont be copied just reference variable will be reassigned</p>
        <pre><code>
          int[] a = {10, 20, 30, 40, 50, 60};
          int[] b = {70, 80};
          a = b;  (valid)
          b = a;  (valid)
        </code></pre>
      </div>

      <p>Whenever we are assigning one array to another array the dimensions must be matched for ex in the place of 1D int array we should provide
         1D array only if we are trying to provide any other dimension then we will get compile time error</p>
      <pre><code>
        int[][] a = new int[3][];
        a[0] = new int[4][3];     (CE: incompatible types found int[][] required int[]);
        a[0] = 10;                (CE: incompatible types found int required int[]);
        a[0] = new int[2];        (valid)
      </code></pre>

      <p>Whenever we are assigning one array to another array both dimensions and types must be matched but sizes are not required to match</p> 
       
      <pre><code>
        int[][] a = new int[4][3];
        a[0] = new int[4];
        a[1] = new int[2];
        a = new int[3][2];
      </code></pre>

      <p style="color:red">Total how many objects created?</p>
        <p>11</p>
        <p style="color:red">Total how many objects eligible for garbage collector?</p>
        <p>7</p>

        <img src="images/ss1.png" alt="ss1" width="500" height="300">

        <h3>6. Types of variables</h3>
        <h4>Division 1:</h4>
        <p>Based on type of value represented by a variable all variables are divided into two types</p>
        <h5>1. Primitive Variables</h5>
        <p>can be used to represent primitive values</p>
        <code>int x = 10;</code>
        <p>Here x is a primitive variable</p>
        <h5>2. Reference variables</h5>
        <p>Can be used to refer objects</p>
        <code>Student s = new Student()</code>

        <h4>Division 2:</h4>
        <p>Based on position of declaration and behaviour all variables are divided into three types.</p>
        <p>1. Instance variables</p>
        <p>2. Static variables</p>
        <p>3. Local variables</p>

        <h5>Instance variables</h5>
        <p>1. If the value of a variable is varied from object to object such type of variables are called instance variables</p>
        <p>2. For every object a seperate copy of instance variable will be created</p>
        <p>3. Instance variables should be declared within the class directly but outside of any method or block or constructor</p>
        <p>4. Instance variable will be created at the time of object creation and destroyed at the time of object destruction. Hence the scope of instance variable is exactly same as the scope of object</p>
        <p>5. Instance variables will be stored in the heap memory as the part of object</p>
        <p>6. We cant access instance variables directly from static area but we can access by using object reference</p>
        <p>7. But we can access instance variable directly from instance area</p>

        <pre><code>
          class Test {
            int x = 10;
            public static void main(String[] args) {
              SOP(x);   (CE: non static variable x cannot be referenced from a static context)
              Test t = new Test();
              SOP(t.x);   10
            }
            public void m1() {
              SOP(x);   10
            }
          }
        </code></pre>

        <p>8. For instance variables jvm will always provide defayult values and we are not required to perform initialization explicitly</p>

        <pre><code>
          class Test {
            int x;
            double d;
            boolean b;
            String s;
            p s v m(String[] args) {
              Test t1 = new Test();
              SOP(t1.x);    0
              SOP(t1.d);    0.0
              SOP(t1.b);    false
              SOP(t1.s);    null
            }
          }
        </code></pre>

        <p>9. Instance variables also known as object level variables or attributes</p>

        <h5>Static variables</h5>

        <pre><code>
        class Student {
          String name;
          int roll no;
          String collegename;
        }
        </code></pre>

        <img src="images/ss3.png" alt="ss1" width="500" height="300">
        <p>1. If the value of a variable is not varied from object to object then its not recommended to declare variable as instance variable we have to declare such type of variables at class level by using static modifier</p>
        <p>2. In the case of instance variables for every object a separate copy will be created but in the case of static variables a single copy will be created at class level and shared by every object of the class</p>
        <p>3. Static variables should be declared with in the class directly but outside of any method or block or constructor</p>
        <p>4. Static variables will be created at the time of class loading and destroyed at the time of class unloading. Hence scope of static variable is exactly same as scope of .class file</p>

        <pre><code>
          java Test<kbd>enter</kbd>
          1. Start JVM
          2. create & start main Thread
          3. locate Test.class file
          4. load Test.class        (Static variables creation)
          5. Execute main() method
          6. unload Test.class      (Static variables destruction)
          7. Terminate main Thread
          8. Shut down jvm
        </code></pre>

        <p>5.Static variables will be stored in method area</p>
        <p>6. We can access static variables either by object reference or by class name but recommended to use class name. Within the same class 
           it is not required to use class name and we can access directly</p>
         
        <pre><code>
            class Test {
            static int x = 10;
            p s v m(String[] args) {
              Test t = new Test();
              SOP(t.x);         (valid)
              SOP(Test.x);      (valid and recommended)
              SOP(x);           (valid )
            }
            public void m1() {
              SOP(x);           (valid)
            }
          }
        </code></pre>

        <p>7. We can access static variables directly from both instance and static areas</p>
        
        <p>8. For static variables jvm will provide default values and we are not required to perform initialization explicitly</p>
        <pre><code>
          class Test {
            static int x;
            static double d;
            static boolean b;
            static String s;
            p s v m(String[] args) {
              SOP(t1.x);    0
              SOP(t1.d);    0.0
              SOP(t1.b);    false
              SOP(t1.s);    null
            }
          }
        </code></pre>

        <p>9. Static variable also known as class level variables or fields</p>
        <pre><code>
          class Test {
            static int x = 10;
            int y = 20;
            p s v m (String[] args) {
              Test t1 = new Test();
              t1.x = 888;
              t1.y = 999;
              Test t2 = new Test();
              SOP(t2.x + " " + t2.y);
            }
          }
        </code></pre>

        <output>Output: 888 20</output><br>

        <img src="images/ss2.png" alt="ss1" width="500" height="300">
       
        <h5>Local Variables</h5>
        <p>1. Sometimes to meet temporary requirements of the programmar we can declare variables inside a method or block or constructor such type of variables are called local variables or temporary variables or automatic variables</p>
        <p>2. Local variables will be stored inside stack memory</p>
        <p>3. Local variables will be created while executing the block in which we declared it. Once block execution completes automatically local variable will be destroyed. Hence the scope of local variable is the block in which we declared it.</p>
        
        <pre><code>
          class Test {
            p s v m(String[] args) {
              int i = 0;
              for(int j = 0; j &lt= 3; j++) {
                i = i + j;
              }
              SOP(i + "......" + j);
            }
          }
        </code></pre>

        <pre><output>
          CE: cannot find symbol
          symbol: variable j
          location: class Test
        </output></pre>

        <pre><code>
          class Test {
            p s v m(String[] args){
              try {
                int j = Integer.parseInt("ten");
              }
              catch(NumberFormatException e) {
                j = 10;
              }
              SOP(j);
            }
          }
        </code></pre>
          <pre><output>
            CE: cannot find symbol
            symbol: variable j
            location: class Test
          </output></pre>
        
        <p>4. For local variables jvm wont provide default values compulsory we should perform initialization explicitly before using that variable i.e if we are not using then it is not required to perform initialization</p>
        <pre><code>
        class Test {
          p s v m(String[] args) {
            int x;
            SOP("Hello");
          }
        }
        </code></pre>
        
        <pre><output>
        Hello
        </output></pre>

        <pre><code>
        class Test {
          p s v m(String[] args) {
            int x;
            SOP(x);
          }
        }
        </code></pre>

        <pre><output>
        CE: variable x might not have been initialized
        </output></pre>

        <pre><code>
          class Test {
            p s v m(String[] args) {
              int x;
              if(args.length > 0) {
                x = 10;
              }
              SOP(x);
            }
          }
        </code></pre>
        <pre><output>
          CE: variable x might not have been initialized.  
        </output></pre>

        <pre><code>
          class Test {
            p s v m(String[] args) {
              int x;
              if(args.length > 0) {
                x = 10;
              } else {
                x = 20;
              }
              SOP(x);
            }
          }
          </code></pre>

          <pre><output>
          java test 10<kbd>enter</kbd>
          10
          java test<kbd>enter</kbd>
          20
          </output></pre>

        <p>Note 1 : It is not recommended to perform initialization for local variables inside logical blocks becaue there is no guarantee for the execution of these blocks always at run time</p>
        <p>Note 2 : It is highly recommended to perform initialization at the time of declaration atleast with default values</p>
        <p>5. The only applicable modifier for local variables is final. By mistake if we are trying to apply any other modifier then we will get compile time error</p>

        <pre><code>
          class Test {
            p s v m(String[] args) {
              public int x = 10;
              private int x = 10;
              protected int x = 10;
              static int x = 10;
              transient x = 10;
              volatile x = 10;
              final int x = 10;
            }
          }
          </code></pre>
          <pre><output>
            CE: Illegal start of expression
          </output></pre>
          <img src="images/ss4.png" alt="ss1" width="500" height="300">

        <p>6. If we are not declaring with any modifier then by default it is default but this rule is applicable only for instance and static variables but not for local variables</p>

        <h4>Conclusions : </h4>
        <p>1. For instance and static variables jvm will provide default values and we are not required to perform initialization explicitly but for local variables jvm wont provide default values compulsory we should perform initialization explicitly befor using that variable</p>
        <p>2. Instance and static variables can be accessed by multiple threads simultaneously and hence these are not thread safe but in the case of local variable for every thread a separate copy will be created and hence local variables are thread safe</p>
        
        <table class="table table-striped" >
          <thead class="thead-dark">
            <tr>
              <th>Types of variables</th>
              <th>Is thread safe?</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Instance Variables</td>
              <td>No</td>
            </tr>
            <tr>
              <td>Static variables</td>
              <td>No</td>
            </tr>
            <tr>
              <td>Local variables</td>
              <td>Yes</td>
            </tr>
          </tbody>
        </table>
 
        <p>Every variable in java should be either instance or static or local</p>
        <p>Every variable in java should be either primitive or reference hence various possible combinations of variables in java are</p>
        
        <img src="images/ss5.png" alt="ss1" width="500" height="300">
        <pre><code>
        class Test {
          int x = 10;                   (instance primitve variable)
          static String s = "durga";    (static reference variable)
          p s v m(String[] args) {
            int[] y = new int[3];       (local reference variable)
          }
        }
        </code></pre>

        <h6>Uninitialized arrays</h6>
        <pre><code>
          class Test {
            int[] x;
            p s v m(String[] args) {
              Test t = new Test();
              SOP(t.x);
              SOP(t.x[0]);
            }
          }
          </code></pre>

          <pre><output>
            null
            RE: NullPointerException
          </output></pre>

          <p>At instance level</p>
          <pre><code>
            int[] x;
            SOP(obj.x);
            SOP(obj.x[0]);
          </code></pre>
          <pre><output>
            null
            RE: NullPointerException
          </output></pre>

          <pre><code>
            int[] x = new int[3];
            SOP(obj.x);
            SOP(obj.x[0]);
          </code></pre>
          <pre><output>
            [I@7yt5g6
            0
          </output></pre>
          
        <p>At static level</p>
        <pre><code>
          static int[] x;
          SOP(x);
          SOP(x[0]);
        </code></pre>
        <pre><output>
          null
          RE: NullPointerException
        </output></pre>

        <pre><code>
          static int[] x = new int[3];
          SOP(x);
          SOP(x[0]);
        </code></pre>
        <pre><output>
          [I@7yt5g6
          0
        </output></pre>

        <p>At local level</p>
        <pre><code>
          int[] x;
          SOP(x);
          SOP(x[0]);
        </code></pre>
        <pre><output>
          CE: variable x might not have been initialized
        </output></pre>

        <pre><code>
          int[] x = new int[3];
          SOP(x);
          SOP(x[0]);
        </code></pre>
        <pre><output>
          [I@7yt5g6
          0
        </output></pre>

        <mark>Once we creates an array every array element by default initialized with default values irrespective of whether it is instance or static or local array</mark>
<h3>7. Var-arg methods(came in 1.5v)</h3>
<p>Until 1.4v we cant declare a method with variable number of arguments if there is a change in number of arguments compulsory we should go for new method
  it increases length of the code and reduces readibility hence to overcome this problem some people introduced var args methods in 1.5v
  According to this we can declare a method which can take variable number of arguments such type of methods are called var args methods
</p>

<p>We can declare a var args method as follows</p>
<pre><code>
  m1(int... x);
</code></pre>
<p>We can call this method by passing any number of int values including 0 numbers</p>

<pre><code>
  m1();
  m1(10);
  m1(10, 20);
  m1(10, 20, 30);
</code></pre>

<p>All calls to m1() method are valid</p>

<pre><code>
  class Test {
    public static void m1(int... x) {
      SOP("var-arg method");
    }
    p s v m(String[] args) {
      m1();
      m1(10);
      m1(10, 20);
      m1(10, 20, 30);
    }
  }
  </code></pre>

  <pre><output>
    var-arg method
    var-arg method
    var-arg method
    var-arg method
  </output></pre>

<p>Internally var-arg parameter will be converted into one dimensional array hence within the var-arg method we can 
  differentiate values by using index.
</p>

<pre><code>
  class Test {
    public static void m1(int... x) {
      SOP("The number of arguments : " + x.length);
    }
    p s v m(String[] args) {
      m1();
      m1(10);
      m1(10, 20);
      m1(10, 20, 30);
    }
  }
  </code></pre>

  <pre><output>
    The number of arguments : 0
    The number of arguments : 1
    The number of arguments : 2
    The number of arguments : 3
  </output></pre>

  <pre><code>
    class Test {
      public static void sum(int... x) {
        int total = 0;
        for(int x1 : x) {
          total = total + x1;
        }
        SOP("The sum " + total);
      }
      p s v m(String[] args) {
        sum();
        sum(10, 20);
        sum(10, 20, 30);
        sum(10, 20, 30, 40);
      }
    }
    </code></pre>

    <pre><output>
      The sum 0
      The sum 30
      The sum 60
      The sum 100
    </output></pre>

  <h6>case 1:</h6>
  <p>Which of the following are valid var-arg method declarations</p>
  <pre><code>
    m1(int... x); (valid)
    m1(int ...x); (valid)
    m1(int...x);  (valid)
    m1(int x...); (invalid)
    m1(int. ..x); (invalid)
    m1(int .x..); (invalid)
  </code></pre>

<h6>case 2:</h6>
<p>We can mix var-arg parameter with normal parameter</p>
<pre><code>
  m1(int x, int... y);      (valid)
  m1(String s, double... y);(valid)
</code></pre>

<h6>case 3:</h6>
<p>If I mix normal parameter with var-arg parameter then var-arg parameter should
  be last parameter</p>
  <pre><code>
    m1(double... d, String s); (invalid)
    m1(char ch, String... s);  (valid)
  </code></pre>

<h6>case 4:</h6>
<p>Inside var-arg method we can take only one var-arg parameter and we cant take more than one var-arg parameter</p>
<pre><code>
  m1(int... x, double... d);
</code></pre>

<pre><code>
  class Test {
    p s v m(String[] args) {
      
    }
  }
  </code></pre>

<h6>case 5:</h6>
<p>Inside a class we cant declare var-arg method and corresponding array method simultaneously o/w we will get compile time error</p>
<pre><code>
  class Test {
    p s v m1(int... x) {
      SOP("int...");
    }
    p s v m(int[] x) {
       SOP("int[]"); 
    }
  }
  </code></pre>

  <pre><output>CE: cannot declare both m1(int[]) and m(int...) in Test</output></pre>

  <h6>case 6 :</h6>
  <pre><code>
    class Test {
      p s v m1(int... x) {
        SOP("var-arg method");
      }
      p s v m1(int x) {
         SOP("General method"); 
      }
      p s v main(String[] args) {
        m1();
        m1(10, 20);
        m1(10);
      }
    }
    </code></pre>

    <pre><output>
      var-arg method
      var-arg method
      General method
    </output></pre>

<p>In general var-arg method will get least priority i.e if no other method matched then only var-arg method will 
  get the chance. It is exactly same as default case inside switch
</p>

<h6>Equivalence between var-arg parameter and 1D array</h6>
<h6>case 1:</h6>
<p>Wherever 1D array present we can replace with var-arg parameter</p>
<p>m1(int[] x)  ->  m1(int... x)</p>

<p>Main of string array args can be replaced with main(String... x)</p>
<p>main(String[] args)  ->  main(String... x)</p>

<h6>case 2:</h6>
<p>Wherever var-arg parameter present we cant replace with 1D array</p>
<p>m1(int... x)   ->   m1(int[] x)    (invalid replacement)</p>

<mark>Note: 
  m1(int... x) we can call this method by passing a group of int values and x will become 1D array
</mark>

<mark>m1(int[]... x) we can call this method by passing a group of 1D int arrays and x will become 2D int array</mark>

<pre><code>
  class Test {
    p s v m(String[] args) {
      int[] a = {10, 20, 30};
      int[] b = {40, 50, 60};
      m1(a, b);
    }
    p s v m1(int[]... x) {
      for(int[] x1 : x) {
        SOP(x1[0]);
      }
    }
  }
  </code></pre>
  <pre><output>
    10 
    40
  </output></pre>
<h3>8. main method</h3>
<p>1. Whether class contains main method or not and whether main method is declared according to requirement or not. These things wont be checked by compiler.
  At run time jvm is responsible to check these things. If jvm unable to find main method then we will get Run Time Exception saying no such method error : main
</p>

<pre><code>
  class Test {
  
    
  }
  </code></pre>

  <pre><output>
    Exception in thread "main" java.lang.NoSuchMethodError: main
  </output></pre>

<p>2. At runtime jvm always searches for the main method with the following prototype</p>
<pre><code>
 public static void main(String[] args)
</code></pre>

<div class="container">
  <p class="bg-warning text-white">Why main method is public</p>
  <p>To call by jvm from anywhere it is a public</p>
</div>

<div class="container">
  <p class="bg-warning text-white">Why main method is static</p>
  <p>Without exist object also jvm has to call this method.</p>
</div>

<div class="container">
  <p class="bg-warning text-white">Why return type is void</p>
  <p>Main method wont return anything to jvm</p>
</div>

<div class="container">
  <p class="bg-warning text-white">Why the name is main</p>
  <p>This is name which is configured inside the jvm thats why jvm searches for main only</p>
</div>

<div class="container">
  <p class="bg-warning text-white">What about string array</p>
  <p>To pass command line arguments</p>
</div>
<h6>On removing static</h6>
<pre><code>
class Test {
  public void main(String[] args) {
      
  }
}
</code></pre>

<pre><output>
Exception in thread "main" java.lang.NoSuchMethodError: main
</output></pre>

<h6>On changing void to int</h6>
<pre><code>
class Test {
  public static int main(String[] args) {
        
  }
}
</code></pre>

<pre><output>
Exception in thread "main" java.lang.NoSuchMethodError: main
</output></pre>

<h6>On changin main to Main</h6>
<pre><code>
class Test {
  public static void Main(String[] args) {
          
  }
}
</code></pre>

<pre><output>
Exception in thread "main" java.lang.NoSuchMethodError: main
</output></pre>

<h6>On changing String[] args to String args</h6>
<pre><code>
class Test {
  public static void main(String args) {
            
  }
}
</code></pre>

<pre><output>
 Exception in thread "main" java.lang.NoSuchMethodError: main
</output></pre>

<p>3. The above syntax is very strict and if we perform any change then we will get run time exception saying no such method error: main</p>

<p>4. Even though above syntax is very strict the following changes are acceptable</p>

<p>Instead of public static we can take static public i.e the order of modifiers is not important</p>
<pre><code>
  class Test {
    static public void main(String[] args) {
              
    }
  }
  </code></pre>
<p>We can declare string array in any acceptable form</p>
<pre><code>
  class Test {
    public static void main(String[] args) {
              
    }
  }
</code></pre>
<pre><code>
    class Test {
      public static void main(String []args) {
                
      }
    }
</code></pre>
<pre><code>
      class Test {
        public static void main(String args[]) {
                  
        }
      }
</code></pre>

<p>Instead of args we can take any valid java identifier</p>
<pre><code>
  class Test {
    public static void main(String[] nc) {
              
    }
  }
</code></pre>

<p>We can replace string array with var-arg parameter</p>
<pre><code>
  class Test {
    public static void main(String... args) {
              
    }
  }
</code></pre>

<p>We can declare main method with the following modifiers final, synchonized and strictfp</p>

<pre><code>
  public class Test {
    static final synchronized strictfp public void main(String... durga) {
          System.out.println("Valid main method");
    }
  }
</code></pre>

<div class="container">
  <p class="bg-warning text-white">Which of the following main method is valid?</p>
  <p>public static void main(String args)<span style="color:red">Valid</span></p>
  <p>public static void Main(String[] args)<span style="color:red">Valid</span></p>
  <p>public void main(String[] args)<span style="color:red">Valid</span></p>
  <p>public static int main(String[] args)<span style="color:red">Valid</span></p>
  <p>final synchronized strictfp public void main(String[] args)<span style="color:red">Valid</span></p>
  <p>final synchronized strictfp public static void main(String[] args)<span style="color:green">Valid</span></p>
  <p>public static void main(String... args)<span style="color:green">Valid</span></p>
</div>

<div class="container">
  <p class="bg-warning text-white">Which of the above cases we will get compile time error</p>
  <p>We wont get compile time error anywhere but except last two cases in remaining we will get RE saying NoSuchMethodError: main</p>
</div>

<h6>Case 1:</h6>
<p>Overloading of the main method is possible but JVM will always call String[] arg only. The other overloaded method we have to call explicitly like other normal method</p>
<pre><code>
  class Test {
    public static void main(String[] args) {
      SOP("String[]");
    }
    public static void main(int[] args)  {
      SOP("int[]");
    }
  }
</code></pre>

<pre><output>
  String[]
</output></pre>

<h6>Case 2:</h6>
<p>Inheritance concept applicable for main method hence while executing child class if child doesn't contain main method then parent class main method will be executed.</p>
<pre><code>
  class P {
    public static void main(String[] args) {
      SOP("Parent main");
    }
  }
  class C extends P {

  }
</code></pre>

<img src="images/ss6.png" alt="ss6" width="300" height="300">

<h6>case 3:</h6>
<p></p>
<pre><code>
  class P {
    public static void main(String[] args) {
      SOP("Parent main");
    }
  }
  class C extends P {
    public static void main(String[] args) {
      SOP("child main");
    }
  }
</code></pre>
<img src="images/ss7.png" alt="ss7" width="300" height="300">
<p>It seems overriding concept applicable for main method but it is not overriding and it is method hiding</p>
<mark>Note: For main method inheritance and overloading concepts are applicable but overriding concept is not applicable. But instead of overriding, method hiding is applicable</mark>

<h6>1.7 version enhancements with respect to main method</h6>
<p>Until 1.6v if the class doesn't contain main method then we will get run time exception NoSuchMethodError: main but from 1.7v onwards instead of NoSuchMethodError we will get more elaborated information</p>
<p></p>

<pre><code>
  class Test {

  }
</code></pre>
<table class="table table-striped">
  <thead class="thead-dark">
    <tr>
    <th>1.6V</th>
    <th>1.7V</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><pre>
        Javac Test.java
        Java Test
        RE: NoSuchMethodError: main</pre>
      </td>
      <td><pre>
        Javac Test.java
        Java Test
        Error: Main method not found in class com.cts.java.Test, please define the main method as:
        public static void main(String[] args)</pre>
      </td>
    </tr>
  </tbody>
</table>

<p>From 1.7v onwards main method is mandatory to start program execution hence even though class contains static block it won't be executed if the class doesn't contain main method</p>


<pre><code>
  class Test {
    static {
      SOP("Static Block")
    }
  }
</code></pre>
<table class="table table-striped">
  <thead class="thead-dark">
    <tr>
    <th>1.6V</th>
    <th>1.7V</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><pre>
        Javac Test.java
        Java Test
        Static Block
        RE: NoSuchMethodError: main</pre>
      </td>
      <td><pre>
        Javac Test.java
        Java Test
        Error: Main method not found in class com.cts.java.Test, please define the main method as:
        public static void main(String[] args)</pre>
      </td>
    </tr>
  </tbody>
</table>

<p>From 1.7v onwards main method is mandatory to start program execution</p>
<pre><code>
  class Test {
    static {
      SOP("Static Block")
      System.exit(0);
    }
  }
</code></pre>

<table class="table table-striped">
  <thead class="thead-dark">
    <tr>
    <th>1.6V</th>
    <th>1.7V</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><pre>
        Javac Test.java
        Java Test
        Static Block
      </td>
      <td><pre>
        Javac Test.java
        Java Test
        Error: Main method not found in class com.cts.java.Test, please define the main method as:
        public static void main(String[] args)</pre>
      </td>
    </tr>
  </tbody>
</table>

<pre><code>
  class Test {
    static {
      SOP("Static Block");
    }
    public static void main(String[] args) {
      SOP("Main method");
    }
  }
</code></pre>

<table class="table table-striped">
  <thead class="thead-dark">
    <tr>
    <th>1.6V</th>
    <th>1.7V</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><pre>
        Javac Test.java
        Java Test
        Static Block
        Main Method</pre>
      </td>
      <td><pre>
        Javac Test.java
        Java Test
        Static Block
        Main method</pre>
      </td>
    </tr>
  </tbody>
</table>

<table class="table table-striped">
  <thead class="thead-dark">
    <tr>
    <th>1.6V Execution flow</th>
    <th>1.7V Execution flow</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <img src="images/ss81.6.png" width="400" height="500">
      </td>
      <td>
        <img src="images/ss81.7.png" width="400" height="500">
      </td>
    </tr>
  </tbody>
</table>

<div class="container">
  <p class="bg-warning">Without writing main method is it possible to print some statements to the console?</p>
  <p>Yes by using static block but this rule is applicable until 1.6v but from 1.7v onwards it is impossible to
     print some statement to the console without writing main method</p>
</div>


<h3>9. command line arguments</h3>
<p>The arguments which are passing from command prompt are called command line arguments. With these command line 
  arguments jvm will create an array and by passing that array as argument jvm will call main method
</p>
<p>Example</p>
<p>Java test A B C<kbd>enter</kbd></p>
<p><pre>
  A - args[0]
  B - args[1]
  C - args[2]
  length - args.length - 3
</pre></p>

<h6>Main objective of command line argument</h6>
<p>We can customize behaviour of the main method</p>

<h6>Why command line arguments are always string</h6>
<p>String is the most common used object thats why some people gave priority to the string type and we can easily convert it into other types also</p>

<h6>Case 1:</h6>
<pre><code>
  class Test {
    public static void main(String[] args) {
      String[] argh = {"x", "y", "z"};
      args = argh;
      for(String s : args) {
        SOP(s);
      }
    }
  }
</code></pre>

<pre><output>
  java Test A B C
  x
  y
  z
  java Test A B
  x
  y
  z
  java Test 
  x
  y
  z
</output></pre>

<h6>case 2:</h6>
<p>Within main method commad line arguments are available in string form</p>
<pre><code>
  class P {
    public static void main(String[] args) {
      SOP(args[0] + args[1]);
    }
  }
</code></pre>
<pre><output>
java test 10 20
1020
</output></pre>

<h6>case 3:</h6>
<p>Usually space itself is the separator between command line arguments. If our command line argument itself contain space then we have to enclose that command line argument within double quotes</p>
<pre><code>
  class P {
    public static void main(String[] args) {
      SOP(args[0]);
    }
  }
</code></pre>

<pre><output>
  javac Test "Note Book"
  Note Book
</output></pre>

<h3>10. java coding standards</h3>
        
        
</body>
</html>
