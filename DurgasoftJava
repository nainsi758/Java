<html>
    <head>
        <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
        <title>Java</title>
        <style>
            h1 {
                color: red;
            }
            h3 {
                color: darkblue;
            }
            h6 {
                color:crimson; 
            }
            h5 {
                color:darkmagenta;
            }
            table th {
                text-align: center;
            }
        </style>
    </head>
    <body>
        <h1>Language Fundamentals</h1>
        <h3>1. Identifiers</h3> A name which can be used for identification purpose. It can be method name, variable name, class name and label name </p>
        <pre>
          <code>
            class <span style="background-color:rgb(0, 255, 255);">Test</span> {
              public static void <span style="background-color:rgb(0, 255, 255);">main</span>(<span style="background-color:rgb(0, 255, 255);">String</span>[] <span style="background-color:rgb(0, 255, 255);">args</span>) {
                int <span style="background-color:rgb(0, 255, 255);">x</span> = 10;
              }
            }
          </code>
        </pre>
        <p>The only allowed characters in java identifiers are </p>
        <ol>
          <li>a to z</li>
          <li>A to Z</li>
          <li>0 to 9 </li>
          <li>$</li>
          <li>_</li>
        </ol>
        <p>Which of the following are valid identifiers?</p>
        <ol>
          <li>total_number</li>
          <li>total#</li>
          <li>123total</li>
          <li>total123</li>
          <li>ca$h</li>
          <li>_$_$_$_$_$_$</li>
          <li>all@hands</li>
          <li>Java2Share</li>
          <li>Integer</li>
          <li>Int</li>
          <li>int</li>
        </ol>
        <ol>
          <li>valid</li>
          <li>invalid</li>
          <li>invalid</li>
          <li>valid</li>
          <li>valid</li>
          <li>valid</li>
          <li>invalid</li>
          <li>valid</li>
          <li>valid</li>
          <li>valid</li>
          <li>invalid</li>
        </ol>
        <p>Identifiers should not start with digit.</p>
        <p>Java Identifiers are case sensitive. Ofcourse java language itself is treated as case sensitive programming language.</p>
        <pre>
          <code>
            class Test {
                int number = 10;
                int Number = 20;
                int NUMBER = 30;
            }
          </code>
        </pre>
        <p>We can differentiate wrt case.</p>
        <p>There is no length limit for java identifiers but it is not recommended to take too lengthy identifiers.</p>
        <pre>
          <code>
            int if = 20;  <span>&#10060;</span>
          </code>
        </pre>
        <mark>We can't use reserved word as identifiers.
        Predefined class name and interface names can be used as identifiers</mark>
        <pre>
          <code>
            class Test {
              p s v m(String[] args) {
                int String = 888;
                SOP(String);
              }
            }
          </code>
        </pre>
        <p>Output <br>888</p>
        <pre>
          <code>
            class Test {
              p s v m(String[] args) {
                int Runnable = 999;
                SOP(String);
              }
            }
          </code>
        </pre>
        <p>Output <br>999</p>
        <h3>2. Reserved Words</h3>
        <p>Some words are reserved to represent some meaning or functionality called reserved words.</p>
        <mark>Total 53 reserved words are there.
             In them 50 are keywords and <span class="bg-warning text-white">3 are reserved literals</span>.
        </mark>
        <h5>keyword(Unused keywords - goto const)</h5>
        <p>If the reserved word associated with functionality. <span class="bg-warning text-white">48 keywords are used keywords</span> and <span class="bg-warning text-white">2 are unused.</span></p>
        <p><h5>Reserved literals(true false null)</h5>If the reserved word only to represent value.
        

        <div class="container-fluid">
            <div class="row">
                <div class="col-sm-1" style="background-color:lavender;"><h6>Keywords for data types(8)</h6><p>byte<br>short<br>int<br>long<br>float<br>double<br>boolean<br>char</p></div>                  
                <div class="col-sm-1" style="background-color:lavenderblush;"><h6>Keywords for flow control(11)</h6><p>if<br>else<br>switch<br>case<br>default<br>while<br>do<br>for<br>break<br>continue<br>return</p></div>
                <div class="col-sm-1" style="background-color:lavender;"><h6>Keywords for modifiers(11)</h6><p>public<br>private<br>protected<br>static<br>final<br>abstract<br>synchronized<br>native<br>strictfp(1.2)<br>transient<br>volatile</p></div>
                <div class="col-sm-1" style="background-color:lavenderblush;"><h6>Keywords for exception handling(6)</h6><p>try<br>catch<br>finally<br>throw<br>throws<br>assert(1.4)</p></div>
                <div class="col-sm-1" style="background-color:lavender;"><h6>Class related keywors(6)</h6><p>class<br>interface<br>extends<br>implements<br>package<br>import</p></div>
                <div class="col-sm-1" style="background-color:lavenderblush;"><h6>Object related keywords(4)</h6><p>new<br>instanceof<br>super<br>this</p></div>
                <div class="col-sm-1" style="background-color:lavender;"><h6>Void return type keyword(1)</h6><p>void</p></div>
                <div class="col-sm-1" style="background-color:lavenderblush;"><h6>Enum Keyword(1)</h6><p>enum(1.5)</p></div>
                <div class="col-sm-1" style="background-color:lavender;"><h6>Unused keywords(2)</h6><p>goto<br>const</p></div>
                <div class="col-sm-1" style="background-color:lavenderblush;"><h6>Reserved literals(3)</h6><p>true<br>false<br>null</p></div>
            </div>
        </div>
        <p>Goto - Usage of goto created several problems in old languages and hence SUN people banned this keyword in java.</p>
        <p>const - Use final instead of const.</p>
        <p>goto and const are unused keywords but if we are trying to use we will get CE.</p>
        <p>null - default value for object reference.</p>
        <p>true, false - values for boolean data type.</p>
        <mark>Delete keyword is not there because destruction of the object is responsibility of garbage collector</mark>
        <br><br><p>Enum - We can use enum to define a group of named constants</p>
        <pre>
          <code>
            enum month {
              JAN, FEB,... DEC;
            }
          </code>
        </pre>
        <p>All 53 reserved words in java contains only lower case alphabet symbols.</p>
        <mark>In java return type is mandatory</mark>
        <br><br><h3>3. Data Types</h3>
        <p>In java every variable and every expression has some type. Each and every datatype is clearly defined. Every assignment should be checked by compiler for type compatibility because of above reasons we can conclude java language is strongly typed  programming language</p>
        <div class="container-fluid">
            <p class="bg-warning text-white">Is java pure oop language or not?</p>
        
            <p>Java is not considered as pure oop language because several oop feature is not supported by java. Like operator overloading and multiple inheritance etc. We are depending on primitive data types which are non-objects</p>
        </div>

        <h5>Primitive data types(8)</h5>
        <p>Numeric data types - Data types which can be used to represent only numbers</p>
        <p>Non-Numeric data types - Data types which can be used to represent non-numeric data like char and boolean</p>
        <p>Except char and boolean remaining data types are signed data types because we can represent both positive and negative numbers.</p>
        <p>0 represents positive number and 1 represents negative number. Positive numers will be represented directly in a memory whereas as negative numbers will be represented in 2's compliment form.</p>
        <p> If we want to handle data in terms of streams either from the file or from the network(file supported form or the the network supported form is byte data type)</p>
        <p>Short is the most rarely used data type in java</p>
        <p>Ex:-I want to write data to a file or I want to send data across a network.</p>
        <p>If we want 5 to 6 decimal places of accuracy go for float. <span class="text-primary">Float follows single precision.</span></p>
        <p>If we want 14 to 15 decimal places of accuracy go for double. <span class="text-primary">Double follows double precision</span></p>
        <table class="table table-striped" >
            <thead class="thead-dark">
              <tr>
                <th colspan="3">Primitive data types(8)</th>
              </tr>
              <tr>
                <th colspan="2">Numeric Data Type</th>
                <th>Non numeric Data Type</th>
              </tr>
              <tr>
                <th>Integral Data Type</th>
                <th>Floating Point Data Type</th>
                <th></th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Byte(size 1 bytes 8 bits) -128 to +127 Wrapper class-Byte Default value-0</td>
                <td>float(size 4 bytes) -3.4e38 to 3.4e38 means (-3.4*10<sup>38</sup> to 3.4*10<sup>38</sup>) Wrapper class-Float Default value-0.0</td>
                <td>character(2 bytes) 0 to 65535 Wrapper class-Character Default value-0(represents space character)</td>
              </tr>
              <tr>
                <td>Short(2 bytes 16 bits) -2<sup>15</sup>to 2<sup>15</sup>-1(-32768 to 32767) Wrapper class-Short Default value-0</td>
                <td>double(size 8 bytes) -1.7e308 to 1.7e308 Wrapper class-Double Default value-0.0</td>
                <td>boolean(true and false) Wrapper class-Boolean Default value-false</td>
              </tr>
              <tr>
                <td>Int(4 bytes 32 bits) -2<sup>31</sup>to 2<sup>31</sup>-1(-2147483648 to 2147483647) Wrapper class-Integer Default value-0</td>
              </tr>
              <tr>
                <td>Long(8 bytes 64 bits) -2<sup>63</sup>to 2<sup>63</sup>-1 Wrapper class-Long Default value-0</td>
              </tr>
            </tbody>
          </table>
<p>The number of characters present in a big file may exceed int range, hence the return type of length method is long but not int.</p>
<code>long l = f.length()</code><br><br>
          <code>
              <pre>
                  int x=1;
                  if(x) {
                      SOP("Hii");
                  } else {
                      SOP("Bye");
                  }
                </pre>
             </code>
             <code>
               <pre>
                 boolean b = True;

                 Output:
                 Can't find symbol
                 symbol : variable True
                 location : class Test
               </pre>
             </code>
             <p class="text-primary"> This code will give error because this was possible in old languages. Here it is expecting boolean so provide boolean only</p>
             </div>
        <div class="container-fluid">
            <p class="bg-warning text-white">Why java uses 2 byte instead of 1 byte for char?</p>
            <p>Because java uses unicode, old language uses ascii code(1 byte is sufficient to represent 256 bits)</p>
        </div>

        <mark>Null is the default value for object reference so we can't use it for primitive types(o/w CE)</mark>

        <h3>4. Literals</h3>

        
        
        <p>A constant value wich can be assigned to the variable is called literal</p>
        <code>int x = 10;</code>
        <p>Here 10 is literal</p>

        <h5>Integral Literals</h5> <p>For integral data types byte short int long we can specify literal value in the following ways.</p>

        <h6>Decimal Form (base-10 means allowed digits are 0 to 9)</h6>
        <p>Bydefault decmal only</p>
        <h6>Octal value(base-8 means allowed digits are 0 to 7)</h6>
        <p>If a number prefixed with 0 is considered as octal value</p>
        <h6>Hexadecimal form(base-16 means allowed digits are 0 to 9 and A to F)</h6>
        <p>Java is case sensitive, here for extra digits(a to f) we can use both lower case and upper case characters. This is one of very few areas where java is not case sensitive. For prefix also x can be uppercase or lowercase.</p>

        <p>If a number prefixed with 0x is considered as hexadecimal value</p>
        
        <pre><code>
          int x = 10;
          int y = 010;
          int z = 0x10;
        </code></pre>

        <pre><output>Output : 10 8 16</output></pre>
        
        <p>By default every integral literal is of int type but we can specify explicitly as long type by suffixed with l or L</p>

        <pre><code>
          int x = 10L;
        </code></pre>
        <pre><output>Wrong because assigning 8 byte to 4 byte</output></pre>

        <h5>Floating Point Literals</h5>
        <pre><code>
        1. float f = 123.456f;
        2. double d = 0123.456D
        3. double d = 0x123.456
        4. double d = 0786
        5. double d = 0xFace
        6. double d = 10
        7. double d = 0xFace.0
        8. double d = 0777
        9. double d = 1.2e3  
      </code></pre> 

      <pre><output>
        1. Valid. By default every Floating type literal is of type double type and hence we 
        cant assign directly to the float variable but we can specify floating point literal
         as float type by suffixed with f or F
        2. Valid(treated as Decimal only)
        Floating point literals we can specify only in decimal form. We can't use octal and
         hexa with floating point literals only can use with integral literal type 
        3. Not valid
        4. Not valid
        No decimal point is there so treated as integral type only and as being integral it is
         prefixed with 0 so it will be treated as octal hence octal allows (0 -7) here 8 is there
          CE: Integer number too large
        5. Valid It is integral literal. Starts with 0x so hexadecimal. Face is allowed value.
        And we can assign integral literal directly to floating point variable and that integral 
        literal can be specified either in decimal or octal or hexadecimal.
        6. Valid. 10.0
        7. Invalid
        8. Valid 
        9. Valid
      </output></pre>
      <p>We can specify floating point literals only in decimal form and we can't specify in octal and hexadecimal forms. O/w CE: malformed floating point literals.</p>

        <h5>Boolean Literals</h5>
        <p>Only allowed values for boolean literals are true or false</p>

        <h5>Char Literals</h5>
        <p>We can specify char literal as integral literal which represents unicode value of the character and that integral literal can be specified either in decimal or octal or hexa decimal forms but allowed range is 65535</p>
        <pre><code>
          1. char ch = "a"
          2. char ch = 'abc'
          3. char ch = 97
          4. char ch = 65536
        </code></pre>

        <pre><output>
          1. Invalid because string not allowed
          2. CE : Unclosed character literal, not a java statement
          3. a
          4. Found int req char
        </output></pre>
        <p>We can represent char literals in unicode representation which is nothing but '\u0061' (represents a : convert 97 to hexadecimal)</p>
        <table class="table table-striped" >
          <thead class="thead-dark">
            <tr>
              <th>Escape characters</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>\n</td>
              <td>new line</td>
            </tr>
            <tr>
              <td>\t</td>
              <td>Horizontal tab</td>
            </tr>
            <tr>
              <td>\r</td>
              <td>carriage return</td>
            </tr>
            <tr>
              <td>\b</td>
              <td>backspace character</td>
            </tr>
            <tr>
              <td>\f</td>
              <td>form feed</td>
            </tr>
            <tr>
              <td>\'</td>
              <td>Single quote</td>
            </tr>
            <tr>
              <td>\"</td>
              <td>Double quote</td>
            </tr>
            <tr>
              <td>\\</td>
              <td>backslash character</td>
            </tr>
          </tbody>
        </table>
        <div class="container-fluid">
          <p class="bg-warning text-white">Which of the following are valid representation?</p>
          <code>
            <pre>
              char ch = 65536;
              char ch = 0XBeer;
              char ch = \uface;
              char ch = '\ubeef';
              char ch = '\m';
              char ch = '\iface';


              Output:
              Invalid
              Invalid
              Invalid
              Valid 
              Invalid
              Invalid
            </pre>
          </code>
          
      </div>
        <h5>String Literals</h5>
        <pre><code>string s = "a"</code></pre>

        <h5>Binary Literals(from 1.7v onwards)</h5>
        <pre><code>int b = 0b1111</code></pre>
        <pre><output>15</output></pre>

        <h5>Using underscore with numeric literals for readibility(from 1.7v onwards)</h5>
        <pre><code>double d = 1_23_456.7_8_9</code></pre>
        <p>At the time of compilation these underscores symbols will be removed automatically
          hence after compilation above lines will become 
        </p>
        <pre><code>
          double d = 123456.789;
          double d = 1_____23_____456.7_8_9
        </code></pre>
        <pre><output>
          ALso valid</output></pre>

        <pre><code>
          double d = _1_23_456.7_8_9
        </code></pre>
        <pre><output>
          Invalid
        </output></pre>

        <p>We can use underscore symbols only with in the digits</p>
        <img src="images/ss13.png" alt="data representation" width="400" height="
        500">
        <p>byte(1B)-----> short(2B) ------> int(4B) -----> long(8B) -----> float(4B) -----> double(8B)</p>
        <p>char(2B) -----> int(4B) -----> long(8B) -----> float(4B) -----> double(8B)</p>
        <p>short and char both are having 2B so why we can't assign each other. First both are different data type, Second signed and unsigned, 16 bit char in 15 bit short(1 for sign)</p>
        <p>8 byte long value we can assign to 4 B float variable bcoz both are following diff memory representation internally.</p>
        <h3>5. Arrays</h3>
        <h5>Introduction</h5>
        <p>An array is an indexed collection of fixed number of homogeneous data elements.</p> 
        <p>The main advantage of array is we can represent huge number of values by using single variable so that readibility of the code will
          be improved. 
        </p>
        <p>The main disadvantage of the array is fixed in size i.e once we creates an array there is no chance of increasing 
          or decreasing of size based on our requirement. Hence to use arrays concept compulsory we should know the size in advance which may not possible always.
        </p>

        <h5>Array Declaration</h5>
        <h6>1-D array declaration</h6>
        <code>int[] x;</code>(recommended because name is clearly separated from type.)<br>
        <code>int []x;</code><br>
        <code>int x[];</code><br>

        <code>int[6] x;</code>(Invalid)
        <p><span class="text-primary">At the time of declaration we cant specify the size o/w we will get compile time error</span></p>


        <h6>2-D array declaration</h6>
        <code>int[][] x;</code>(recommended)<br>
        <code>int [][]x;</code><br>
        <code>int x[][];</code><br>
        <code>int[] []x;</code><br>
        <code>int[] x[];</code><br>
        <code>int []x[];</code><br>

        <code>int[] a, b;</code>(a-1D b-1D)<br>
        <code>int[] a[],b;</code>(a-2D b-1D)<br>
        <code>int[] a[], b[];</code>(a-2D b-2D)<br>
        <code>int[] []a, b;</code>(a-2D b-2D)<br>
        <code>int[] []a, b[];</code>(a-2D b-3D)<br>
        <code>int[] []a, []b;</code>(Invalid compilation error)<br>
        <p>If we want to specify dimension before the variable that facility is applicable only for first variable in a declaration.
          If we are trying to apply for remaining variable we will get Compile time error
        </p>

        <h6>3-D array declaration</h6>
        <code>int[][][] x;</code><br>
        <code>int [][][]x;</code><br>
        <code>int x[][][];</code><br>
        <code>int[] [][]x;</code><br>
        <code>int[] x[][];</code><br>
        <code>int[] []x[];</code><br>
        <code>int[][] []x;</code><br>
        <code>int [][]x[];</code><br>
        <code>int []x[][];</code><br>

        <h5>Array Creation</h5>
        <h6>1-D Array Creation</h6>
        <code>int[] x = new int[3];</code><br>
        <p>Every array in java is an object only hence we can create arrays by using new operator.</p>
        <p>For every array type corresponding classes are available and these classes are part of java language and not available to the programmer level.</p>
        <code>SOP(a.getClass().getName());</code><output>[I</output><br>

        <table class="table table-striped" >
          <thead class="thead-dark">
            <tr>
              <th>Array Type</th>
              <th>Corresponding Class Type</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>int[]</td>
              <td>[I</td>
            </tr>
            <tr>
              <td>int[][]</td>
              <td>[[I</td>
            </tr>
            <tr>
              <td>double[]</td>
              <td>[D</td>
            </tr>
            <tr>
              <td>short[]</td>
              <td>[S</td>
            </tr>
            <tr>
              <td>byte[]</td>
              <td>[B</td>
            </tr>
            <tr>
              <td>boolean[]</td>
              <td>[Z</td>
            </tr>
          </tbody>
        </table>

        <h6>Loophole 1: </h6>
        <p>At the time of array Creation compulsory we should specify the size o/w how the jvm will reserve the size and hence CE will come.</p>
        <pre><code>
          int[] x = new int[];
          int[] x = new int[6];
          int[] x = new int[0];
          int[] x = new int[-3];
          int[] x = new int['a'];
        </code></pre>

        <pre><output>
          CE
          valid
          valid
          valid at compile time but run time exception - negative array size exception
          valid - char to int promotion acceptable so size will be 97
        </output></pre>
        <p>byte(1B)-----> short(2B) ------> int(4B)</p>
        <p>char(2B) -----> int(4B)</p>

        <p>Only integer value allowed for size so till int every data type is acceptable means whose promotion to int is acceptable</p>

        <pre><code>int[] x = new int[10l];</code></pre>
        <pre><output>
          Invalid becuse long cant get promoted to int so we will get compile time error
        </output></pre>

        <p>The maximum allowed array size in java is 2147483647(int max size). Even in this case we can get run time error if sufficient heap memory is not available</p>
        
        <h6>2-D Array Creation</h6>
        <h6>Array of arrays</h6>
        <p>In java 2D array not implemented by using matrix style some people followed array of arrays approach for multi dimensional array creation, the main adv of this approach is memory utilization will be improved</p>

        <pre><code>
        int[][] x = new int[2][];
        x[0] = new int[2];
        x[1] = new int[3];
      </code></pre>

      <h6>3-D Array Creation</h6>
      <pre><code>
        int[][][] x = new int[2][][];
        x[0] = new int[3][];
        x[0][0] = new int[1];
        x[0][1] = new int[2];
        x[0][2] = new int[3];
        x[1] = new int[2][2];
      </code></pre>
      <div class="container-fluid">
        <p class="bg-warning text-white">Which of the following array declarations are valid?</p>
        <pre><code>
          int[] a = new int[];
          int[] a = new int[3];
          int[][] a = new int[][];
          int[][] a = new int[3][];
          int[][] a = new int[][4];
          int[][] a = new int[3][4];
          int[][][] a = new int[3][4][5];
          int[][][] a = new int[3][4][];
          int[][][] a = new int[3][][5];
          int[][][] a = new int[][4][5];


          Output:- 
          invalid
          valid 
          invalid 
          valid 
          invalid 
          valid 
          valid 
          valid 
          invalid 
          invalid
        </code></pre>
    </div>

    
      <pre>
        <code>
        int[][] x = new int[2][3];
        SOP(x);
        SOP(x[0]);
        SOP(x[0][0]);

        Output:- 
        [[I@u09a
        [I@8hr9
        0
      </code>
      </pre>
    

      <mark>Once we creates an array every array element by default initialized by value 0</mark>
      <br><br><mark>Whenever we are trying to print any reference variable, internally toString() method will be called which is implemented by default to return the string in classname@hashcode_in_hexadecimal form</mark>

      <pre><code>
        int[][] x = new int[2][];
        SOP(x);
        SOP(x[0]);
        SOP(x[0][0]);
      </code></pre>

      <pre><output>
        [[I@0u5b7a 
        null 
        NullPointerException
      </output></pre>
      <p>If we don't initialize any object by default it will be initialized with null.</p>
      <p>If we are trying to perform any operation on null then we will get RE by saying NullPointerException</p>
      <p>If we are trying to access array element with out of range index(either positive or negative int value) then we will get RE: ArrayIndexOutOfBoundsException.</p>
      <p>Float value as index : Possible loss of precision becuase index expecting integer value only.</p>
      <h5>Array declaration, Creation and Initialization in a single line</h5>
        <code>int[] x = {10, 20, 30};</code><br>
        <code>int[][] x = {{10, 20}, {30, 40, 50}};</code><br>
        <code>int[][][] x = {{{10, 20, 30}, {40, 50, 60}}, {{70, 80}, {90, 100}}};</code><br>

        <h5>length vs length()</h5>
        <pre><code>
        int[] x = new int[6];
        SOP(x.length());
      </code></pre>

      <pre><output>
        cannot find symbol
        System.out.println(x.length());
                                    ^
        symbol:   method length()
          location: variable x of type int[]

      </output></pre>

      <pre><code>
        int[] x = new int[6];
        SOP(x.length);
      </code></pre>

      <output>
        6
      </output><br>

      <mark>Length is a final variable applicable for arrays. length variable represents the size of the array.</mark>

      <pre><code>
        String s = "durga";
        SOP(s.length);
      </code></pre>

      <pre><output>
        error: cannot find symbol
                System.out.println(s.length);
                                    ^
                symbol:   variable length
                location: variable s of type String

      </output></pre>

      <pre><code>
        String s = "durga";
        SOP(s.length());
      </code></pre>

      <output>Output - 5</output><br>

      <p>length() method is a final method applicable for string objects. length() returns number of characters present in the string</p>

      <pre><code>
        String s = {"a", "aa", "aaa"};
        SOP(s.length);
        SOP(s.length());
        SOP(s[0].length);
        SOP(s[0].length());
      </code></pre>

      <pre><output>
        3
        CE
        CE
        1
      </output></pre>
      

      <pre><code>
        int[][] x = new int[6][3];
        SOP(x.length);
        SOP(x[0].length());
      </code></pre>

      <output>Output: 6 3</output><br>

      <mark>In multidimensional arrays length variable represents only base size but not total size.</mark>
      <p>There is no direct way to find total length of multidimensional array but indirectly we can find as follows</p>
      <p>x[0].length + x[1].length + x[2].length.............</p>

        <h5>Annonymous arrays</h5>
        <p>Sometimes we can declare an array without name such type of nameless arrays are called annonymous arrays</p>
        <p>The main purpose of annonymous arrays is just for instant use(one time usage)</p>
        <p>We can create annonymous arrays as follows- new int[]{10, 20, 30};</p>
        <p><span class="text-primary">While creating annonymous arrays we can't create the size o/w we will get compile time error</span></p>
        
        <code>new int[]{10, 20, 30, 40, 50};</code>Valid<br>
        <code>new int[5]{10, 20, 30, 40, 50};</code>Invalid

        <pre><code>
          class Test {
            p s v m(String[] args) {
              sum(new int[] {10, 20, 30, 40, 50});
            }
            p s v sum(int[] x) {
                int total = 0;
                for(int x1 : x) {
                    total = total + x1;
                }
                SOP("The sum : " + total);
            }
          }
          </code></pre>

        <p>In the above example just to call sum method we required an array but after completing sum method call we are not using that array anymore hence for this one time requirement annonymous array is the best choice</p>

        <p>We can create multidimensional annonymous arrays as follows- new int[][]{{10, 20}, {30, 40, 50}};</p>
        
        <p>Based on our requirement we can give the name for annonymous array then it is no longer annonymous</p>
        <code>int[] x = new int[]{10, 20, 30};</code>


        <h5>Array element assignments</h5>
        <p>In the case of object type arrays, as array elements we can provide either declared type objects or its child class objects</p>
        <pre><code>
        Object[] a = new Object[10];
        a[0] = new Object();
        a[1] = new String("durga");
        a[2] = new Integer(10);
        </code></pre>

        <pre><code>
          Number[] a = new Number[10];
          a[0] = new Integer(10);
          a[1] = new Double(10.5);
          a[2] = new String("Durga");
        </code></pre>

        <p>Here a[2] is invalid because String is not the child class of Number</p>

        <p>For interface type arrays, as array elements its implementation class objects are allowed</p>
        <pre><code>
          Runnable[] r = new Runnable[10];
          r[0] = new Thread();
          r[1] = new String("durga");
        </code></pre>
<p>We are not creating Runnable object, just creating Runnable type array object. Interface type array object we can create but interface object we cant create.</p>
        <pre><output>
          incompatible types: String cannot be converted to Runnable
                r[1] = new String("durga");
                       ^

        </output></pre>

        <table class="table table-striped" >
          <thead class="thead-dark">
            <tr>
              <th>Array Type</th>
              <th>Allowed Element Types</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Primitive Arrays</td>
              <td>Array type which can be implicitly promoted to declared type.</td>
            </tr>
            <tr>
              <td>Object Type Arrays</td>
              <td>Either declared type or its child class objects.</td>
            </tr>
            <tr>
              <td>Abstract class type arrays</td>
              <td>Its child class objects are allowed(Example - Number is an abstract class)</td>
            </tr>
            <tr>
              <td>Interface type array</td>
              <td>Its implementation class objects are allowed</td>
            </tr>
          </tbody>
        </table>

        <h5>Array variabe assignments</h5>
        <p>Element level promotion are not applicable at array level. For example char element can be promoted to int type whereas char array cant be promoted to int array</p>
        <pre><code>
          int[] x = {10, 20, 30, 40};
          char[] ch = {'a', 'b', 'c', 'd'};
          int[] b = x;
          int[] c = ch;
        </code></pre>

        <pre><output>
          valid
          CE : incompatible types: char[] cannot be converted to int[]
        </output></pre>

        <div class="container">
        <p class="bg-warning text-white">Which of the following promotions will be performed automatically</p>
        <pre><code>
        char     ---> int       
        char[]   ---> int[]     
        int      ---> double    
        int[]    ---> double[]  
        float    ---> int       
        float[]  ---> int[]    
        String   ---> Object    
        String[] ---> Object[]  
        </code></pre>

        <pre><output>
          valid
          invalid
          valid
          invalid
          invalid
          invalid
          valid
          <span class="bg-danger text-white">valid</span>
        </output></pre>
        <p>But in the case of object type arrays, child class type array can be promoted to parent class type array.</p>
        <pre><code>
          String[] s = {'a', 'b', 'c'};
          Object[] a = s; 
        </code></pre> 

        <pre><output>
          valid
        </output></pre>
        
        
        <pre><code>
          int[] a = {10, 20, 30, 40, 50, 60};
          int[] b = {70, 80};
          a = b;  
          b = a;  
        </code></pre>
        <pre><output>
          valid
          valid
        </output></pre>
      </div>

      <p>Whenever we are assigning one array to another array intrenal elements wont be copied just reference variable will be reassigned</p>

      <pre><code>
        int[][] a = new int[3][];
        a[0] = new int[4][3];     
        a[0] = 10;               
        a[0] = new int[2];        
      </code></pre>

      <pre><output>
        CE: incompatible types 
        found: int[][] 
        required: int[]

        CE: incompatible types 
        found: int 
        required: int[]

        valid
      </output></pre>

      <p>Whenever we are assigning one array to another array the dimensions must be matched for ex in the place of 1D int array we should provide
        1D array only if we are trying to provide any other dimension then we will get compile time error</p>

       
       
      <pre><code>
        int[][] a = new int[4][3];
        a[0] = new int[4];
        a[1] = new int[2];
        a = new int[3][2];
      </code></pre>

      <p>Whenever we are assigning one array to another array both dimensions and types must be matched but sizes are not required to match</p>

      <p style="color:red">Total how many objects created?</p>
        <p>11</p>
        <p style="color:red">Total how many objects eligible for garbage collector?</p>
        <p>7</p>

        <img src="images/ss1.png" alt="ss1" width="500" height="300">

        <h3>6. Types of variables</h3>
        <h4>Division 1:</h4>
        <p>Based on type of value represented by a variable all variables are divided into two types</p>
        <h5>1. Primitive Variables</h5>
        <p>can be used to represent primitive values</p>
        <code>int x = 10;</code>
        <p>Here x is a primitive variable</p>
        <h5>2. Reference variables</h5>
        <p>Can be used to refer objects</p>
        <code>Student s = new Student();</code>

        <h4>Division 2:</h4>
        <p>Based on position of declaration and behavior all variables are divided into three types.</p>
        <p>1. Instance variables</p>
        <p>2. Static variables</p>
        <p>3. Local variables</p>

        <h5>Instance variables</h5>
        <p>1. If the value of a variable is varied from object to object such type of variables are called instance variables</p>
        <p>2. For every object a seperate copy of instance variable will be created</p>
        <p>3. Instance variables should be declared within the class directly but outside of any method or block or constructor</p>
        <p>4. Instance variable will be created at the time of object creation and destroyed at the time of object destruction. Hence the scope of instance variable is exactly same as the scope of object</p>
        <p>5. Instance variables will be stored in the heap memory as the part of object</p>
        <p>6. We cant access instance variables directly from static area but we can access by using object reference</p>
        <p>7. But we can access instance variable directly from instance area</p>

        <pre><code>
          class Test {
            int x = 10;
            public static void main(String[] args) {
              SOP(x);   (CE: non static variable x cannot be referenced from a static context)
              Test t = new Test();
              SOP(t.x);   10
            }
            public void m1() {
              SOP(x);   10
            }
          }
        </code></pre>

        <p>8. For instance variables jvm will always provide default values and we are not required to perform initialization explicitly</p>

        <pre><code>
          class Test {
            int x;
            double d;
            boolean b;
            String s;
            p s v m(String[] args) {
              Test t1 = new Test();
              SOP(t1.x);    0
              SOP(t1.d);    0.0
              SOP(t1.b);    false
              SOP(t1.s);    null
            }
          }
        </code></pre>

        <p>9. Instance variables also known as object level variables or attributes</p>

        <h5>Static variables</h5>

        <pre><code>
        class Student {
          String name;
          int roll no;
          String collegename;
        }
        </code></pre>

        <img src="images/ss3.png" alt="ss1" width="500" height="300">
        <p>1. If the value of a variable is not varied from object to object then its not recommended to declare variable as instance variable we have to declare such type of variables at class level by using static modifier</p>
        <p>2. In the case of instance variables for every object a separate copy will be created but in the case of static variables a single copy will be created at class level and shared by every object of the class</p>
        <p>3. Static variables should be declared with in the class directly but outside of any method or block or constructor</p>
        <p>4. Static variables will be created at the time of class loading and destroyed at the time of class unloading. Hence scope of static variable is exactly same as scope of .class file</p>

        <pre><code>
          java Test<kbd>enter</kbd>
          1. Start JVM
          2. create & start main Thread
          3. locate Test.class file
          4. load Test.class        (Static variables creation)
          5. Execute main() method
          6. unload Test.class      (Static variables destruction)
          7. Terminate main Thread
          8. Shut down jvm
        </code></pre>

        <p>5.Static variables will be stored in method area</p>
        <p>6. We can access static variables either by object reference or by class name but recommended to use class name. Within the same class 
it is not required to use class name and we can access directly</p>
         
        <pre><code>
            class Test {
            static int x = 10;
            p s v m(String[] args) {
              Test t = new Test();
              SOP(t.x);         (valid)
              SOP(Test.x);      (valid and recommended)
              SOP(x);           (valid )
            }
            public void m1() {
              SOP(x);           (valid)
            }
          }
        </code></pre>

        <p>7. We can access static variables directly from both instance and static areas</p>
        
        <p>8. For static variables jvm will provide default values and we are not required to perform initialization explicitly</p>
        <pre><code>
          class Test {
            static int x;
            static double d;
            static boolean b;
            static String s;
            p s v m(String[] args) {
              SOP(t1.x);    0
              SOP(t1.d);    0.0
              SOP(t1.b);    false
              SOP(t1.s);    null
            }
          }
        </code></pre>

        <p>9. Static variable also known as class level variables or fields</p>
        <pre><code>
          class Test {
            static int x = 10;
            int y = 20;
            p s v m (String[] args) {
              Test t1 = new Test();
              t1.x = 888;
              t1.y = 999;
              Test t2 = new Test();
              SOP(t2.x + " " + t2.y);
            }
          }
        </code></pre>

        <output>Output: 888 20</output><br>

        <img src="images/ss2.png" alt="ss1" width="500" height="300">
       
        <h5>Local Variables</h5>
        <p>1. Sometimes to meet temporary requirements of the programmar we can declare variables inside a method or block or constructor such type of variables are called local variables or temporary variables or automatic variables</p>
        <p>2. Local variables will be stored inside stack memory</p>
        <p>3. Local variables will be created while executing the block in which we declared it. Once block execution completes automatically local variable will be destroyed. Hence the scope of local variable is the block in which we declared it.</p>
        
        <pre><code>
          class Test {
            p s v m(String[] args) {
              int i = 0;
              for(int j = 0; j &lt= 3; j++) {
                i = i + j;
              }
              SOP(i + "......" + j);
            }
          }
        </code></pre>

        <pre><output>
          CE: cannot find symbol
          symbol: variable j
          location: class Test
        </output></pre>

        <pre><code>
          class Test {
            p s v m(String[] args){
              try {
                int j = Integer.parseInt("ten");
              }
              catch(NumberFormatException e) {
                j = 10;
              }
              SOP(j);
            }
          }
        </code></pre>
          <pre><output>
            CE: cannot find symbol
            symbol: variable j
            location: class Test
          </output></pre>
        
        <p>4. For local variables jvm wont provide default values compulsory we should perform initialization explicitly before using that variable i.e if we are not using then it is not required to perform initialization</p>
        <pre><code>
        class Test {
          p s v m(String[] args) {
            int x;
            SOP("Hello");
          }
        }
        </code></pre>
        
        <pre><output>
        Hello
        </output></pre>

        <pre><code>
        class Test {
          p s v m(String[] args) {
            int x;
            SOP(x);
          }
        }
        </code></pre>

        <pre><output>
        CE: variable x might not have been initialized
        </output></pre>

        <pre><code>
          class Test {
            p s v m(String[] args) {
              int x;
              if(args.length > 0) {
                x = 10;
              }
              SOP(x);
            }
          }
        </code></pre>
        <pre><output>
          CE: variable x might not have been initialized.  
        </output></pre>

        <pre><code>
          class Test {
            p s v m(String[] args) {
              int x;
              if(args.length > 0) {
                x = 10;
              } else {
                x = 20;
              }
              SOP(x);
            }
          }
          </code></pre>

          <pre><output>
          java test 10<kbd>enter</kbd>
          10
          java test<kbd>enter</kbd>
          20
          </output></pre>

        <p>Note 1 : It is not recommended to perform initialization for local variables inside logical blocks becaue there is no guarantee for the execution of these blocks always at run time</p>
        <p>Note 2 : It is highly recommended to perform initialization at the time of declaration atleast with default values</p>
        <p>5. The only applicable modifier for local variables is final. By mistake if we are trying to apply any other modifier then we will get compile time error</p>

        <pre><code>
          class Test {
            p s v m(String[] args) {
              public int x = 10;
              private int x = 10;
              protected int x = 10;
              static int x = 10;
              transient x = 10;
              volatile x = 10;
              final int x = 10;
            }
          }
          </code></pre>
          <pre><output>
            CE: Illegal start of expression
          </output></pre>
          <img src="images/ss4.png" alt="ss1" width="500" height="300">

        <p>6. If we are not declaring with any modifier then by default it is default but this rule is applicable only for instance and static variables but not for local variables</p>

        <h4>Conclusions : </h4>
        <p>1. For instance and static variables jvm will provide default values and we are not required to perform initialization explicitly but for local variables jvm wont provide default values compulsory we should perform initialization explicitly befor using that variable</p>
        <p>2. Instance and static variables can be accessed by multiple threads simultaneously and hence these are not thread safe but in the case of local variable for every thread a separate copy will be created and hence local variables are thread safe</p>
        
        <table class="table table-striped" >
          <thead class="thead-dark">
            <tr>
              <th>Types of variables</th>
              <th>Is thread safe?</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Instance Variables</td>
              <td>No</td>
            </tr>
            <tr>
              <td>Static variables</td>
              <td>No</td>
            </tr>
            <tr>
              <td>Local variables</td>
              <td>Yes</td>
            </tr>
          </tbody>
        </table>
 
        <p>Every variable in java should be either instance or static or local</p>
        <p>Every variable in java should be either primitive or reference hence various possible combinations of variables in java are</p>
        
        <img src="images/ss5.png" alt="ss1" width="500" height="300">
        <pre><code>
        class Test {
          int x = 10;                   (instance primitve variable)
          static String s = "durga";    (static reference variable)
          p s v m(String[] args) {
            int[] y = new int[3];       (local reference variable)
          }
        }
        </code></pre>

        <h6>Uninitialized arrays</h6>
        <pre><code>
          class Test {
            int[] x;
            p s v m(String[] args) {
              Test t = new Test();
              SOP(t.x);
              SOP(t.x[0]);
            }
          }
          </code></pre>

          <pre><output>
            null
            RE: NullPointerException
          </output></pre>

          <p>At instance level</p>
          <pre><code>
            int[] x;
            SOP(obj.x);
            SOP(obj.x[0]);
          </code></pre>
          <pre><output>
            null
            RE: NullPointerException
          </output></pre>

          <pre><code>
            int[] x = new int[3];
            SOP(obj.x);
            SOP(obj.x[0]);
          </code></pre>
          <pre><output>
            [I@7yt5g6
            0
          </output></pre>
          
        <p>At static level</p>
        <pre><code>
          static int[] x;
          SOP(x);
          SOP(x[0]);
        </code></pre>
        <pre><output>
          null
          RE: NullPointerException
        </output></pre>

        <pre><code>
          static int[] x = new int[3];
          SOP(x);
          SOP(x[0]);
        </code></pre>
        <pre><output>
          [I@7yt5g6
          0
        </output></pre>

        <p>At local level</p>
        <pre><code>
          int[] x;
          SOP(x);
          SOP(x[0]);
        </code></pre>
        <pre><output>
          CE: variable x might not have been initialized
        </output></pre>

        <pre><code>
          int[] x = new int[3];
          SOP(x);
          SOP(x[0]);
        </code></pre>
        <pre><output>
          [I@7yt5g6
          0
        </output></pre>

        <mark>Once we creates an array every array element by default initialized with default values irrespective of whether it is instance or static or local array</mark>
<h3>7. Var-arg methods(came in 1.5v)</h3>
<p>Until 1.4v we cant declare a method with variable number of arguments if there is a change in number of arguments compulsory we should go for new method
  it increases length of the code and reduces readibility hence to overcome this problem some people introduced var args methods in 1.5v
  According to this we can declare a method which can take variable number of arguments such type of methods are called var args methods
</p>

<p>We can declare a var args method as follows</p>
<pre><code>
  m1(int... x);
</code></pre>
<p>We can call this method by passing any number of int values including 0 numbers</p>

<pre><code>
  m1();
  m1(10);
  m1(10, 20);
  m1(10, 20, 30);
</code></pre>

<p>All calls to m1() method are valid</p>

<pre><code>
  class Test {
    public static void m1(int... x) {
      SOP("var-arg method");
    }
    p s v m(String[] args) {
      m1();
      m1(10);
      m1(10, 20);
      m1(10, 20, 30);
    }
  }
  </code></pre>

  <pre><output>
    var-arg method
    var-arg method
    var-arg method
    var-arg method
  </output></pre>

<p>Internally var-arg parameter will be converted into one dimensional array hence within the var-arg method we can 
  differentiate values by using index.
</p>

<pre><code>
  class Test {
    public static void m1(int... x) {
      SOP("The number of arguments : " + x.length);
    }
    p s v m(String[] args) {
      m1();
      m1(10);
      m1(10, 20);
      m1(10, 20, 30);
    }
  }
  </code></pre>

  <pre><output>
    The number of arguments : 0
    The number of arguments : 1
    The number of arguments : 2
    The number of arguments : 3
  </output></pre>

  <pre><code>
    class Test {
      public static void sum(int... x) {
        int total = 0;
        for(int x1 : x) {
          total = total + x1;
        }
        SOP("The sum " + total);
      }
      p s v m(String[] args) {
        sum();
        sum(10, 20);
        sum(10, 20, 30);
        sum(10, 20, 30, 40);
      }
    }
    </code></pre>

    <pre><output>
      The sum 0
      The sum 30
      The sum 60
      The sum 100
    </output></pre>

  <h6>case 1:</h6>
  <p>Which of the following are valid var-arg method declarations</p>
  <pre><code>
    m1(int... x); 
    m1(int ...x); 
    m1(int...x);  
    m1(int x...); 
    m1(int. ..x); 
    m1(int .x..); 
  </code></pre>
  <pre><output>
    valid 
    valid 
    valid 
    invalid 
    invalid
    invalid
  </output></pre>

<h6>case 2:</h6>

<pre><code>
  m1(int x, int... y);      
  m1(String s, double... y);
</code></pre>

<pre><output>
  valid 
  valid
</output></pre>
<p>We can mix var-arg parameter with normal parameter</p>
<h6>case 3:</h6>

  <pre><code>
    m1(double... d, String s); 
    m1(char ch, String... s);  
  </code></pre>

  <pre><output>
    invalid 
    valid
  </output></pre>

  <p>If I mix normal parameter with var-arg parameter then var-arg parameter should
    be last parameter</p>

<h6>case 4:</h6>
<p>Inside var-arg method we can take only one var-arg parameter and we cant take more than one var-arg parameter</p>
<pre><code>
  m1(int... x, double... d); //invalid
</code></pre>

<pre><code>
  class Test {
    public static void main(String[] args) {
      m1(10, 20);
    }
  
    private static void m1(int... x, int...y) {
      System.out.println(x[0]);
    }
    
  }
  </code></pre>

  <pre><output>
    error : varargs parameter must be the last parameter
  </output></pre>

<h6>case 5:</h6>

<pre><code>
  class Test {
    p s v m1(int... x) {
      SOP("int...");
    }
    p s v m1(int[] x) {
       SOP("int[]"); 
    }
  }
  </code></pre>

  <pre><output>CE: cannot declare both m1(int[]) and m(int...) in Test</output></pre>

  <p>Inside a class we cant declare var-arg method and corresponding array method simultaneously o/w we will get compile time error</p>
  
  <h6>case 6 :</h6>
  <pre><code>
    class Test {
      p s v m1(int... x) {
        SOP("var-arg method");
      }
      p s v m1(int x) {
         SOP("General method"); 
      }
      p s v main(String[] args) {
        m1();
        m1(10, 20);
        m1(10);
      }
    }
    </code></pre>

    <pre><output>
      var-arg method
      var-arg method
      General method
    </output></pre>

<p>In general var-arg method will get least priority i.e if no other method matched then only var-arg method will 
  get the chance. It is exactly same as default case inside switch
</p>

<h6>Equivalence between var-arg parameter and 1D array</h6>
<h6>case 1:</h6>
<p>Wherever 1D array present we can replace with var-arg parameter</p>
<p>m1(int[] x)  ->  m1(int... x)</p>

<p>Main of string array args can be replaced with main(String... x)   (From 1.5v onwards)</p>
<p>main(String[] args)  ->  main(String... x)</p>

<h6>case 2:</h6>
<p>Wherever var-arg parameter present we cant replace with 1D array</p>
<p>m1(int... x)   ->   m1(int[] x)    (invalid replacement)</p>

<mark>Note: 
  m1(int... x) we can call this method by passing a group of int values and x will become 1D array
</mark>

<mark>m1(int[]... x) we can call this method by passing a group of 1D int arrays and x will become 2D int array</mark>

<pre><code>
  class Test {
    p s v m(String[] args) {
      int[] a = {10, 20, 30};
      int[] b = {40, 50, 60};
      m1(a, b);
    }
    p s v m1(int[]... x) {
      for(int[] x1 : x) {
        SOP(x1[0]);
      }
    }
  }
  </code></pre>
  <pre><output>
    10 
    40
  </output></pre>

  <img src="images/ss11.png" alt="ss11" width="300" height="300">
<h3>8. main method</h3>
<p>1. Whether class contains main method or not and whether main method is declared according to requirement or not. These things wont be checked by compiler.
  At run time jvm is responsible to check these things. If jvm unable to find main method then we will get Run Time Exception saying no such method error : main
</p>

<pre><code>
  class Test {
  
    
  }
  </code></pre>

  <pre><output>
    Exception in thread "main" java.lang.NoSuchMethodError: main
  </output></pre>

<p>2. At runtime jvm always searches for the main method with the following prototype</p>
<pre><code>
 public static void main(String[] args)
</code></pre>

<div class="container">
  <p class="bg-warning text-white">Why main method is public</p>
  <p>To call by jvm from anywhere it is a public. Because jvm could be installed in any location and workspace could be in another location</p>
</div>

<div class="container">
  <p class="bg-warning text-white">Why main method is static</p>
  <p>Without exist object also jvm has to call this method.</p>
</div>

<div class="container">
  <p class="bg-warning text-white">Why return type is void</p>
  <p>Main method wont return anything to jvm</p>
</div>

<div class="container">
  <p class="bg-warning text-white">Why the name is main</p>
  <p>This is name which is configured inside the jvm thats why jvm searches for main only. We can configure to change to another name also</p>
</div>

<div class="container">
  <p class="bg-warning text-white">What about string array</p>
  <p>To pass command line arguments</p>
</div>
<h6>On removing static</h6>
<pre><code>
class Test {
  public void main(String[] args) {
      
  }
}
</code></pre>

<pre><output>
Exception in thread "main" java.lang.NoSuchMethodError: main
</output></pre>

<h6>On changing void to int</h6>
<pre><code>
class Test {
  public static int main(String[] args) {
        
  }
}
</code></pre>

<pre><output>
Exception in thread "main" java.lang.NoSuchMethodError: main
</output></pre>

<h6>On changin main to Main</h6>
<pre><code>
class Test {
  public static void Main(String[] args) {
          
  }
}
</code></pre>

<pre><output>
Exception in thread "main" java.lang.NoSuchMethodError: main
</output></pre>

<h6>On changing String[] args to String args</h6>
<pre><code>
class Test {
  public static void main(String args) {
            
  }
}
</code></pre>

<pre><output>
 Exception in thread "main" java.lang.NoSuchMethodError: main
</output></pre>

<p>3. The above syntax is very strict and if we perform any change then we will get run time exception saying no such method error: main</p>

<p>4. Even though above syntax is very strict the following changes are acceptable</p>

<p>Instead of public static we can take static public i.e the order of modifiers is not important</p>
<pre><code>
  class Test {
    static public void main(String[] args) {
              
    }
  }
  </code></pre>
<p>We can declare string array in any acceptable form</p>
<pre><code>
  class Test {
    public static void main(String[] args) {
              
    }
  }
</code></pre>
<pre><code>
    class Test {
      public static void main(String []args) {
                
      }
    }
</code></pre>
<pre><code>
      class Test {
        public static void main(String args[]) {
                  
        }
      }
</code></pre>

<p>Instead of args we can take any valid java identifier</p>
<pre><code>
  class Test {
    public static void main(String[] nc) {
              
    }
  }
</code></pre>

<p>We can replace string array with var-arg parameter</p>
<pre><code>
  class Test {
    public static void main(String... args) {
              
    }
  }
</code></pre>

<p>We can declare main method with the following modifiers final, synchonized and strictfp</p>

<pre><code>
  public class Test {
    static final synchronized strictfp public void main(String... durga) {
          System.out.println("Valid main method");
    }
  }
</code></pre>

<div class="container">
  <p class="bg-warning text-white">Which of the following main method is valid?</p>
  <p>public static void main(String args)
  <p>public static void Main(String[] args)
  <p>public void main(String[] args)
  <p>public static int main(String[] args)
  <p>final synchronized strictfp public void main(String[] args)
  <p>final synchronized strictfp public static void main(String[] args)
  <p>public static void main(String... args)
  <pre><output>
    invalid
    invalid
    invalid
    invalid
    invalid
    valid
    valid
  </output></pre>
</div>

<div class="container">
  <p class="bg-warning text-white">Which of the above cases we will get compile time error</p>
  <p>We wont get compile time error anywhere but except last two cases in remaining we will get RE saying NoSuchMethodError: main</p>
</div>

<h6>Case 1:</h6>
<pre><code>
  class Test {
    public static void main(String[] args) {
      SOP("String[]");
    }
    public static void main(int[] args)  {
      SOP("int[]");
    }
  }
</code></pre>
<pre><output>
  String[]
</output></pre>
<p>Overloading of the main method is possible but JVM will always call String[] arg only. The other overloaded method we have to call explicitly like other normal method</p>

<h6>Case 2:</h6>
<pre><code>
  class P {
    public static void main(String[] args) {
      SOP("Parent main");
    }
  }
  class C extends P {

  }
</code></pre>
<p>Inheritance concept applicable for main method hence while executing child class if child doesn't contain main method then parent class main method will be executed.</p>

<img src="images/ss6.png" alt="ss6" width="300" height="300">

<h6>case 3:</h6>
<p></p>
<pre><code>
  class P {
    public static void main(String[] args) {
      SOP("Parent main");
    }
  }
  class C extends P {
    public static void main(String[] args) {
      SOP("child main");
    }
  }
</code></pre>
<img src="images/ss7.png" alt="ss7" width="300" height="300">
<p>It seems overriding concept applicable for main method but it is not overriding and it is method hiding</p>
<mark>Note: For main method inheritance and overloading concepts are applicable but overriding concept is not applicable. But instead of overriding, method hiding is applicable</mark>

<h6>1.7 version enhancements with respect to main method</h6>
<p>Until 1.6v if the class doesn't contain main method then we will get run time exception NoSuchMethodError: main but from 1.7v onwards instead of NoSuchMethodError we will get more elaborated information</p>
<p></p>

<pre><code>
  class Test {

  }
</code></pre>
<table class="table table-striped">
  <thead class="thead-dark">
    <tr>
    <th>1.6V</th>
    <th>1.7V</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><pre>
        Javac Test.java
        Java Test
        RE: NoSuchMethodError: main</pre>
      </td>
      <td><pre>
        Javac Test.java
        Java Test
        Error: Main method not found in class com.cts.java.Test, please define the main method as:
        public static void main(String[] args)</pre>
      </td>
    </tr>
  </tbody>
</table>

<p>From 1.7v onwards main method is mandatory to start program execution hence even though class contains static block it won't be executed if the class doesn't contain main method</p>


<pre><code>
  class Test {
    static {
      SOP("Static Block")
    }
  }
</code></pre>
<table class="table table-striped">
  <thead class="thead-dark">
    <tr>
    <th>1.6V</th>
    <th>1.7V</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><pre>
        Javac Test.java
        Java Test
        Static Block
        RE: NoSuchMethodError: main</pre>
      </td>
      <td><pre>
        Javac Test.java
        Java Test
        Error: Main method not found in class com.cts.java.Test, please define the main method as:
        public static void main(String[] args)</pre>
      </td>
    </tr>
  </tbody>
</table>

<p>From 1.7v onwards main method is mandatory to start program execution</p>
<pre><code>
  class Test {
    static {
      SOP("Static Block")
      System.exit(0);
    }
  }
</code></pre>

<table class="table table-striped">
  <thead class="thead-dark">
    <tr>
    <th>1.6V</th>
    <th>1.7V</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><pre>
        Javac Test.java
        Java Test
        Static Block
      </td>
      <td><pre>
        Javac Test.java
        Java Test
        Error: Main method not found in class com.cts.java.Test, please define the main method as:
        public static void main(String[] args)</pre>
      </td>
    </tr>
  </tbody>
</table>

<pre><code>
  class Test {
    static {
      SOP("Static Block");
    }
    public static void main(String[] args) {
      SOP("Main method");
    }
  }
</code></pre>

<table class="table table-striped">
  <thead class="thead-dark">
    <tr>
    <th>1.6V</th>
    <th>1.7V</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><pre>
        Javac Test.java
        Java Test
        Static Block
        Main Method</pre>
      </td>
      <td><pre>
        Javac Test.java
        Java Test
        Static Block
        Main method</pre>
      </td>
    </tr>
  </tbody>
</table>

<table class="table table-striped">
  <thead class="thead-dark">
    <tr>
    <th>1.6V Execution flow</th>
    <th>1.7V Execution flow</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <img src="images/ss81.6.png" width="400" height="500">
      </td>
      <td>
        <img src="images/ss81.7.png" width="400" height="500">
      </td>
    </tr>
  </tbody>
</table>

<div class="container">
  <p class="bg-warning">Without writing main method is it possible to print some statements to the console?</p>
  <p>Yes by using static block but this rule is applicable until 1.6v but from 1.7v onwards it is impossible to
     print some statement to the console without writing main method</p>
</div>


<h3>9. command line arguments</h3>
<p>The arguments which are passing from command prompt are called command line arguments. With these command line 
  arguments jvm will create an array and by passing that array as argument jvm will call main method
</p>
<p>Example</p>
<p>Java test A B C<kbd>enter</kbd></p>
<p><pre>
  A - args[0]
  B - args[1]
  C - args[2]
  length - args.length - 3
</pre></p>

<h6>Main objective of command line argument</h6>
<p>We can customize behaviour of the main method</p>

<h6>Why command line arguments are always string</h6>
<p>String is the most common used object thats why SUN people gave priority to the string type and we can easily convert it into other types also</p>

<h6>Case 1:</h6>
<pre><code>
  class Test {
    public static void main(String[] args) {
      String[] argh = {"x", "y", "z"};
      args = argh;
      for(String s : args) {
        SOP(s);
      }
    }
  }
</code></pre>

<pre><output>
  java Test A B C
  x
  y
  z
  java Test A B
  x
  y
  z
  java Test 
  x
  y
  z
</output></pre>

<h6>case 2:</h6>
<pre><code>
  class P {
    public static void main(String[] args) {
      SOP(args[0] + args[1]);
    }
  }
</code></pre>
<pre><output>
java test 10 20
1020
</output></pre>
<p>Within main method commad line arguments are available in string form</p>
<h6>case 3:</h6>

<pre><code>
  class P {
    public static void main(String[] args) {
      SOP(args[0]);
    }
  }
</code></pre>

<pre><output>
  javac Test "Note Book"
  Note Book
</output></pre>
<p>Usually space itself is the separator between command line arguments. If our command line argument itself contain space then we have to enclose that command line argument within double quotes</p>
<h3>10. java coding standards</h3>
<p>Whenever we are writing java code it is highly recommended to follow coding standards. Whenever we are writing any component its name should reflect the purpose of that component(functionality)</p>
<p>The main advantage of this approach is readibility and the maintainability of the code will be improved</p>
<p>If you are asked to write sum program</p>
<pre><code>
  class A {
    public int m1(int x, int y) {
      return x + y;
    }
  }
</code></pre>

<pre><code>
  package com.cts.java
  public class Calculator {
    public static int add(int number1, int number2) {
      return number1 + number2;
    }
  }
</code></pre>
        
<h6>Mistakes explained</h6>
<p>Every class should be part of some package use proper naming convention for package name(client internet domain name in reverse)</p>
<p>Code should be reachable to maximum people. Highly recommended our class should be public</p>
<p>The name of the class should represent its purpose</p>
<p>We are not using any instance variable here then what is the need of declaring this method as instance method. Instance method can be called by creating an object and then call
  method using that object so declare this method as static method.</p>


<p>The name of the method should represent its purpose</p>
<p>The name of the variables should represent its purpose</p>

<h6>Coding standard for classes</h6>
<p>Usually class names are nouns. Should starts with uppercase character and if it contains multiple words then every innerword should start with uppercase character</p>
<p>Example: String StringBuffer  Account Dog</p>

<h6>Coding standards for interfaces</h6>
<p>Usually interface names are adjectives should starts with uppercase characters and if it contains multiple words every inner word should start with uppercase character</p>
<p>Example: Runnable  Serializable  Comparable</p>

<h6>Coding standard for method()</h6>
<p>Usually method names are either verbs or verb noun combination. Should starts with lowercase alphabet symbol and if it contains multiple words then every inner word should start with uppercase character (camel case convention)</p>
<p>Verb example for method: sleep() run() eat()</p>
<p>Verb noun combination example : getName()  setSalary()</p>

<h6>Coding standards for variables</h6>
<p>Usually varable names are nouns should starts with lowercase alphabet symbols and if it contains multiple words then every inner word should starts with uppercase characters(Camel case convention)</p>
<p>Example: name  age   salary    mobileNumber</p>

<h6>Coding standard for constants</h6>
<p>Usually constant names are nouns should contain only uppercase characters and if it contain multiple words then these words are separated with underscore symbol</p>
<p>Example: MAX_VALUE   MAX_PRIORITY    NORM_PRIORITY   MIN_PRIORITY  PI</p>
<p>Usually we can declare constants with public static and final modifiers</p>

<h6>Java bean coding standards</h6>
<p>A java bean is a simple java class with private properties and public getter and setter methods</p>
<pre><code>
  public class StudentBean {
    private String name;
    public void setName(String name) {
      this.name = name;    
    }
    public String getName() {
      return name;
    }
  }
</code></pre>

<p>Class name ends with bean is not official convention from sun microsystem</p>

<h6>Syntax for setter method</h6>
<p>1. It should be public method</p>
<p>2. The return type should be void</p>
<p>3. Method name should be prefixed with set</p>
<p>4. It should take some argument. It should not be no-argument method</p>

<h6>Syntax for getter method</h6>
<p>1. It should be public method </p>
<p>2. The return type should not be void</p>
<p>3. Method name should prefixed with get</p>
<p>4. It should not take any argument</p>

<h6>About boolean properties</h6>
<mark>Note: For boolean properties getter method name can be prefixed with either get or is but recommended to use is.</mark>
<pre><code>
  public class Test {

    private boolean empty;
  
    public boolean isEmpty() {
      return empty;
    }
  
    public void setEmpty(boolean empty) {
      this.empty = empty;
    }
  
  }
</code></pre>

<pre><code>
  public class Test {

    private boolean empty;
  
    public boolean getEmpty() {
      return empty;
    }
  
    public void setEmpty(boolean empty) {
      this.empty = empty;
    }
  
  }
</code></pre>

<h6>Coding standard for listeners</h6>
<h6>Case 1: To register a listener</h6>
<p>Method name should be prefixed with add.</p>
<pre><code>
  public void addMyActionListener(MyActionListener l); <span style="color:green">valid</span>
  public void registerMyActionListener(MyActionListener l); <span style="color:red">Invalid</span>
  public void addMyActionListener(ActionListener l); <span style="color:red">Invalid</span>
</code></pre>

<h6>Case 2: To unregister a listener</h6>
<p>Method name should be prefixed with remove</p>
<pre><code>
  public void removeMyActionListener(MyActionListener l); <span style="color:green">valid</span>
  public void unRegisterMyActionListener(MyActionListener l); <span style="color:red">Invalid</span>
  public void removeMyActionListener(ActionListener l); <span style="color:red">Invalid</span>
  public void deleteMyActionListener(MyActionListener l); <span style="color:red">Invalid</span>
</code></pre>

<h1>1. Operators And Assignments</h1>
    <h3>1. Increment And Decrement Operators</h3>
    <h5>Increment operator</h5>
    <table class="table table-striped">
        <thead class="thead-dark">
            <tr>
                <th>Expression</th>
                <th>Initial value of x</th>
                <th>Value of y</th>
                <th>Final value of x</th>
            </tr>
        </thead>
            <tr>
                <td>y = ++x;</td>
                <td>10</td>
                <td>11</td>
                <td>11</td>
            </tr>
            <tr>
                <td>y = x++;</td>
                <td>10</td>
                <td>10</td>
                <td>11</td>
            </tr>
            <tr>
                <td>y = --x;</td>
                <td>10</td>
                <td>9</td>
                <td>9</td>
            </tr>
            <tr>
                <td>y = x--;</td>
                <td>10</td>
                <td>10</td>
                <td>9</td>
            </tr>
        <tbody>
        </tbody>
    </table>

    <h6>Loophole 1:</h6>

    <pre><code>
        int x = 10;
        int y = ++10;
        SOP(y);
    </code></pre>
    <pre><output>
        CE: unexpected type 
        found : value
        required: variable
    </output></pre>
    <p>We can apply Increment and Decrement operators only for variables but not for constant values. If we are trying to apply for constant values then we will get compile time error</p>
    
    <h6>Loophole 2:</h6>
    <pre><code>
        int x = 10;
        int y = ++(++x);
        SOP(y);
    </code></pre>
    <pre><output>
        CE: unexpected type 
        found : value
        required: variable
    </output></pre>
    <p>Nesting of Increment and Decrement operators not allowed</p>

    <h6>Loophole 3:</h6>
    <pre><code>
        final int x = 10;
        x = 11;
        SOP(x);
    </code></pre>
    <pre><output>
        CE: cannot assign a value to final variable x
    </output></pre>
    <p>For final variables reassignments not possible</p>

    <h6>Loophole 4:</h6>
    <pre><code>
        final int x = 10;
        x++;
        SOP(x);
    </code></pre>
    <pre><output>
        CE: cannot assign a value to find variable x
    </output></pre>
    <p>For final variables we cant apply Increment and Decrement operators</p>
    <mark>We can apply increment and decrement operators for every primitive type except boolean</mark>

    <pre><code>
        int x = 10;
        x++;
        SOP(x);
    </code></pre>
    <pre><output>
        11
    </output></pre>

    <pre><code>
        char ch = 'a';
        ch++;
        SOP(ch);
    </code></pre>
    <pre><output>
        b
    </output></pre>

    <pre><code>
        double d = 10.5;
        d++;
        SOP(d);
    </code></pre>
    <pre><output>
        11.5
    </output></pre>

    <pre><code>
        boolean b = true;
        b++;
        SOP(b);
    </code></pre>
    <pre><output>
        CE: operator ++ can't be applied to boolean.
    </output></pre>

    <h6>Difference between b++ and b = b + 1;</h6>
    
    <pre><code>
        byte b = 10;
        b = b + 1;
        SOP(b);
    </code></pre>
    <pre><output>
        CE: incompatible types: possible lossy conversion from int to byte
    </output></pre>
    <p class="bg-primary text-white">If we apply any Arithmetic operator between two variables a and b the result type is always max(int, type of a, type of b)
        but in the case of increment and decrement operators internal typecasting will be performed automatically b = (type of b)(b + 1);
    </p>
    <pre><code>
        byte b = 10;
        b = (byte)(b + 1);
        SOP(b);
    </code></pre>
    <pre><output>
        11
    </output></pre>

    <pre><code>
        byte b = 10;
        b = b++;            (means b = (byte)(b + 1))
        SOP(b);
    </code></pre>
    <pre><output>
        11
    </output></pre>

    <pre><code>
        byte a = 10;
        byte b = 20;
        byte c = a + b;
        SOP(c);
    </code></pre>
    <pre><output>
        CE: incompatible types: possible lossy conversion from int to byte
    </output></pre>

    <pre><code>
        byte a = 10;
        byte b = 20;
        byte c = (byte)(a + b);
        SOP(c);
    </code></pre>
    <pre><output>
        11
    </output></pre>
    
    <h3>2. Arithmetic Operators(+ - * / %)</h3>
    <p class="bg-primary text-white">If we apply any Arithmetic operator between two variables a and b the result type is always max(int, type of a, type of b)</p>
    
<pre><code>
    byte + byte = int
    byte + short = int
    short + short = int
    byte + long = long
    long + double = double
    float + long = float
    char + char = int
    char + double = double
</code></pre>

<h6>Example 1: </h6>

<pre><code>
    SOP('a' + 'b');      
    SOP('a' + 0.89);     
</code></pre>

<pre><output>
    97 + 98 = 195
    97 + 0.89 = 97.89
</output></pre>

<mark>In integral Arithmetic(byte short int long) there is no way to represent infinity hence if infinity is a result we will get Arithmetic exception in integral Arithmetic</mark>
<pre><code>
    SOP(10 / 0);
</code></pre>


<pre><output>
    Exception in thread "main" java.lang.ArithmeticException: / by zero
</output></pre>

<mark>But in floating point Arithmetic(float and double) there is a way to represent infinity. For this float and double classes contains the following two constants i.e
    POSITIVE_INFINITY and NEGATIVE_INFINITY. Hence even though the result is infinity we wont get any Arithmetic exception in floating point Arithmetic
</mark>
<pre><code>
    SOP(10 / 0.0);
</code></pre>

<pre><output>
   Infinity
</output></pre>

<pre><code>
    SOP(-10 / 0.0);
</code></pre>

<pre><output>
   -Infinity
</output></pre>

<mark>In integral Arithmetic(byte short int long) there is no way to represent undefined results hence if the result is undefined 
    we will get RE saying Arithmetic Exception
</mark>
<pre><code>
    SOP(0 / 0);
</code></pre>

<pre><output>
    Exception in thread "main" java.lang.ArithmeticException: / by zero
</output></pre>

<mark>But in floating point Arithmetic(float and double) there is a way to represent undefined results. For this float and double classes contains NaN constants. 
    Hence we wont get any Arithmetic exception in floating point Arithmetic
</mark>
<pre><code>
    SOP(0.0 / 0);
</code></pre>

<pre><output>
    NaN
</output></pre>

<pre><code>
    SOP(-0.0 / 0);
</code></pre>

<pre><output>
    NaN
</output></pre>

<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>Expression</th>
            <th>Result</th>
        </tr>
    </thead>
        <tr>
            <td>SOP(10 / 0)</td>
            <td>RE: Exception in thread "main" java.lang.ArithmeticException: / by zero</td>
        </tr>
        <tr>
            <td>SOP(10 / 0.0)</td>
            <td>Infinity</td>
        </tr>
        <tr>
            <td>SOP(0 / 0)</td>
            <td>RE: Exception in thread "main" java.lang.ArithmeticException: / by zero</td>
        </tr>
        <tr>
            <td>SOP(0.0 / 0)</td>
            <td>NaN</td>
        </tr>
    <tbody>
    </tbody>
</table>

<mark>For any x value including NaN the following Expressions returns false</mark>
<pre>
    x < NaN
    x <= NaN
    x > NaN
    x >= NaN
    x == NaN
</pre>
<mark>For any x value including NaN the following Expressions returns true</mark>
<pre>x != NaN</pre>

<pre>
        System.out.println(10 < Float.NaN);
	System.out.println(10 <= Float.NaN);
	System.out.println(10 > Float.NaN);
	System.out.println(10 >= Float.NaN);
	System.out.println(10 == Float.NaN);
	System.out.println(Float.NaN == Float.NaN);
	System.out.println(10 != Float.NaN);
	System.out.println(Float.NaN != Float.NaN);
</pre>


<pre><output>
false
false
false
false
false
false
true
true
</output></pre>

<h5>Arithmetic Exception</h5>
<p>1. Run Time Exception but not compile time error</p>
<p>2. It is possible only in integral arithmetic but not in floating point arithmetic</p>
<p>3. The only operator which cause AE are / and %</p>

    <h3>3. String concatenation operator(+)</h3>
    <p><span style="color:red">The only overloaded operator in java is + operator.</span> Sometimes it acts as arithmetic addition operator and Sometimes it acts as string concatenation
        operator</p>
<p>If atleast one argument is string type then + operator acts as concatenation operator and if both arguments are number type then +
    operator acts as arithmetic addition operator</p>
<p>If more than one operator  then based on the precedence they will be evaluated but if multiple operators with same precedence then evaluation will be from 
    left to right</p>
<pre><code>
    String a = "durga"
    int b = 10, c = 20, d = 30;
    SOP(a + b + c + d);
    SOP(b + c + d + a);
    SOP(b + c + a + d);
    SOP(b + a + c + d);
</code></pre>

<pre><output>
    durga102030
    60durga
    30durga30
    10durga2030
</output></pre>

<p>Which of the following expressions are valid?</p>
<pre><code>
    String a = "durga"
    int b = 10, c = 20, d = 30;
    a = b + c + d;
    a = a + b + c;
    b = a + c + d;
    b = b + c + d;
</code></pre>

<pre><output>
    CE: incompatible types found: int req: java.lang.String
    durga1020
    CE: incompatible types found: java.lang.String req: int
    60
</output></pre>


    

    <h3>4. Relational operators(<,  <=,  >,  >=)</h3>
        <pre><code>
        SOP(10 < 20);
        SOP('a' < 10);
        SOP('a' < 97.6);
        SOP('a' > 'A');
        SOP(true > false);
    </code></pre>
    
    <pre><output>
        true
        false
        true
        true
        The operator > is undefined for the argument type(s) boolean, boolean
    </output></pre>
    <mark>We can apply relational operators for every primitive type except boolean</mark>

    
    <pre><code>
        System.out.println("durga" > "durga");
    </code></pre>

    <pre><output>
        The operator > is undefined for the argument type(s) java.lang.String, java.lang.String
    </output></pre>
    <mark>We cant apply relational operators for object type</mark>
        
<pre><code>
    SOP(10 < 20 < 30);
</code></pre>
<pre><output>
    The operator < is undefined for the argument type(s) boolean, int
</output></pre>
<mark>Nesting of relational operators is not allowed o/w we will get compile time error</mark>

    <h3>5. equality operators(==, !=)</h3>
    
<pre><code>
    SOP(10 == 20);
    SOP('a' == 'b');
    SOP('a' == 97.0);
    SOP(false == false);
</code></pre>
<pre><output>
    false
    false
    true(small type will automatically converted to bigger type)
    true
</output></pre>
<p>We can apply equality operators for every primitive type including boolean also</p>
<mark>We can apply equality operators for object type also. For object references r1, r2 
    <p>r1 == r2</p>
    returns true if and only if both references pointing to the same object(references comparison or address comparison)
</mark><br>

<img src="images/ss9.png" alt="ss9" width="300" height="300">


<pre><code>
    Thread t1 = new Thread();
    Thread t2 = new Thread();
    Thread t3 = t1;
    SOP(t1 == t2);
    SOP(t1 == t3);
</code></pre>

<pre><output>
    false
    true
</output></pre>

<img src="images/ss10.png" alt="ss9" width="300" height="300">

<pre><code>
    Thread t = new Thread();
    Object o = new Object();
    String s = new String();
    SOP(t == o);
    SOP(o == s);
    SOP(s == t);
</code></pre>

<pre><output>
    false
    false
    CE: Incompatible operand types String and Thread
</output></pre>

<h6>Loophole</h6>
<p>If we apply equality operators for object type then compulsory there should be some relation between argument types
    either child to parent or parent to child or same type o/w we will get compile time error saying
    incomparable types java.lang.String, java.lang.Thread 
</p>

<div class="container">
    <p class="bg-warning text-white">What is the difference between == operator & equals() method</p>
    <p>In general we can use == operator for reference comparison(address comparison) and .equals() method for content comparison</p>
    <pre><code>
        String s1 = new String("durga");
        String s2 = new String("durga");
        SOP(s1 == s2);
        SOP(s1.equals(s2));
    </code></pre>
    
    <pre><output>
        false
        true
    </output></pre>
</div>

<mark class="bg-primary text-white">For any object reference r, r == null is always false but null == null is always true</mark>


<pre><code>
    String s = new String("durga");
    SOP(s == null);
</code></pre>
<pre><output>
    false
</output></pre>

<pre><code>
    String s = null;
    SOP(s == null);
</code></pre>
<pre><output>
    true
</output></pre>

<pre><code>
    SOP(null == null);
</code></pre>
<pre><output>
    true
</output></pre>




    <h3>6. instanceof operator</h3>
    <p>We can use instanceof operator to check whether the given object is of particular type or not</p>
    <p>Arraylist object can be of any type we don't know it may be string type customer type or student type. I want 
        check whether it is customer type or student type then we should go for instanceof operator</p>
    
    <pre><code>
        Object o = l.get(0);
        if(o instanceof Student) {
            Student s = (Student)o;
            //perform Student specific functionality
        } else if(o instanceof Customer){
            Customer c = (Customer)c;
            //perform Customer related functionality
        }
    </code></pre>

    <h6>Syntax</h6>
    <p>r instanceof X</p>
    <p>r is object reference and X is Class or Interface name</p>

    <h6>Example 1:</h6>
    <pre><code>
        public class Test {
	
            public static void main(String[] args) {
                
                Thread t = new Thread();
                System.out.println(t instanceof Thread);
                System.out.println(t instanceof Object);
                System.out.println(t instanceof Runnable);
            }
        
        }
    </code></pre>
    <pre><output>
        true
        true
        true
    </output></pre>
    <p>Every implemented class object by default is interface type</p>
    
    <h6>Example 2:</h6>
    <pre><code>
        public class Test {

            public static void main(String[] args) {
        
                Thread t = new Thread();
                System.out.println(t instanceof String);
        
            }
        }
    </code></pre>
    
    <pre><output>
        CE: incompatible types: Thread cannot be converted to String
    </output></pre>

    <p>To use instanceof operator compulsory there should be some relation between argument types(either child to
        parent or parent to child or same type o/w we will get CE saying incompatible types)</p>

    
<h6>Example 3:</h6>

<pre><code>
    public class Test {

        public static void main(String[] args) {
    
            Thread t = new Thread();
            System.out.println(null instanceof String);
            System.out.println(null instanceof Thread);
            System.out.println(null instanceof Runnable);
            System.out.println(null instanceof Object);
        }
    }
</code></pre>
<pre><output>
    false
    false
    false
    false
</output></pre>
<mark>For any class or interface X <span class="bg-primary text-white">null instanceof X</span> is always false</mark>
    <h3>7. bitwise operators(&, |, ^)</h3>
    <p>& -> AND = Returns true iff both arguments are true</p>
    <p>| -> OR = Returns true iff atleast one argument is true</p>
    <p>^ -> XOR = Returns true iff both arguments are different</p>

    <h6>Example</h6>
    <pre><code>
        public class Test {

            public static void main(String[] args) {
        
                System.out.println(true & false);
                System.out.println(true | false);
                System.out.println(true ^ false);
        
            }
        }
    </code></pre>
    
    <pre><output>
        false
        true
        true
    </output></pre>

    <pre><code>
        SOP(4 & 5)
        SOP(4 | 5)
        SOP(4 ^ 5)
    </code></pre>

    <pre><output>
        4
        5
        1
    </output></pre>

    <mark>We can apply these operators for integral types also.</mark>

    <h5>Bitwise compliment operator(~)</h5>
    <p>We can apply this operator only for integral types but not for boolean types if we are trying to apply for boolean type then we will get compile time error</p>
    <pre><code>
        SOP(~true)
    </code></pre>
    
    <pre><output>
        CE error: bad operand type boolean for unary operator '~'
    </output></pre>

    <pre><code>
        SOP(~4)
    </code></pre>
    
    <pre><output>
        -5
    </output></pre>

    <img src="images/ss12.png" alt="ss12" width="300" height="300">

    <p>So 32bit compliment we have to perform, not for just 3 bits or 2 bits</p>
    <mark>Note: The MSB acts as sign bit. 0 means positive number. 1 means negative number. Positive numbers will be presented directly in a memory whereas negative numbers will be represented indirectly
        in the menory in 2's compliment form
    </mark>

    <h5>Boolean compliment operator(!)</h5>
    <pre><code>
        SOP(!4)
    </code></pre>
    
    <pre><output>
        CE: The operator ! is undefined for the argument type(s) int
    </output></pre>

    <pre><code>
        SOP(!false)
    </code></pre>
    
    <pre><output>
        true
    </output></pre>

    <p>We can apply this operator only for boolean types but not for integral types</p>

    <table class="table table-striped">
        <thead class="thead-dark">
            <tr>
                <th>Operators</th>
                <th>Use</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>&, |, ^</td>
                <td>Applicable for both boolean and integral types</td>
            </tr> 
            <tr>
                <td>~</td>
                <td>Applicable for only integral types but not for boolean type</td>
            </tr> 
            <tr>
                <td>!</td>
                <td>Applicable for only boolean but not for integral types</td>
            </tr> 
        </tbody>
    </table>


    <h3>8. short circuit operators(&&, ||)</h3>
    <p>These are exactly same as bitwise operators(&, |) except the following differences</p>
    <table class="table table-striped">
        <thead class="thead-dark">
            <tr>
                <th>&,  |</th>
                <th>&&, ||</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Both arguments should be evaluated always</td>
                <td>Second argument evaluation is optional</td>
            </tr> 
            <tr>
                <td>Relatively performance is low</td>
                <td>Relatively performance is high</td>
            </tr>
            <tr>
                <td>x && y : y will be evaluated iff x is true i.e if x is false then y won't be evaluated</td>
                <td>x || y : y will be evaluated iff x is false i.e if x is true. Then y won't be evaluated</td>
            </tr>
            <tr>
                <td>Applicable for both boolean and integral types</td>
                <td>Applicable for boolean but not for integral types</td>
            </tr>
        </tbody>
    </table>

    <h6>Example 1:</h6>

    <pre><code>
        int x = 10, y = 15;
        if(++x < 10 & ++y > 15) {
            x++;
        } else {
            y++;
        }
        SOP(x + "....." + y);
    </code></pre>
    
    <pre><output>
        11.....17
    </output></pre>

    <pre><code>
        int x = 10, y = 15;
        if(++x < 10 && ++y > 15) {
            x++;
        } else {
            y++;
        }
        SOP(x + "....." + y);
    </code></pre>
    
    <pre><output>
        11.....16
    </output></pre>

    <pre><code>
        int x = 10, y = 15;
        if(++x < 10 | ++y > 15) {
            x++;
        } else {
            y++;
        }
        SOP(x + "....." + y);
    </code></pre>
    
    <pre><output>
        12.....16
    </output></pre>
    
    <pre><code>
        int x = 10, y = 15;
        if(++x < 10 || ++y > 15) {
            x++;
        } else {
            y++;
        }
        SOP(x + "....." + y);
    </code></pre>
    
    <pre><output>
        12.....16
    </output></pre>

    <h6>Example 2:</h6>
    <pre><code>
        int x = 10, y = 15;
        if(++x < 10 && x / 0 > 10) {
            SOP("Hello")
        } else {
            SOP("Hii")
        }
    </code></pre>
    
    <pre><output>
        Hii
    </output></pre>

    <pre><code>
        int x = 10, y = 15;
        if(++x < 10 & x / 0 > 10) {
            SOP("Hello")
        } else {
            SOP("Hii")
        }
    </code></pre>
    
    <pre><output>
        RE: ArithmeticException
    </output></pre>

    

    <h3>9. type cast operators</h3>
    <p>There are two types of typecasting</p>
    <p>1. Implicit typecasting</p>
    <p>2. Explicit typecasting</p>

    <h6>Implicit typecasting</h6>
    <p>1. Compiler is responsible to perform Implicit typecasting</p>
    <p>2. Whenever we are assigning smaller data type value to bigger data type variable Implicit typecasting will be performed</p>
    <p>3. It is also known as widening or upcasting</p>
    <p>4. There is no loss of information in this typecasting</p>
    <p>5. The following are various possible conversions where Implicit typecasting will be performed</p>
    <img src="images/ss13.png" alt="ss12" width="300" height="300">
    <pre><code>
        int x = 'a';
        SOP(x);
    </code></pre>
    
    <pre><output>
        97
    </output></pre>

    <p>Compiler converts char to int automatically by Implicit typecasting</p>

    <pre><code>
        double d = 10;
        SOP(d);
    </code></pre>
    
    <pre><output>
        10.0
    </output></pre>

    <p>Compiler converts int to double automatically by Implicit typecasting</p>

    <h6>Explicit typecasting</h6>
    <p>1. Programmer is responsible to perform Explicit typecasting</p>
    <p>2. Whenever we are assigning bigger data type value to smaller datatype variable then 
        explicit typecasting is required.</p>
    <p>3. It is also called as narrowing or downcasting</p>
    <p>4. There may be a chance of loss of information in this typecasting</p>
    <p>5. The following are various possible conversions where explicit typecasting is required</p>
    
    <img src="images/ss14.png" alt="ss12" width="300" height="300">
    <pre><code>
        int x = 130;
        byte b = x;
    </code></pre>
    
    <pre><output>
        CE: error: incompatible types: possible lossy conversion from int to byte
    </output></pre>

    <pre><code>
        int x = 130;
        byte b = (byte)x;
        SOP(b);
    </code></pre>
    
    <pre><output>
        -126
    </output></pre>

    <p> Whenever we are assigning bigger data type value to smaller datatype variable by explicit typecating then 
        the most significant bits will be lost. We have to consider only LSB</p>

        <img src="images/ss15.png" alt="ss15" width="300" height="300">

    <pre><code>
        public class Test {

            public static void main(String[] args) {
                int x = 150;
                short s = (short)x;
                byte b = (byte)x;
                System.out.println(b);
                System.out.println(s);
                }
        }
    </code></pre>
    
    <pre><output>
        150
        -106
    </output></pre>

    <pre><code>
        public class Test {

            public static void main(String[] args) {
                double d = 130.456;
                int x = (int) d;
                System.out.println(x);
                byte b = (byte) d;
                System.out.println(b);
        
            }
        }
    </code></pre>
    
    <pre><output>
        130
        -126
    </output></pre>

    <mark>If we assign floating point values to the integral type by explicit typecasting the digits after the decimal point will be lost</mark>
    
    <h3>10. assignment operators</h3>
    <p>There are three types of assignment operators</p>
    <h6>1. Simple assignment</h6>
    <pre><code>
        int x = 10;
    </code></pre>

    <h6>2. Chained assignment</h6>
    <pre><code>
        int a, b, c, d;
        a = b = c = d = 20;
        SOP(a + " " + b + " " + c + " " d);
    </code></pre>

    <pre><output>
        20 20 20 20
    </output></pre>

    <pre><code>
        int a = b = c = d = 20;
        SOP(a + " " + b + " " + c + " " d);
    </code></pre>

    <pre><output>
CE  error: cannot find symbol
                int a = b = c = d = 20;
                        ^
  symbol:   variable b
  location: class Test
Test.java:5: error: cannot find symbol
                int a = b = c = d = 20;
                            ^
  symbol:   variable c
  location: class Test
Test.java:5: error: cannot find symbol
                int a = b = c = d = 20;
                                ^
  symbol:   variable d
  location: class Test

    </output></pre>

    <mark>Can't perform chained assignment directly at the time of declaration</mark>

    <pre><code>
        int b, c, d;
        int a = b = c = d = 20;
    </code></pre>
    
    <pre><output>
        valid
    </output></pre>
    
<h6>Compound assignment operator</h6>
<p>Sometimes assignment operator mixed with some other operator such type of assignment operators are called compound assignment operators</p>
<pre><code>
    int a = 10;
    a += 20;
    SOP(a);
</code></pre>
    
<pre><output>
    30
</output></pre>

<p>The following are all possible compound assignment operators in java</p>

<div class="container-fluid">
    <div class="row">
        <div class="col-sm-2" style="background-color:lavender;"><p>+=<br>-=<br>*=<br>/=<br>%=<br></div>                  
        <div class="col-sm-2" style="background-color:lavenderblush;"><p>&=<br>|=<br>^=<br></div>
        <div class="col-sm-2" style="background-color:lavender;"><p>>>=<br>>>>=<br><<=</div>
    </div>
</div>

<pre><code>
    byte b = 10;
    b = b + 1;
    SOP(b)
</code></pre>

<pre><output>
    CE:  error: incompatible types: possible lossy conversion from int to byte
</output></pre>

<pre><code>
    byte b = 10;
    b = b++;
    SOP(b)
</code></pre>

<pre><output>
    11
</output></pre>

<pre><code>
    byte b = 10;
    b += 1;
    SOP(b)
</code></pre>

<pre><output>
    11
</output></pre>

<pre><code>
    byte b = 127;
    b += 3;
    SOP(b)
</code></pre>

<pre><output>
    -126
</output></pre>

<mark>In the case of compound assignment operators internal typecasting will be perfomed automatically</mark>

<pre><code>
    int a, b, c, d;
    a = b = c = d = 20;
    a += b -= c *= d /= 2;
    SOP(a + " " + b + " " + " " + c + " " + d);
</code></pre>

<pre><output>
    -160 -180 200 10
</output></pre>

<p>Assignment operator associativity is right to left</p>



    <h3>11. conditional operator(?:)</h3>
    <p>The only possible ternary operator in java is conditonal operator</p>
    <pre><code>
        int x = (10 < 20) ? 30 : 40;
        SOP(x);
    </code></pre>
        
    <pre><output>
        30
    </output></pre>
    
    <h3>12. new operator</h3>
    <p>We can use new operator to create object</p>
    <h6>Example</h6>
    <p>Test t = new test();</p>
    <mark>Note: After creating an object constructor will be executed to perform initialization of an object. Hence constructor is
        not for creation of object and it is for initialization of an object
    </mark>
    <p>In java we have only new keyword but not delete keyword because destruction of useless objects is the responsibility of garbage collector
    </p>


    <h3>13. [] operator</h3>
    <p>We can use this operator to declare and create arrays</p>
    <h6>Example</h6>
    <p>int[] x = new int[10];</p>

    <h3>14. operator precedence</h3>
    <p>In which order all operands will be evaluated is decided by java operator precedence</p>
    <table class="table table-striped">
        <thead class="thead-dark">
            <tr>
                <th>Operators</th>
                <th>Precedence</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Unary operators</td>
                <td>[],  x++,  x--<br>++x,  --x,  ~,  !<br>new,  &lttype></td>
            </tr> 
            <tr>
                <td>Arithmetic Operators</td>
                <td>*,  /,  %<br>+,  -</td>
            </tr> 
            <tr>
                <td>Shift operators</td>
                <td>>>,  >>>,  <<</td>
            </tr> 
            <tr>
                <td>Comparison operators</td>
                <td><,  <=,  >,  >=,  instanceof</td>
            </tr> 
            <tr>
                <td>equality operators</td>
                <td>==,  !=</td>
            </tr> 
            <tr>
                <td>Bitwise operators</td>
                <td>&<br>^<br>|</td>
            </tr> 
            <tr>
                <td>Short circuit operators</td>
                <td>&&<br>||</td>
            </tr> 
            <tr>
                <td>Conditional operators</td>
                <td>?:</td>
            </tr>
            <tr>
                <td>Assignment operators</td>
                <td>=,  +=,  -=,  *= </td>
            </tr>  
        </tbody>
    </table>
 

    <h3>15. Evaluation order of operands</h3>
    <pre><code>
        public class Test {

            public static void main(String[] args) {
                System.out.println(m1(1) + m1(2) * m1(3) / m1(4) + m1(5) * m1(6));
        
            }
        
            private static int m1(int i) {
                System.out.println(i);
                return i;
            }
        }
    </code></pre>
    
<pre><output>
1
2
3
4
5
6
32
</output></pre>
    
<mark>In java we have only operator precedence but not operand precedence. Before applying any operator all operands will
    be evaluated from left to right.
</mark>

    <h3>16. new vs newInstance()</h3>
    <p>We can use new operator to create an object if we know class name at the beginning</p>
    <pre><code>
        Test t = new Test();
        Student s = new Student();
        Customer c = new Customer();
    </code></pre>

    <p>newInstance is a method present in class Class. We can use newInstance method to create an object if we don't know
        class name at the beginning and it is available dynamically at the run time.
    </p>
    <pre><code>
        class Student {

        }
        class Customer {

        }
        public class Test {

            public static void main(String[] args) throws Exception {
                Object o = Class.forName(args[0]).newInstance();
                System.out.println("Object created for:" + o.getClass().getName());
        
            }
        
        }
    </code></pre>
    
    <pre><output>
        java Test Student<kbd>enter</kbd>
        Object created for Student
        java Test Customer<kbd>enter</kbd>
        Object created for Customer
        java Test java.lang.String<kbd>enter</kbd>
        Object created for java.lang.String
    </output></pre>

    <mark>In the case of new operator based on our requirement we can invoke any constructor</mark>
    <h6>Example</h6>
    <pre><code>
        Test t = new Test();
        Test t1 = new Test(10);
        Test t2 = new Test("durga");
    </code></pre>   
    
    <mark>But newInstance method internally calls no-arg constructor hence to use newInstance method 
        compulsory corresponding class should contain no-arg constructor o/w we will get RE saying InstantiationException
    </mark><br><br>

   <mark>While using new operator at run time if the corresponding .class file is not available then we will get RE saying
       NoClassDefFoundError: Test
   </mark> 

   <pre><code>
    public class Test {

        public static void main(String[] args) throws Exception {
            Student s = new Student();
    
        }    
</code></pre>

<pre><output>
    CE: NoClassDefFoundError: Test
</output></pre>

<mark>
    While using newInstance method at run time if the corresponding .class file not available then we will get RE 
    saying ClassNotFoundException
</mark>

<pre><code>
    public class Test {

        public static void main(String[] args) throws Exception {
            Object o = Class.forName(args[0]).newInstance();
        }
    
    }
</code></pre>

<pre><output>
    java Test Student<kbd>enter</kbd>
    RE: ClassNotFoundException: Student
</output></pre>

<p>At run time if Student.class file not available then we will get RE saying ClassNotFoundException: Student
<h6>Differences between new and newInstance</h6>
    <table class="table table-striped">
        <thead class="thead-dark">
            <tr>
                <th>new</th>
                <th>newInstance()</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>It is operator in java</td>
                <td>It is a method present in java.lang.Class</td>
            </tr> 
            <tr>
                <td>We can use new operator to create an object if we know class name at the beginning</td>
                <td>We can use newInstance method to create an object if we don't know class name at the beginning and it is available dynamically at the run time.</td>
            </tr> 
            <tr>
                <td>To use new operator class not required to contain no-arg constructor</td>
                <td>To use newInstance() compulsory class should contain no-arg constructor o/w we will get RE: InstantiationException</td>
            </tr>
            <tr>
                <td>At runtime if .class file not available then we get RE: NoClassDefFoundError which is unchecked</td>
                <td>At runtime if .class file not available then we get RE: ClassNotFoundException, which is checked</td>
            </tr>
        </tbody>
    </table>
    <h3>17. ClassNotFoundException vs NoClassDefFoundError</h3>
    <h6>Difference between ClassNotFoundException and NoClassDefFoundError</h6>
    <table class="table table-striped">
        <thead class="thead-dark">
            <tr>
                <th>NoClassDefFoundError</th>
                <th>ClassNotFoundException</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>For hardcoded class names, at run time if the corresponding .class file is not available then we will get RE saying NoClassDefFoundError which is unchecked<br>
                 Example:<br> Test t = new Test();<br>At run time if test.class file is not available then we will get RE saying NoClassDefFoundError : Test</td>
                <td>For dynamically provided class names at run time if the corresponding .class file is not available then we will get RE saying ClassNotFoundException, which is checked exception
                    <br>Example:<br>
                    Object o = Class.forName(args[0]).newInstance();
                    
                    <br>java Test Student<kbd>enter</kbd><br>
                    At run time if Student .class file not available then we will get RE saying ClassNotFoundException: Student
                 </td>
            </tr>
        </tbody>
    </table>
    <h3>18. instanceof vs isInstance()</h3>
    <table class="table table-striped">
        <thead class="thead-dark">
            <tr>
                <th>instanceof</th>
                <th>isInstance()</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>instanceof is an operator in java. We can use instanceof to check whether the given object is of particular type or not and we know the type at the beginning<br>
                 Example:<br> 
        <pre><code>
        Thread t = new Thread();
        SOP(t instanceof Runnable);
        SOP(t instanceof Object);
        </code></pre>
        </td>
                <td>isInstance() is a method present in java.lang.class. We can use isInstance method to check whether the given object is of particular type or not and we don't know the type at the beginning
                    and it is available dynamically at run time
                    <br>Example:<br>
        <pre><code>
        class Test {
            public static void main(String[] args) {
                Thread t = new Thread();
                SOP(Class.forName(args[0].isInstance(t));
                }
         }
        </code></pre>
        <pre><output>
        java Test Runnable<kbd>enter</kbd>
        true
        java Test String<kbd></kbd>
        false
        </output></pre>
                 </td>
            </tr>
        </tbody>
    </table>

    <mark>isInstance() is method equivalent of instanceof operator</mark>

    <h1>Flow Control</h1>
    <p>Flow control describes the order in which the statements will be executed at run time</p>
    <table class="table table-striped">
        <thead class="thead-dark">
            <tr>
                <th>Flow Control Statements</th>
                <th>Name</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Selection Statements</td>
                <td>1. if-else<br>2. switch()</td>
            </tr>
            <tr>
                <td>Iterative Statements</td>
                <td>1. while()<br>2. do-while()<br>3. for()<br>4. for-each(1.5v)</td>
            </tr>
            <tr>
                <td>Transfer Statements</td>
                <td>1. break<br>2. continue<br>3. return<br>4. try catch finally<br>5. assert</td>
            </tr>
        </tbody>
    </table>

    <h3>Selection Statements</h3>
    <h5>if-else</h5>
    <p>The argument to the if statements should be boolean type. By mistake if we are trying to provide
        any other type then we will get CE
    </p>
    <pre><code>
        int x = 0;
        if(x) {
            SOP("Hello")
        } else {
            SOP("Hii")
        }
    </code></pre>
    <pre><output>
        Exception in thread "main" java.lang.Error: Unresolved compilation problem: 
	Type mismatch: cannot convert from int to boolean
    </output></pre>

    <pre><code>
        int x = 10;
        if(x = 20) {
            SOP("Hello")
        } else {
            SOP("Hii")
        }
    </code></pre>
    <pre><output>
        Exception in thread "main" java.lang.Error: Unresolved compilation problem: 
	Type mismatch: cannot convert from int to boolean
    </output></pre>

    <pre><code>
        int x = 10;
        if(x == 20) {
            SOP("Hello")
        } else {
            SOP("Hii")
        }
    </code></pre>
    <pre><output>
        Hii
    </output></pre>

    <pre><code>
        boolean b = true;
        if(b = false) {
            SOP("Hello")
        } else {
            SOP("Hii")
        }
    </code></pre>
    <pre><output>
        Hii
    </output></pre>

    <pre><code>
        boolean b = false;
        if(b == false) {
            SOP("Hello")
        } else {
            SOP("Hii")
        }
    </code></pre>
    <pre><output>
        Hello
    </output></pre>

    <mark>Else part and curly braces are optional. Without curly braces only one statement is allowed under if, which should not be declarative statement</mark>

    <pre><code>
        if(true) 
            SOP("Hello")
    </code></pre>
    
    <pre><output>
        Hello
    </output></pre>

    <pre><code>
        if(true);
    </code></pre>
    
    <pre><output>
        valid
    </output></pre>

    <pre><code>
        if(true);;;;;;;;;;;;;;;;;;;;;;
    </code></pre>
    
    <pre><output>
        valid(we can add any number of semicolons it will be treated as empty statements)
    </output></pre>

    <mark>Semicolon is a valid java statements which is also known as empty statement</mark>

    <pre><code>
        if(true)
            int x = 10;
    </code></pre>
    
    <pre><output>
        Unresolved compilation problems: 
	Syntax error, insert ". class" to complete Expression
	Syntax error, insert "AssignmentOperator Expression" to complete Assignment
	Syntax error, insert ";" to complete Statement
	The left-hand side of an assignment must be a variable
	x cannot be resolved to a variable
    </output></pre>

    <pre><code>
        if(true) {
            int x = 10;
        }
    </code></pre>
    
    <pre><output>
        valid
    </output></pre>

    <pre><code>
        if(true)
            if(true)
                SOP("Hello");
        else
            SOP("Hii")
    </code></pre>
    
    <pre><output>
        Hello
    </output></pre>

    <mark>There is no dangling else problem in java. Every else is mapped to the nearest if statement</mark>
    <p>Earlier example is same as</p>
    <pre><code>
        if(true)
            if(true)
                SOP("Hello");
            else
                SOP("Hii")
    </code></pre>
    
    <pre><output>
        Hello
    </output></pre>
    <h5>Switch Statements</h5>
    <p>If several options are available then its not recommended to use nested if esle because it reduces readibility.
        To handle this requirement we should go for switch statement</p>
    <p>The allowed arguments types for the switch statement are byte short char int until 1.4v but <span style="color:blue">from 1.5v onwards corresponding
        wrapper classes and enum type also allowed. From 1.7v onwards string type also allowed</span>
    </p>
    <table class="table table-striped">
        <thead class="thead-dark">
            <tr>
                <th>1.4V</th>
                <th>1.5V</th>
                <th>1.7V</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>byte</td>
                <td>Byte</td>
                <td>String</td>
            </tr> 
            <tr>
                <td>short</td>
                <td>Short</td>
            </tr>
            <tr>
                <td>char</td>
                <td>Character</td>
            </tr>
            <tr>
                <td>int</td>
                <td>Integer</td>
            </tr>
            
        </tbody>
    </table>

    <mark>Curly braces are mandatory. Except switch everywhere curly braces are optional</mark>
    <p><span style="color:blue">Both case and default are optional i.e an empty switch statement is a valid java syntax</span></p>
    <pre><code>
        int x = 10;
        swicth(x) {

        }
    </code></pre>
    
    <pre><output>
        valid
    </output></pre>

    <pre><code>
        int x = 10;
        swicth(x) {
            SOP("Hello")
        }
    </code></pre>
    
    <pre><output>
        Test.java:6: error: case, default, or '}' expected
    </output></pre>

    <p><span style="color:blue">Inside switch every statements should be under some case or default i.e independent
        statements are not allowed inside switch o/w we will get compile time error</span>
    </p>

    <pre><code>
        int x = 10;
        int y = 20;
        switch(x) {
            case 10:
                SOP(10);
                break;
            case y:
                SOP(20);
                break;
        }
    </code></pre>
    
    <pre><output>
        <span style="color:red">CE: case expressions must be constant expressions</span>
    </output></pre>

    <pre><code>
        int x = 10;
        final int y = 20;
        switch(x) {
            case 10:
                SOP(10);
                break;
            case y:
                SOP(20);
                break;
        }
    </code></pre>
    
    <pre><output>
        10
    </output></pre>

    <mark>Every case label should be compile time constant i.e constant expression</mark>
    <p>If we declare y as final then we wont get any compile time error</p>

    <pre><code>
        int x = 59;
        switch(x + 1) {
            case 10:
                SOP(10)
            case 10 + 20+ 30:
                SOP(60)
        }
    </code></pre>
        
    <pre><output>
        60
    </output></pre>
    <mark>Both switch argument and case label can be expressions but case label should be constant expression</mark>

    <pre><code>
        byte b = 10;
        switch(b) {
            case 10:
                SOP(10);
                break;
            case 100:
                SOP(100);
                break;
            case 1000:
                SOP(1000);
        }
    </code></pre>
    
    <pre><output>
        CE: possible loss of precision 
        found: int
        required: byte
    </output></pre>

    <pre><code>
        byte b = 10;
        switch(b + 1) {
            case 11:
                SOP(10);
                break;
            case 100:
                SOP(100);
                break;
            case 1000:
                SOP(1000);
        }
    </code></pre>
    
    <pre><output>
        10
    </output></pre>

    <p>Every case label should be in the range of switch argument type o/w we will get compile time error</p>

    <pre><code>
        int x = 10;
        swicth(x) {
            case 97:
                SOP(97);
                break;
            case 98:
                SOP(98);
                break;
            case 99:
                SOP(99);
                break;
            case 'a':
                SOP('a')
        }
    </code></pre>
    
    <pre><output>
        CE: Duplicate case label 
    </output></pre>

    <p>Duplicate case labels are not allowed o/w we will get compile time error</p>

    <h6>Case label</h6>
    <p>1. It should be constant expression</p>
    <p>2. The value should be in the range of switch argument type</p>
    <p>3. Dupliacte case labels are not allowed</p>

    <h6>Fall through inside switch</h6>
    <pre><code>
        switch(x) {
            case 0:
                SOP(0);
            case 1:
                SOP(1);
                break;
            case 2:
                SOP(2);
            default: 
                SOP("def")
        }
    </code></pre>
    
    <pre><output>
        x = 0
        0
        1
        x = 1
        1
        x = 2
        2
        def
        x = 3
        def
    </output></pre>

    <pre><code>
        switch(x) {
            case 1:
            case 2:
            case 3:
                SOP("Q-1")
                break;
            case 4:
            case 5:
            case 6:
                SOP("Q-2")
                break;
        }
    </code></pre>

    <mark>Within the switch if any case is matched from that case onwards all statements will be executed until break
        or end of the switch. This is called fall through inside switch. The main advantage of fall through inside switch is we can define
        common action for multiple cases(code reusability)
    </mark>

    <h6>Default case</h6>
    <p>1. Within the switch we can take default case atmost once</p>
    <p>2. Default case will be executed if and only if there is no case matched</p>
    <p>3. Within the switch we can write default case anywhere but it is recommended to write as last case</p>

    <pre><code>
        switch(x) {
            default: 
                SOP("def");
            case 0:
                SOP(0);
                break;
            case 1:
                SOP(1);
            case 2:
                SOP(2); 
        }
    </code></pre>
    
    <pre><output>
        x = 0
        0
        x = 1
        1
        2
        x = 2
        2
        x = 3
        def
        0
    </output></pre>

    <h5>Iterative Statements</h5>
    <h6>while()</h6>
    <p>If we dont know number of iterations in advance then we should go for while loop.</p>
    <p>The argument should be boolean type if we are trying to provide any other type then we will get CE</p>
    <h6>Example</h6>

    <pre><code>
        while(rs.next()) {
            
        }
    </code></pre>
    
    <pre><code>
        while(e.hasMoreElements()) {

        }
    </code></pre>

    <pre><code>
        while(itr.hasNext()) {

        }
    </code></pre>

    <pre><code>
        while(1) {
            SOP("Hello")
        }
    </code></pre>
    
    <pre><output>
        CE: incompatible types
        found: int
        required: boolean
    </output></pre>
    
    <pre><code>
        while(true)
            SOP("Hello");
    </code></pre>
    
    <pre><output>
        Infinite times print Hello
    </output></pre>

    <pre><code>
        while(true);
    </code></pre>
    
    <pre><output>
        valid
    </output></pre>

    <pre><code>
        while(true)
            int x = 10;
    </code></pre>
    
    <pre><output>
        Unresolved compilation problems: 
	Syntax error, insert ". class" to complete Expression
	Syntax error, insert "AssignmentOperator Expression" to complete Assignment
	Syntax error, insert ";" to complete Statement
	The left-hand side of an assignment must be a variable
	x cannot be resolved to a variable
    </output></pre>
    
    <pre><code>
        while(true) {
            int x = 10;
        }
    </code></pre>
    
    <pre><output>
        valid
    </output></pre>
    <mark>Curly braces are optional and without curly braces we can take only one statement under while which should not be declarative statement</mark>

    <pre><code>
        while(true) {
            SOP("Hello")
        }
        SOP("Hii")
    </code></pre>
    
    <pre><output>
        CE: unreachable code( i.e SOP("Hii"))
    </output></pre>

    <pre><code>
        while(false) {
            SOP("Hello")
        }
        SOP("Hii")
    </code></pre>
        
    <pre><output>
        CE: unreachable code(i.e first curly brace of while)
    </output></pre>

    <pre><code>
        int a = 10, b = 20;
        while(a < b) {
            SOP("Hello")
        }
        SOP("Hii");
    </code></pre>
    
    <pre><output>
        Hello infinite number of times
    </output></pre>

    <pre><code>
        int a = 10, b = 20;
        while(a > b) {
            SOP("Hello")
        }
        SOP("Hii")
    </code></pre>
    
    <pre><output>
        Hii
    </output></pre>

    <pre><code>
        final int a = 10, b = 20;
        while(a < b) {
            SOP("Hello");
        }
        SOP("Hii");
    </code></pre>
    
    <pre><output>
        CE: unreachable code(i.e SOP("Hii"))
    </output></pre>

    <pre><code>
        final int a = 10, b = 20;
        while(a > b) {
            SOP("Hello")
        }
        SOP("Hii")
    </code></pre>
    
    <pre><output>
        CE: unreachable code(i.e first curly brace of while loop)
    </output></pre>

    <mark class="bg-primary text-white">Note: Every final variable will be replaced by the value at compile time only.</mark>
    <pre><code>
        final int a = 10;
        int b = 20;
        SOP(a);
        SOP(b);
    </code></pre>

    <h6>After compilation</h6>
    <pre><output>
        final int a = 10;
        int b = 20;
        SOP(10);
        SOP(b);
    </output></pre>
    <mark class="bg-primary text-white">If every argument is a final variable(compile time constant then that operation should be performed at compile time only)</mark>
    <pre><code>
        final int a = 10, b = 20;
        int c = 20;
        SOP(a + b);
        SOP(a + c);
        SOP(a < b);
        SOP(a < c);
    </code></pre>

    <h6>After compilation</h6>

    <pre><output>
        final int a = 10, b = 20;
        int c = 20;
        SOP(30);
        SOP(10 + c);
        SOP(true);
        SOP(10 < c);
    </output></pre>

    <h5>do-while()</h5>
    <p>If we want to execute loop body atleast once then we should go for do while</p>
    <pre><code>
        do {
            body
        }while(b);
    </code></pre>

    <p>Mandatory b should always be boolean type</p>
    
    <pre><code>
        do
            SOP("Hello");
        while(true);
    </code></pre>
    
    <pre><output>
        Infinite times hello
    </output></pre>

    <pre><code>
        do;
        while(true);
    </code></pre>

    <pre><output>
        valid
    </output></pre>

    <pre><code>
        do
            int x = 10;
        while(true);
    </code></pre>
    
    <pre><output>
        invalid
    </output></pre>

    <mark>Curly braces are optional and without curly braces we can take only on one statement between do and while
        which should not be declarative statement</mark>

    <pre><code>
        do {
            int x = 10;
        }while(true);
    </code></pre>
    
    <pre><output>
        valid
    </output></pre>

    <pre><code>
        do
        while(true);
    </code></pre>
    
    <pre><output>
        invalid(Between do and while no body is there, atleast semicolon is required,
         without having the body what is the need of taking the loop)
    </output></pre>

    <pre><code>
        public class Test {

            public static void main(String[] args) {
        
                do
                    while (true)
                        System.out.println("Hello");
                while (false);
            }
        
        }
    </code></pre>
    
    <pre><output>
        Infinite times hello
    </output></pre>

    <mark class="bg-primary text-white">This total thing is one do while statement. We entered into do while already thats why
        total syntax is by default reachable. First half is reachable an second half is not reachable my compiler is never going 
        to check that. Is do while reachable or not? Yes because I can able to enter already in do while
    </mark>

    <pre><code>
        do {
            SOP("Hello");
        }while(true);
        SOP("Hii");
    </code></pre>
    
    <pre><output>
        CE: unreachable code(i.e SOP("Hii"))
    </output></pre>

    <pre><code>
        do {
            SOP("Hello");
        }while(false);
        SOP("Hii");
    </code></pre>
    
    <pre><output>
        Hello
        Hii
    </output></pre>
    <pre><code>
        int a = 10, b = 20;
        do {
            SOP("Hello");
        }while(a < b);
        SOP("Hii");
    </code></pre>
    
    <pre><output>
        Infinite times hello
    </output></pre>

    <pre><code>
        int a = 10, b = 20;
        do {
            SOP("Hello");
        }while(a > b);
        SOP("Hii");
    </code></pre>
    
    <pre><output>
        Hello
        Hii
    </output></pre>

    <pre><code>
        final int a = 10, b = 20;
        do {
            SOP("Hello");
        }while(a < b);
        SOP("Hii");
    </code></pre>
    
    <pre><output>
        CE: unreachable code(i.e SOP("Hii"))
    </output></pre>
    <pre><code>
        final int a = 10, b = 20;
        do {
            SOP("Hello");
        }while(a > b);
        SOP("Hii");
    </code></pre>
    
    <pre><output>
        Hello
        Hii
    </output></pre>

    <h5>for loop</h5>
    <p>1. For loop is most common used loop in java</p>
    <p>2. If we know number of iterations in advance then for loop is the best choice</p>
    <p>3. Curly braces are optional and without curly braces we can take only one statement under for loop which should not be declarative statement</p>

    <pre><code>
        for(int i = 0; true; i++) {
            SOP("Hello");
        }
    </code></pre>
    
    <pre><output>
        Infinite times Hello
    </output></pre>

    <pre><code>
        for(int i = 0; i < 10; i++);
    </code></pre>
    
    <pre><output>
        valid
    </output></pre>

    <pre><code>
        for(int i = 0; i < 10; i++) 
            int x = 10;
        
    </code></pre>
    
    <pre><output>
        CE: Unresolved compilation problems: 
        Syntax error, insert ". class" to complete Expression
        Syntax error, insert "AssignmentOperator Expression" to complete Assignment
        Syntax error, insert ";" to complete Statement
        The left-hand side of an assignment must be a variable
        x cannot be resolved to a variable
    </output></pre>

    <h6>Initialization section</h6>
    <p>1. This part will be executed only once in loop life cycle.</p>
    <p>2. Here we can declare and initialize local variables of for loop</p>
    <p>3. Here we can declare any number of variables but should be of the same type by mistake if we are trying to declare different
        data type variables then we will get compile time error</p>
    <pre><code>
       int i = 0, j = 0;
       int i = 0, String s = "durga";
       int i = 0, int j = 0;
    </code></pre>
    
    <pre><output>
        valid
        invalid
        invalid
    </output></pre> 
    <p>If we want to speciify type once again, compulsory we have to use semicolon between these and if we 
        are taking semicolon then it would be treated as Conditional check so 3rd one is invalid.
    </p>
    <pre><code>
        int i = 0;
        for(SOP("Hello boss u r sleeping"); i < 3; i++) {
            SOP("No boss you only sleeping");
        }
    </code></pre>
    
    <pre><output>
        Hello boss u r sleeping
        No boss you only sleeping
        No boss you only sleeping
        No boss you only sleeping
    </output></pre>

    <p>4. In the Initialization section we can take any valid java statement including SOP</p>
    
    <h6>Conditional check</h6>
    <pre><code>
        for(int i = 0; <span class="bg-danger text-white">true</span>; i++) {
            
        }
    </code></pre>
    
    <p>1. Here we can take any valid java expression but should be of the type boolean</p>
    <p>2. This part is optional and if we are not taking anything then compiler will always place true</p>
    
    <h6>Increment or decrement section</h6>
    <pre><code>
        int i = 0;
        for(SOP("Hello"); i < 3; SOP("Hii")) {
            i++;
        }
    </code></pre>
    
    <pre><output>
        Hello
        Hii
        Hii
        Hii 
    </output></pre>

    <p>In the Incrementor decrement section we can take any valid java statement including SOP</p>

    <pre><code>
        for( ; ; ) {
            SOP("Hello");
        }
    </code></pre>
    
    <pre><output>
        Infinite times Hello
    </output></pre>
    <pre><code>
        for( ; ; );
    </code></pre>
    
    <pre><output>
        Infinite times execution
    </output></pre>

    <mark class="bg-primary text-white">All three parts of for loop are independent of each other and optional</mark>

    <pre><code>
        for(int i = 0; true; i++) {
            SOP("Hello");
        }
        SOP("Hii");
    </code></pre>
    
    <pre><output>
        CE: unreachable code(i.e SOP("Hii"))
    </output></pre>

    <pre><code>
        for(int i = 0; false; i++) {
            SOP("Hello");
        }
        SOP("Hii")
    </code></pre>
    
    <pre><output>
        CE: unreachable code(i.e for loop first curly brace)
    </output></pre>

    <pre><code>
        for(int i = 0; ; i++) {
            SOP("Hello");
        }
        SOP("Hii")
    </code></pre>
    
    <pre><output>
        CE: unreachable code(i.e SOP("Hii"))
    </output></pre>

    <pre><code>
        int a = 10, b = 20;
        for(int i = 0; a < b; i++) {
            SOP("Hello");
        }
        SOP("Hii");
    </code></pre>
    
    <pre><output>
        Hello infinite times
    </output></pre>

    <pre><code>
        int a = 10, b = 20;
        for(int i = 0; a > b; i++) {
            SOP("Hello");
        }
        SOP("Hii");
    </code></pre>
    
    <pre><output>
        Hii
    </output></pre>

    <pre><code>
        final int a = 10, b = 20;
        for(int i = 0; a < b; i++) {
            SOP("Hello");
        }
        SOP("Hii");
    </code></pre>
    
    <pre><output>
        CE: unreachable code(i.e SOP("Hii"))
    </output></pre>

    <pre><code>
        final int a = 10, b = 20;
        for(int i = 0; a > b; i++) {
            SOP("Hello");
        }
        SOP("Hii");
    </code></pre>
    
    <pre><output>
        CE: unreachable code(i.e for loop first curly brace)
    </output></pre>

    <h5>for-each loop(Enhanced for loop came into 1.5v)</h5>
    <p>It is specially designed loop to retrieve elements of arrays and collections</p>

    <h6>case 1: To print elements of 1D array</h6>
    <pre><code>
        int[] x = {10, 20, 30, 40};
    </code></pre>

    <p class="bg-primary text-white">Using normal for loop</p>
    <pre><code>
        for(int i = 0; i < x.length; i++) {
            SOP(x[i]);
        }
    </code></pre>

    <p class="bg-primary text-white">Using enhanced for loop</p>
    <pre><code>
        for(int x1 : x) {
            SOP(x1);
        }
    </code></pre>

    <h6>case 2: To print elements of 2D array</h6>
    <pre><code>
        int[][] x = {{10, 20, 30}, {40, 50}};
    </code></pre>

    <p class="bg-primary text-white">Using normal for loop</p>
    <pre><code>
        int[][] x = {{10, 20, 30}, {40, 50}};
        for(int i = 0; i < x.length; i++) {
            for(int j = 0; j < x[i].length; j++) {
                System.out.println(x[i][j]);
             }
        }
    </code></pre>

    <p class="bg-primary text-white">Using enhanced for loop</p>
    <pre><code>
        int[][] x = {{ 10, 20, 30 }, { 40, 50 }};
		for (int x1[] : x) {
			for(int x2 : x1) {
				System.out.println(x2);
			}
		}
    </code></pre>

    <h6>case 3: To print elements of 3D array</h6>
    <pre><code>
        int[][][] x = {{{10, 20, 30}, {40, 50}}, {{60, 70}, {80, 90}}};
    </code></pre>

    <p class="bg-primary text-white">Using enhanced for loop</p>
    <pre><code>
        int[][][] x = {{{10, 20, 30}, {40, 50}}, {{60, 70}, {80, 90}}};
		for (int x1[][] : x) {
			for (int x2[] : x1) {
				for (int x3 : x2) {
					System.out.println(x3);
				}
			}
		}
    </code></pre>

    <p>for each loop is the best choice to retrieve elements of arrays and collections but its limitation
        is it is applicable only for arrays and collections and it is not a general purpose loop</p>
    <p>By using normal for loop we can print array elements either in original order or in reverse order but using enhanced for loop
        we can print array elements only in original order but not in reverse order
    </p>

    <pre><code>
        int[] x = {10, 20, 30, 40, 50};
        for(int i = x.length - 1; i >= 0; i--) {
            SOP(x[i]);
        }
    </code></pre>

    <h5>Iterable(I) came in 1.5v</h5>
    <pre><code>
        for(eachitem x : target) {

        }
    </code></pre>
    <p>1. The target element in for each loop should be iterable object</p>
    <p>2. An object is said to be iterable iff corresponding class implements java.lang.Iterable interface</p>
    <p>3. Iterable interface introduced in 1.5v and it contains only one method iterator()</p>
    <h6>Syntax of iterator method</h6>
    <pre><code>
        public Iterator iterator()
    </code></pre>
    <p>4. All array related classes and collection implemented classes already implement iterable interface.
        Being a programmer we are not required to do anything just we should aware the point
    </p> 

    <h6>Differences between Iterator and Iterable</h6>
    <table class="table table-striped">
        <thead class="thead-dark">
            <tr>
                <th>Iterator(I)</th>
                <th>Iterable(I)</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>It is related to collections</td>
                <td>It is related to for-each loop</td>
            </tr> 
            <tr>
                <td>We can use to retrieve the elements of collections one by one</td>
                <td>The target element in for-each loop should be Iterable</td>
            </tr>
            <tr>
                <td>java.util package</td>
                <td>java.lang package</td>
            </tr>
            <tr>
                <td>There are three methods in this interface<br>1. hasNext()
                <br>2. next()<br>3. remove()</td>
                <td>Only one method present<br>1. iterator()</td>
            </tr>
        </tbody>
</table>
    
    <h5>Transfer Statements</h5>
    <h6>break</h6>
    <p>We can use break statement in the following places</p>
    <p>1. Inside switch to stop fall through</p>
    <p>2. Inside loops to break loop execution based on some condition</p>
    <p>3. Inside labeled blocks to break block execution based on some condition</p>

    <pre><code>
        public class Test {

            public static void main(String[] args) {
                int x = 10;
                l1: {
                    System.out.println("begin");
                    if(x == 10) 
                        break l1;
                    System.out.println("end");
                }
                System.out.println("Hello");
                
            }
        
        }
    </code></pre>
    
    <pre><output>
        begin
        Hello
    </output></pre>
    <mark>These are the only places where we can use break statement if we are using anywhere else we will get compile time error
        saying break outside switch or loop
    </mark>

    <pre><code>
        public class Test {

            public static void main(String[] args) {
                int x = 10;
                if(x == 10) 
                    break;
                System.out.println("Hello");
            }
        
        }
    </code></pre>
    <pre><output>
        Unresolved compilation problem: 
	break cannot be used outside of a loop or a switch
    </output></pre>

    <h5>continue</h5>
    <p>1. We can use continue statement inside loops to skip current iteration and continue for the next iteration</p>
    <pre><code>
        for (int i = 0; i < 10; i++) {
            if(i % 2 == 0) 
                continue;
            System.out.println(i);
        }
    </code></pre>
    <pre><output>
        1
        3
        5
        7
        9
    </output></pre>

    <p>2. We can use continue statement only inside loops if we are using anywhere else we will get 
        compile time error saying continue outside of loop</p>
        <pre><code>
            int x = 10;
            if(x == 10) 
                continue;
            System.out.println("Hello");
        </code></pre>
        <pre><output>
            Unresolved compilation problem: 
	continue cannot be used outside of a loop
        </output></pre>

    <h5>labeled break and continue</h5>
    <p>We can use labeled break and continue to break or continue a particular loop in nested loops</p>
    <pre><code>
        l1: 
        for() {
            l2:
            for() {
                l3:
                for() {
                    break l1;
                    break l2;
                    break;
                }
            }
        }
    </code></pre>

    <pre><code>
        public class Test {
            public static void main(String[] args) {
                l1: 
                for (int i = 0; i < 3; i++) {
                    for (int j = 0; j < 3; j++) {
                        if (i == j)
                            break;
                        System.out.println(i + " " + j);
                    }
                }
            }
        }
    </code></pre>
    <pre><output>
        1 0
        2 0
        2 1
    </output></pre>

    <pre><code>
        public class Test {
            public static void main(String[] args) {
                l1: for (int i = 0; i < 3; i++) {
                    for (int j = 0; j < 3; j++) {
                        if (i == j)
                            break l1;
                        System.out.println(i + " " + j);
                    }
                }
            }
        }
    </code></pre>
    <pre><output>
        No output
    </output></pre>

    <pre><code>
        public class Test {
            public static void main(String[] args) {
                l1: for (int i = 0; i < 3; i++) {
                    for (int j = 0; j < 3; j++) {
                        if (i == j)
                            continue;
                        System.out.println(i + " " + j);
                    }
                }
            }
        }
    </code></pre>
    <pre><output>
        0 1
        0 2
        1 0
        1 2
        2 0
        2 1
    </output></pre>
    <pre><code>
        public class Test {
            public static void main(String[] args) {
                l1: for (int i = 0; i < 3; i++) {
                    for (int j = 0; j < 3; j++) {
                        if (i == j)
                            continue l1;
                        System.out.println(i + " " + j);
                    }
                }
            }
        }
    </code></pre>
    <pre><output>
        1 0
        2 0
        2 1
    </output></pre>

    <h5>do-while() vs continue</h5>
    <pre><code>
        public class Test {
            public static void main(String[] args) {
                int x = 0;
                do {
                    x++;
                    System.out.println(x);
                    if(++x < 5) 
                        continue;
                    x++;
                    System.out.println(x);
                }while(++x < 10);
            }
        }
    </code></pre>
    <pre><output>
        1
        4
        6
        8
        10
    </output></pre>


    <h1>Declarations and Access Modifiers</h1>
    <h3>1. Java source file structure</h3>
    <p>A java program can contain any number of classes but atmost one class can be declared as public</p>
    <p>If there is a public class then name of the program and name of the public class must be matched o/w
        we will get compile time error</p>
    <pre><code>
        class A {

        }
        public class B {

        }
        class C {

        }
    </code></pre>

    <p>Now we can save this program as B.java only</p>
    <h5>Example 1:</h5>
    <h6>case 1:</h6>
    
    
<pre><output>
    A.java
    B.java
    C.java
    Durga.java
</output></pre>
<p>If there is no public class then we can use any name and there are no restrictions</p>

    <h6>Case 2:</h6>
    <p>If class B is public then name of the class should be B.java o/w we will get CE saying
        class B is public, should be declared in a file named B.java
    </p>

    <h6>case 3:</h6>
    <p>If class B and C declared as public and name of the program is B.java then we will get compile time error saying class C is public,
        should be declared in a file named C.java</p>
    
    <h5>Example 2:</h5>
    <pre><code>
        class A {
            public static void main(String[] args) {
                System.out.println("A class main");
            }
        }
        class B {
            public static void main(String[] args) {
                System.out.println("B class main");
            }
        }
        class C {
            public static void main(String[] args) {
                System.out.println("C class main");
            }
        }
        class D {
            
        }
    </code></pre>

    <p>Now we have saved this file with name Test .java</p>
    <img src="images/ss16.png" alt="ss12" width="800" height="300">
    <p>Here we can see that Test.class not created because that is not a class inside Test just the name 
        of the program</p>
    
<pre><output>
    javac Test.java
    java A<kbd>enter</kbd>
    A class main
    java B<kbd>enter</kbd>
    B class main
    java C<kbd>enter</kbd>
    C class main
    java D<kbd>enter</kbd>
    CE: Error: Main method not found in class D, please define the main method as:
    java Test<kbd>enter</kbd>
    CE: Error: Could not find or load main class Test
    Caused by: java.lang.ClassNotFoundException: Test
    (old version - NoClassDefFoundError)
</output></pre>

    <h6>Conclusions</h6>
    <p>1. Whenever we are compiling a java program, for every class present in the program a separate .class file
        will be generated</p>
    <p>2. We can compile a java program(java source file) but we can run a java .class file</p>
    <p>3. Whenever we are executing a java class the corresponding class method will be executed. If the class doesnt
        contain main mehtod then we will get RE saying NoSuchMethodError: main</p>
    <p>4. If the corresponding .class file not available then we will get RE saying NoClassDefFoundError</p>
    <p>5. It is not recommended to declare multiple classes in a single source file. It is highly recommended to declare 
        only one class per source file and name of the program we have to keep same as class name. The main advantage of this approach is
        readibility and maintainability of the code will be improved</p>

    <h5>Import statement</h5>
    <pre><code>
        class Test {
            public static void main(String[] args) {
                ArrayList l = new ArrayList();
            }
        }
    </code></pre>
    
<pre><output>
    CE error: cannot find symbol
                ArrayList l = new ArrayList();
</output></pre>

<p>We can slolve this problem by using fully qualified name</p>
<pre><code>
    class Test {
        public static void main(String[] args) {
            <span class="bg-primary text-white">java.util.ArrayList</span> l = java.util.new ArrayList();
        }
    }
</code></pre>
<p>The problem with usage of fully qualified name everytime is it increases length of the code and reduces readibility. We can solve this problem by using import statement</p>
<p>Whenever we are writing import statement it is not required to use fully qualified name everytime. We can use shortname directly</p>

<pre><code>
import java.util.ArrayList;

class Test {
	public static void main(String[] args) {
		ArrayList l = new ArrayList();
	}
}
</code></pre>

<p>Hence import statement acts as typing shortcut</p>

<h6>Case 1: Types of import statements</h6>
<p>There are two types of import statements</p>
<h5>1. Explicit class Import</h5>
<h6>Example: </h6>
<p>import java.util.ArrayList</p>
<p>It is highly recommended to use Explicit class import because it improves readibility of the code.
    Best suitable for Hi-Tech city where readibility is important</p>

<h5>2. Implicit class Import</h5>
<h6>Example: </h6>
<p>import java.util.*</p>
<p>Not recommended to use because it reduces readibility of the code. Best suitable for amerpet where typing is important</p>

<h6>Case 2:</h6>
<p>Which of the following import statements are meaningful</p> 
<pre><code>
    import java.util.ArrayList;
    import java.util.ArrayList.*;
    import java.util.*;
    import java.util;
</code></pre>

<pre><output>
    meaningful
    not meaningful
    meaningful
    not meaningful
</output></pre>

<h6>Case 3: </h6>
<p>Consider the following code</p>
<pre><code>
    class myObject extends java.rmi.UnicastRemoteObject {

    }
</code></pre>
    
<pre><output>
    The code compiles fine even though we are not writing import statement
      because we used fully qualified name
</output></pre>

<mark>Whenever we are using fully qualified name it is not required write import statement.
    Similarily Whenever we are writing import statement it is not required to use fully qualified name
</mark>

<h6>Case 4: </h6>
<pre><code>
    import java.util.*;
    import java.sql.*;
    class Test {
        public static void main(String[] args) {
            Date d = new Date();
        }
    }
</code></pre>

<pre><output>
    CE:  reference to Date is ambiguous
</output></pre>

<mark>Note: Even in the case of list also we may get same ambiguity problem because it is available
    in both util and awt packages</mark>

    <h6>Case 5: </h6>
    <mark class="bg-primary text-white">While resolving class names compiler will always gives a precedence in the following order</mark>
    <h5>1. Explicit class import</h5>
    <h5>2. Classes present in current working directory(default package)</h5>
    <h5>3. Implicit class import</h5>
    <pre><code>
        import java.util.Date;
        import java.sql.*;
        class Test {
            public static void main(String[] args) {
                Date d = new Date();
                System.out.println(d.getClass().getName());
            }
        }
    </code></pre>
    <pre><output>
        java.util.Date
    </output></pre>
    <p>In the above example util package date got considered</p>

    <h6>Case 6: </h6>
    <mark>Whenever we are importing a java package all classes and Interfaces present in that package by default available but not
        subpackage classes. If we want to use subpackage class compulsory we should write import statement until subpackage level</mark>
    <h6>Example: </h6>
    <p>java.util.regex.Pattern;</p>
    <p>To use pattern class in our program which import statement is required</p>
    <pre><code>
        import java.*;
        import java.util.*;
        import java.util.regex.*;
        No import required
    </code></pre>
    
    <pre><output>
        import java.util.regex.*; is required
    </output></pre>

    <h6>Case 7: </h6>    
    <p>All classes and Interfaces present in the following packages are by default available to every java program.
        Hence we are not required to write import statement
    </p>
    <p>1. java.lang package</p>
    <p>2. default package(CWD)</p>
 
    <h6>Case 8: </h6>
    <p>Import statements is totally compile time related concepts if more number of imports then more will be the compile time but there is
        no effect on execution time(run time)</p>

    <h6>Case 9: </h6>
    <p>Difference between c language #include and java language import statement</p>
    <p>In the case of c language #include, all input output header files will be loaded at beginning only(at translation time).
        Hence it is static include.</p>
    <p>But in the case of java import statement no .class file will be loaded at the beginning. Whenever we are using a particular class then only
        corresponding .class file will be loaded. This is like dynamic include or load on demand or load on fly
    </p>  

    
    <h5>1.5v new features</h5>
    <p>1. for-each loop</p>
    <p>2. var-args methods</p>
    <p>3. Autoboxing and Autounboxing</p>
    <p>4. Generics</p>
    <p>5. co-varient return types</p>
    <p>6. Queue</p>
    <p>7. Annotations</p>
    <p>8. enum</p>
    <p>9. static import</p>

    <h5>Static import</h5>
    <p>Introduced in 1.5v. According to SUN usage of static import reduces the length of the code and improves readibility but According
        to world wide programming experts(like us) usage of static import creates confusion and reduces readibility . Hence if there is no specific
        requirement then its not recommended to use static import</p>
        
    <p>Usually we can access static members by using class name but Whenever we are writing static import we can access static members directly without class name</p>

    <h6>Without static import</h6>
    <pre><code>
class Test {
    public static void main(String[] args) {
        System.out.println(Math.sqrt(4));
        System.out.println(Math.max(4, 2 ));
        System.out.println(Math.random());
    }
}
    </code></pre>

    <h6>With static import</h6>
    <pre><code>
import static java.lang.Math.*;
class Test {
    public static void main(String[] args) {
        System.out.println(sqrt(4));
        System.out.println(max(4, 2 ));
        System.out.println(random());
    }
}
    </code></pre>

    <div class="container">
        <p class="bg-warning text-white">Explain about System.out.println()?</p>
        <pre><code>
class Test {
    static String s = "durga";
    public static void main(String[] args) {
        System.out.println(Test.s.length());
    }
}
        </code></pre>

        <p>Test is class name</p>
        <p>s is a static  variable present in Test class of the type java.lang.String</p>
        <p>length() is a method present in String class</p>
        <pre><code>
import java.io.PrintStream;
public class System {
	static PrintStream out; 
	public static void main(String[] args) {
		System.out.println();
	}
}   
 </code></pre>
    <p>System is a class present in java.lang package</p>
    <p>'out' is a static variable present in System class of the type PrintStream</p>
    <p>println() is a method present in PrintStream class</p>

    <h6>With static import</h6>
   
<p>out is a static variable present in System class hence we can access by using class name System but
    Whenever we are writing static import its not required to use class name and we can access out directly</p> 
    <pre><code>
        import static java.lang.System.out;
        public class System { 
            public static void main(String[] args) {
                out.println("Hello");
            }
        }
    </code></pre>
    </div>

    <pre><code>
import static java.lang.Integer.*;
import static java.lang.Byte.*;
class Test {

    public static void main(String[] args) {
        System.out.println(MAX_VALUE);
    }
}
    </code></pre>
    
    <pre><output>
        CE :Error: Unresolved compilation problem: 
        The field MAX_VALUE is ambiguous
    </output></pre>

    <mark class="bg-primary text-white">While resolving static members compiler will always consider the precendence in the following order</mark>
    <p>1. Current class static members</p>
    <p>2. Explicit static import</p>
    <p>3. Implicit staic import</p>

        <pre><code>
import static java.lang.Integer.MAX_VALUE;
import static java.lang.Byte.*;
class Test {
    static int MAX_VALUE=999;
    public static void main(String[] args) {
        System.out.println(MAX_VALUE);
    }
}
    </code></pre>
    
    <pre><output>
        999
    </output></pre>

        <pre><code>
import static java.lang.Integer.MAX_VALUE;
import static java.lang.Byte.*;
class Test {
    //static int MAX_VALUE=999;
    public static void main(String[] args) {
        System.out.println(MAX_VALUE);
    }
}
    </code></pre>
    
    <pre><output>
        2147483647
    </output></pre>

<pre><code>
//import static java.lang.Integer.MAX_VALUE;
import static java.lang.Byte.*;
class Test {
    //static int MAX_VALUE=999;
    public static void main(String[] args) {
        System.out.println(MAX_VALUE);
    }
}
</code></pre>
    
<pre><output>
    127
</output></pre>

<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>Normal import</th>
            <th>Static import</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1.Explicit Import</td>
            <td>1. Explicit static import</td>
        </tr> 
        <tr>
            <td>Syntax: <br>import packagename.classname;</td>
            <td>Syntax: <br>import static packagename.classname.staticmember;</td>
        </tr> 
        <tr>
            <td>Example</td>
            <td>Example</td>
        </tr> 
        <tr>
            <td>import java.util.ArrayList;</td>
            <td>import static java.lang.Math.sqrt;<br>
            import static java.lang.System.out;</td>
        </tr> 
        <tr>
            <td>2. Implicit Import</td>
            <td>2. Implicit static import</td>
        </tr> 
        <tr>
            <td>Syntax: <br>import packagename.*;</td>
            <td>Syntax: <br>import static packagename.classname.*;</td>
        </tr> 
        <tr>
            <td>Example</td>
            <td>Example</td>
        </tr> 
        <tr>
            <td>import java.util.*;</td>
            <td>import static java.lang.Math.*;<br>
            import static java.lang.System.*;</td>
        </tr> 
    </tbody>
</table>

<div class="container">
    <p class="bg-warning text-white">Which of the following import statements are valid?</p>
    <pre><code>
        import java.lang.Math.*;
        import static java.lang.Math.*;
        import java.lang.Math.sqrt;
        import static java.lang.Math.sqrt();
        import java.lang.Math.sqrt.*;
        import static java.lang.Math.sqrt;
        import java.lang;
        import static java.lang;
        import java.lang.*;
        import static java.lang.*;
    </code></pre>
    
    <pre><output>
        invalid
        valid
        invalid
        invalid
        invalid
        valid
        invalid
        invalid
        valid
        invalid
    </output></pre>
</div>

<mark>Two packages contains a class or interface with the same name is very rare and hence
    ambiguity problem is also very rare in normal import.
</mark><br>

<mark>But two classes or interfaces contain a variable or method with the same name is very common and hence 
    ambiguity problem is also very common problem in static import
</mark>

<p>Usage of staic import reduces readibility and creates confusion and hence if there is no specific requirement then it is not recommended to
    use static import.
</p>

<h6>Difference between normal import and static import</h6>
<p>We can use normal import to import classes and interfaces of a particular package. Whenever we are using normal import it is
    not required to use fully qualified name and we can use short names directly
</p>
<p>We can use static import to import static members of a particular class or interface. Whenever we are writing static import it is Not
    required to use class name to access static members and we can access directly</p>

<h5>packages</h5>
<p>It is an encapsulation mechanism to group related classes and interfaces into a single unit which is nothing but package</p>
<h6>Example 1:</h6>
<p>All classes and interfaces which are required for database operations are grouped into a single package which is nothing but java.sql package</p>
<h6>Example 2:</h6>
<p>All classes and interfaces which are useful for file io operations are grouped into a separate package which is nothing but java.io package</p>

<p>The main advantages of package are</p>
<p>1. To resolve naming conflicts(unique identification of our components)</p>
<p>2. It improves modularity of the application</p>
<p>3. It improves maintainability of the application</p>
<p>4. It provides security for our components</p>

<p>There is one universally accepted naming convention for packages i.e to use internet domain name in reverse</p>
<h6>Example: </h6>
<p>com.icicibank.loan.housing.Account</p>



<img src="images/ss48.png" alt="ss12" width="600" height="600">

<h6>Example 3:</h6>
<pre><code>
package com.durgasoft.scjp;
import java.sql.Date;
class Test {
	public static void main(String[] args) {
		
		System.out.println("package demo");
	}
}
</code></pre>

<pre><output>
    javac Test.java<kbd>enter</kbd>
    generated .class file will be placed in current working directory
    javac -d . Test.java<kbd>enter</kbd>
     Here -d is destination to place generated .class files, . means CWD
</output></pre>
<img src="images/ss18.png" alt="ss12" width="300" height="300">
<p>Generated .class file will be placed in corresponding package structure</p>
<p>If the corresponding package structure not already available then this command itself will create corresponding package
    structure
</p>

<p>As destination instead of . we can take any valid directory name</p>

<pre><output>
    javac -d F: Test.java<kbd>enter</kbd>
</output></pre>
<img src="images/ss17.png" alt="ss12" width="300" height="300">

<h6>Conclusions</h6>
<p>1. In any java source file there can be atmost one package statement i.e more than one package statements is not allowed o/w 
    we will get CE: class, interfaces or enum expected
</p>2. In any java program the first non comment statements should be package statement(if it is available) o/w we will get CE: class, interface
or enum expected</p>

    <h3>2. Class level modifiers</h3>
    <p>Whenever we are writing our own classes we have to provide some information about our class to the JVM like whether this class can be accessible
        from anywhere or not, whether child class creation is possible or not, whether object creation is possible or not etc We can specify this information 
        by using appropriate modifier
    </p>

    <p>The only applicable modifiers for top level classes are</p>
    <p>1. public</p>
    <p>2. &ltdefault></p>
    <p>3. final</p>
    <p>4. abstract</p>
    <p>5. strictfp</p>

    <p>But for inner classes the applicable modifiers are</p>
    <p>1. public</p>
    <p>2. &ltdefault></p>
    <p>3. final</p>
    <p>4. abstract</p>
    <p>5. strictfp</p>
    <p>+</p>
    <p>6. private</p>
    <p>7. protected</p>
    <p>8. static</p>

    <pre><code>
        private class Test {
            public static void main(String[] args) {
                
                System.out.println("package demo");
            }
        }
    </code></pre>
    
    <pre><output>
        CE: modifier private not allowed here
    </output></pre>

    <pre><code>
        private class A {

        }
    
        static class B {
    
        }
    
        public static void main(String[] args) {
    
            System.out.println("package demo");
        }
    </code></pre>
    
    <pre><output>
        valid
    </output></pre>
   
    <h6>Access specifiers vs Access modifiers</h6>
    <p>public private protected default are considered as specifiers except these remaining are considered as modifiers but
        this rule is applicable only for old languages like C++ but not in java.
    </p>
    <p>In java all are considered as modifier only. There is no word like specifier</p>
    <h1>1. public modifier</h1>
    <h5>public classes</h5>
    <p>If a class declared as public then we can access that class from anywhere</p>
    <pre><code>
package com.cts.pack1;
public class A {
	public void m1() {
		System.out.println("Hello");
	}
}
package com.cts.pack2;
import com.cts.pack1.A;
public class B {
	public static void main(String[] args) {
		A a = new A();
		a.m1();
	}

}
    </code></pre>
    
    <pre><output>
        javac -d . B.java<kbd>enter</kbd>
        java pack2.B<kbd>enter</kbd>
        Hello
    </output></pre>

    <p>If class A is not public then while compiling B class we will get CE saying pack1.A is not public in pack1; cant be accessed from outside package</p>

    <h1>2. default modifier</h1>
    <h5>default classes</h5>
    <p>If a class declared as default then we can access that class only within the current package i.e from outside package we cant access. Hence
        default access is also known as package level access
    </p>

    <h1>3. final modifier</h1>
    <h5>final modifier</h5>
    <p>Final is a modifier applicable for classes, methods and variables</p>
    <h6>final method</h6>
    <p>Whatever method parents has by default available to the child through inheritance, if the child not satisfied with parent method implementation then child
        is allowed to redefine that method based on its requirement. This process is called overriding.
    </p>
    <p>If the parent class method is declared as final then we cant override that method in the child class because its implementation is final</p>

    <pre><code>
        public class P {
            public void property() {
                System.out.println("cash + land + gold");
            }
            public final void marry() { 
                System.out.println("Subbalakshmi");
            }
        }
        public class C extends P{
            public void marry() {
                System.out.println("Isha + 9tara + kareen");
            }
        
        }
    </code></pre>
    
    <pre><output>
        CE: 
        error: marry() in C cannot override marry() in P
                public void marry() {
                            ^
          overridden method is final
        
    </output></pre>

    <h6>final class</h6>
    <p>If a class declared as final, we cant extend functionality of that class i.e we cant create child class for that class i.e
        inheritance is not possible for final classes</p>
        <pre><code>
            final class P {
                public void property() {
                    System.out.println("cash + land + gold");
                }
                public final void marry() { 
                    System.out.println("Subbalakshmi");
                }
            }
            public class C extends P{
                public void marry() {
                    System.out.println("Isha + 9tara + kareen");
                }
            
            }
        </code></pre>
        
        <pre><output>
            CE: 
            error: cannot inherit from final P
        </output></pre>

<mark class="bg-primary text-white">Note: Every method present inside final class is always final bydefault but every variable present
    inside final class need not be final.<br>
</mark>
<mark>The main advantage of final keyword is we can achieve security and we can provide unique implementation but the main disadvantage of
    final keyword is we are missing key benefits of oops: Inheritance(because of final classes) and polymorphism(because of final methods).
    Hence if there is no specific requirement then its not recommended to use final keyword
</mark>

    <h1>4. Abstract modifier</h1>
    <h5>Abstract modifiers</h5>
    <p>Abstract is a modifier applicable for classes and methods but not for variables</p>
    <h6>Abstract method</h6>
    <p>Even though we dont know about implementation still we can declare a method with abstract modifier i.e for abstract methods only declaration is available
        but not implementation
    </p>
    <p>Abstract method declaration should ends with ;</p>

    <pre><code>
        public abstract void m1(); (valid)
        public abstract void m1() {} (invalid)
    </code></pre>
    <p>Child class is responsible to provide implementation for parent class abstract methods</p>
    
    <pre><code>
        abstract class Vehicle {
            abstract public int getNoOfWheels();
        }
        class Bus extends Vehicle {
            public int getNoOfWheels() {
                return 7;
            }
        }
        class Auto extends Vehicle {
            public int getNoOfWheels() {
                return 3;
            }
        }
    </code></pre>
    
    <p>By declaring abstract class in the parent class we can provide guidelines to the child classes such that which methods compulsory child has to implement</p>
    <p>Abstract method never talks about implementation if any modifier talks about implementation then it forms illegal combination with abstract modifier.</p>
    <p>The following are various illegal combination of modifiers for methods with respect to abstract</p>
    <img src="images/ss19.png" alt="ss12" width="300" height="500"><br>
    <mark class="bg-primary text-white">final h ki synchronized(occur at the same time or rate.) strict rhenge native pr jo static h(lacking in movement) private jeevan nhi hoga unka koi</mark>
    <h6>Example : </h6>
    <pre><code>
        abstract final void m1();
    </code></pre>
    <pre><output>
       CE error: illegal combination of modifiers: abstract and final
    </output></pre>

    <mark>For any java class if we are not allowed to create an object(because of partial implementation) such type of class we have to declare with abstract modifiers
        i.e for abstract classes instantiation is not possible.
    </mark>

    <pre><code>
        abstract class Test {
            public static void main(String[] args) {
               Test t = new Test();
           }
       }
    </code></pre>
    <pre><output>
        Test is abstract; cannot be instantiated
    </output></pre>

    <h6>Abstract class vs Abstract method</h6>
    <p>1. If a class contains atleast one abstract method then compulsory we should declare class as abstract o/w we will get CE</p>
    <p>Reason: If a class contains atleast one abstract method then implementation is not complete and hence it is not recommended to create an object. To restrict object instantiation 
        compulsory we should declare class as abstract</p>
    <p>Example: If we brought vehile object in the market then people will ask noOfWheels in your vehicle but since we dont have implementation then we wont be in a position to tell </p>

    <p>2. Even though class doesnt contain any abstract method still we can declare class as abstract if we dont want instantiation i.e abstract class can conatin 0 number of abstract methods also</p>
    <p>Example 1: HTTP servlet class is abstract but it doesnt contain any abstract methods</p>
    <p>Example 2: Every adapter class is recommended to declare as abstract but it doesnt contain any abstract method</p>

    <pre><code>
        class Test {
            public void m1();
       }
    </code></pre>
    
<pre><output>
    CE error: missing method body, or declare abstract
</output></pre>

<pre><code>
    class Test {
        public abstract void m1() {}
   }
</code></pre>

<pre><output>
CE  error: Test is not abstract and does not override abstract method m1() in Test
class Test {
^
Test.java:2: error: abstract methods cannot have a body
</output></pre>

<pre><code>
    class Test {
        public abstract void m1();
   }
</code></pre>

<pre><output>
CE error: error: Test is not abstract and does not override abstract method m1() in Test
</output></pre>

<mark>If we are extending abstract class then for each and every abstract method of parent class we should provide implementation o/w we
    have to declare child class as abstract.
</mark>

<p>In this case next level child class is responsible to provide implementation</p>

<pre><code>
    abstract class P {
        public abstract void m1();
        public abstract void m2();
   }
   class C extends P {
       public void m1() {}
   }
</code></pre>

<pre><output>
CE  error: C is not abstract and does not override abstract method m2() in P
</output></pre>

<h6>final vs abstract</h6>
<p>1. Abstract methods compulsory we should override in child classes to provide implementation whereas we cant override final methods.
    Hence final abstract combination is illegal combination for methods</p>
<p>2. For final classes we cant create child class whereas for abstract classes we should create child class to provide implementation. Hence
    final abstract combination is illegal for classes</p>

    <mark>Abstract class can contain final method whereas final class cant contain abstract method</mark>

    <pre><code>
        abstract class Test {
            public final void m1() {

            }
        }
    </code></pre>
    
    <pre><output>
        valid
    </output></pre>

    <p>Final method inside abstract class is allowed</p>
    
    <pre><code>
        final class Test {
            public abstract void m1();
        }
    </code></pre>
    
    <pre><output>
        illegal combination
    </output></pre>

    <p>Abstract method inside final class is not allowed</p>
 
    <mark>Note: It is highly recommended to use abstract modifier because it promotes several OOPS features like inheritance and polymorphism</mark>
    
    <h1>5. strictfp modifier</h1>
    <h5>strictfp modifier(strict floating point came in 1.2 version)</h5>
    <p>1. Introduced in 1.2v</p>
    <p>2. We can use strictfp for classes and methods but not for variables</p>
    <p>3. Usually the result of floating point arithmetic is varied from platform to platform if we want platform independent results for floating point arithmetic
        then we should go for strictfp modifier</p>

    <h6>strictfp method</h6>
    <p>If a method declared as strictfp all floating point calculations in that method has to follow IEEE754 standard so that we will get platform independent results</p>
    <p>Abstract modifier never talks about implementation whereas strictfp method always talks about implementation. Hence abstract strictfp combination is illegal for methods</p>

    <h6>strictfp class</h6>
    <p>If a class declared as strictfp then every floating point calculation present in every <span class="bg-primary text-white">concrete</span> method has to follow
        IEEE754 standard so that we will get platform independent results</p>
    
    <p>We can declare abstract strictfp combination for classes i.e abstract strictfp combination is legal for classes but illegal for methods</p>
    <pre><code>
        abstract strictfp class Test {
            
        }
    </code></pre>
    
    <pre><output>
        legal
    </output></pre>

    <pre><code>
        abstract strictfp class Test {
            abstract strictfp void m1();
     }     
    </code></pre>
    
    <pre><output>
        CE: illegal combination of modifiers: abstract and strictfp
    </output></pre>
    
    <h3>3. Member level modifiers</h3>
     <h5>Member modifiers(method or variable level modifiers)</h5>
    <h6>Public members</h6>
    <p>If a member declared as public then we can access that member from anywhere</p>
    <p>But corresponding class should be visible i.e before checking member visibility we have to check class visibility</p>
    <pre><code>
        package pack1;
        class A {
            public void m1() {
                SOP("A class method");
            }
        }

        package pack2;
        import pack1.A;
        class S {
            public static void main(String[] args) {
                A a = new A();
                a.m1();
            }
        }
    </code></pre>
    
    <pre><output>
        javac -d . A.java<kbd>enter</kbd>
        javac -d . S.java<kbd>enter</kbd>
        CE: error: A is not public in pack1; cannot be accessed from outside package
    </output></pre>

     <p>In the above example even though m1() method is public we cant access from outside package because corresponding class A is not public i.e if both class and method 
         are public then only we can access the method from outside package</p>
    
         <pre><code>
            package pack1;
            public class A {
                public void m1() {
                    SOP("A class method");
                }
            }
    
            package pack2;
            import pack1.A;
            class S {
                public static void main(String[] args) {
                    A a = new A();
                    a.m1();
                }
            }
        </code></pre>
        
        <pre><output>
            javac -d . A.java<kbd>enter</kbd>
            javac -d . S.java<kbd>enter</kbd>
            java pack2.S<kbd>enter</kbd>
            A class method
        </output></pre>

        <h6>default members</h6>
        <p>If a member declared as default then we can access that member only within the current package i.e from outside of the package we cant access. Hence default access is also known as 
            package level access</p>

        <h1>6.private modifier</h1>
        <h6>private members</h6>
        <p>If a member is private then we can access that member only within the class i.e from outside of the class we cant access.</p> 
        <p>Abstract methods should be available to the child classes to provide implementation whereas private methods are not available to the child classes.
        Hence private abstract combination is illegal for methods.</p>
        
        <h1>7. protected modifier</h1>
        <h6>protected members(the most misunderstood modifier in java)</h6>
        <p>If a member declared as protected then we can access that member anywhere within the current package but only in child classes of outside package</p>
        <p>protected = &ltdefault> + kids</p>

        <pre><code>
            package pack1;
            public class A {
                protected void m1() {
                    SOP("The most misunderstood modifier");
                }
            }
    
            class B extends A {
                public static void main(String[] args) {
                    A a = new A();
                    a.m1();  
                    B b = new B();
                    b.m1();
                    A a1 = new B();
                    a1.m1();              
                }
            }
        </code></pre>
        
        <pre><output>
            javac -d . A.java<kbd>enter</kbd>
            java pack1.B<kbd>enter</kbd>
            The most misunderstood modifier
            The most misunderstood modifier
            The most misunderstood modifier
        </output></pre>

        <mark>We can access protected members within the current package anywhere either by using parent reference or by using child reference</mark>
        <br>
        <mark>But we can access protected members in outside package only in child classes and we should use child reference only i.e parent reference can not be used to access 
            protected members from outside package
        </mark>

        <pre><code>
            package pack1;
            public class A {
                protected void m1() {
                    SOP("The most misunderstood modifier");
                }
            }
    
            class B extends A {
                public static void main(String[] args) {
                    A a = new A();
                    a.m1();  
                    B b = new B();
                    b.m1();
                    A a1 = new B();
                    a1.m1();              
                }
            }

            package pack2;
            import pack1.A;
            class C extends A {
                public static void main(String[] args) {
                    A a = new A();  &#10060
                    a.m1();
                    C c = new C();  &#10004
                    c.m1();
                    A a1 = new C(); &#10060
                    a1.m1();
                }
            }
        </code></pre>

        <pre><output>
            javac -d . A.java<kbd>enter</kbd>
            java pack1.B<kbd>enter</kbd>
            The most misunderstood modifier
            The most misunderstood modifier
            The most misunderstood modifier
            javac -d . C.java<kbd>enter</kbd>
            CE:  error: m1() has protected access in P
        </output></pre>

        <pre><code>
            package pack1;
            public class A {
                protected void m1() {
                    SOP("The most misunderstood modifier");
                }
            }
    
            class B extends A {
                public static void main(String[] args) {
                    A a = new A();
                    a.m1();  
                    B b = new B();
                    b.m1();
                    A a1 = new B();
                    a1.m1();              
                }
            }
            
            package pack2;
            import pack1.A;
            class C extends A {
                public static void main(String[] args) {
                    C c = new C();
                    c.m1(); 
                }
            }
        </code></pre>

        <pre><output>
            javac -d . A.java<kbd>enter</kbd>
            java pack1.B<kbd>enter</kbd>
            The most misunderstood modifier
            The most misunderstood modifier
            The most misunderstood modifier<br>
            javac -d . C.java<kbd>enter</kbd>
            java pack2.C;<kbd>enter</kbd>
            The most misunderstood modifier
        </output></pre>

        <mark>We can access protected members from outside package only in child classes and we should use that child class reference only
            For example: From D class if we want to access we should use D class reference only</mark>
        
            <pre><code>
                package pack1;
                public class A {
                    protected void m1() {
                        SOP("The most misunderstood modifier");
                    }
                }
            
                package pack2;
                import pack1.A;
                class C extends A {
                    
                }
                class D extends C {
                    public static void main(String[] args) {
                        A a = new A();  &#10060
                        a.m1();
                        C c = new C();  &#10060
                        c.m1();
                        D d = new D();  &#10004
                        d.m1();
                        A a1 = new C(); &#10060
                        a1.m1();
                        A a1 = new D(); &#10060
                        a1.m1();
                        C c1 = new D(); &#10060
                        c1.m1();
                    }
                }
            </code></pre>
    
            <pre><output>
                CE: m1() has protected access in pack1.A
            </output></pre>

            <h6>Summary table of private protected &ltdefault> public modifiers</h6>
            <table class="table table-striped">
                <thead class="thead-dark">
                    <tr>
                        <th>Visibility</th>
                        <th>private</th>
                        <th>&ltdefault></th>
                        <th>protected</th>
                        <th>public</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Within the same class</td>
                        <td class="bg-success text-white">visible</td>
                        <td class="bg-success text-white">visible</td>
                        <td class="bg-success text-white">visible</td>
                        <td class="bg-success text-white">visible</td>
                    </tr> 
                    <tr>
                        <td>From child class of same package</td>
                        <td class="bg-danger text-white">not visible</td>
                        <td class="bg-success text-white">visible</td>
                        <td class="bg-success text-white">visible</td>
                        <td class="bg-success text-white">visible</td>
                    </tr>
                    <tr>
                        <td>From non child class of same package</td>
                        <td class="bg-danger text-white">not visible</td>
                        <td class="bg-success text-white">visible</td>
                        <td class="bg-success text-white">visible</td>
                        <td class="bg-success text-white">visible</td>
                    </tr>
                    <tr>
                        <td>From child class of outside package</td>
                        <td class="bg-danger text-white">not visible</td>
                        <td class="bg-danger text-white">not visible</td>
                        <td class="bg-success text-white">visible(we should use child reference only)</td>
                        <td class="bg-success text-white">visible</td>
                    </tr>
                    <tr>
                        <td>From non-child class of outside package</td>
                        <td class="bg-danger text-white">not visible</td>
                        <td class="bg-danger text-white">not visible</td>
                        <td class="bg-danger text-white">not visible</td>
                        <td class="bg-success text-white">visible</td>
                    </tr>
                </tbody>
        </table>

        <mark>The most restricted modifier is private</mark>
        <br>
        <mark>The most accessible modifier is public</mark>

        <p>private < default < protected < public</p>

        <p>Recommended modifier for data member(variable) is private but recommended modifier for methods is public</p>
 

    <h5>final variables</h5>
    <h6>final instance variables</h6>
    <p>1. If the value of a variable is varied from object to object, such type of variables are called instance variables</p>
    <p>2. For every object a separate copy of instance variables will be created</p>
    <p>3. For instance variables we are not required to perform initialization explicitly. JVM will always provide default values</p>
    <pre><code>
        class Test {
            int x;
            public static void main(String[] args) {
                Test t = new Test();
                SOP(t.x);
            }
        } 
    </code></pre>
    
    <pre><output>
        0
    </output></pre>

    <p>4. If the instance variable declared as final then compulsory we have to perform initialization explicitly whether we are using or not
        and JVM wont provide default values.
    </p>
    <pre><code>
        class Test {
            final int x;
        }
    </code></pre>
    
    <pre><output>
        CE: variable x might not have been initialized
    </output></pre>

    <h6>Rule</h6>
    <p>For final instance variables compulsory we should perform initialization before constructor completion i.e the following are various places for initialization</p>
    <h6>At the time of declaration : </h6>
    <pre><code>
        class Test {
            final int x = 10;
        }
    </code></pre>

    <h6>Inside instance block : </h6>
    <pre><code>
        class Test {
            final int x;
            {
                x = 10;
            }
        }
    </code></pre>

    <p>Instance block gets executed before constructor</p>
    <h6>Inside constructor : </h6>
    <pre><code>
        class Test {
            final int x;
            Test() {
                x = 10;
            }
        }
    </code></pre>

    <p>These are the only possible places to perform initialization for final variables, if we are trying to perform
        initialization anywhere else then we will get CE</p>

        <pre><code>
            class Test {
                final int x;
                public void m1() {
                    x = 10;
                }
            }
        </code></pre>
        
        <pre><output>
            CE error: cannot assign a value to final variable x
        </output></pre>

    <h6>final static variables</h6>
     <p>If the value of a variable is not varied from object to object such type of variables are not recommended to declare as 
         instance variables. We have to declare those variables at class level by using static modifier</p>

    <p>In the case of instance variables a separate copy will be created but in the case of static variables a single copy will be created at class level and 
        shared by every object of that class</p>
    <p>For static variables it is not required to perform initialization explicitly. JVM will always provide default values</p>

    <pre><code>
        class Test {
            static int x;
            public static void main(String[] args) {
                SOP(x);
            }
        } 
    </code></pre>
    
    <pre><output>
        0
    </output></pre>

    <p>4. If the static variable declared as final then compulsory we have to perform initialization explicitly whether we are using or not o/w we will get compile time error
        and JVM wont provide default values.
    </p>

    <pre><code>
        class Test {
            final static int x;
        } 
    </code></pre>
    
    <pre><output>
        CE: variable x might not have been initialized
    </output></pre>

    <h6>Rule</h6>
    <p>For final static variables compulsory we should perform initialization before class loading completion i.e the following are various places for initialization</p>
    <h6>At the time of declaration</h6>
    <pre><code>
        class Test {
            final static int x = 10;
        }
    </code></pre>
    
    <h6>Inside static block</h6>
    <pre><code>
        class Test {
            final static int x;
            static {
                x = 10;
            }
        } 
    </code></pre>

    <p>These are the only possible places to perform initialization for final static variables. If we are trying to perform initialization anywhere else
        then we will get compile time error
    </p>

    <pre><code>
        class Test {
            final static int x;
            public void m1() {
                x = 10;
            }
        } 
    </code></pre>
    
    <pre><output>
        CE: error: cannot assign a value to final variable x
    </output></pre>

    <h6>final local variables</h6>
    <p>Sometimes to meet temporary requirements of the programmer we can declare variables inside a method or block or constructor such type of 
        variables are called local variables or temporary variables or automatic variables or stack variables</p>

    <p>For local variables jvm wont provide default values compulsory we should perform initialization explicitly before using that variable 
        i.e if we are not using then it is not required to perform initialization</p>
    
        <pre><code>
            class Test {
                p s v m(String[] args) {
                  int x;
                  SOP("Hello");
                }
              }
        </code></pre>
        
        <pre><output>
            Hello
        </output></pre>

        <pre><code>
            class Test {
                p s v m(String[] args) {
                  int x;
                  SOP(x);
                }
              }
        </code></pre>
        
        <pre><output>
            CE: variable x might not have been initialized
        </output></pre>

        <pre><code>
            class Test {
                p s v m(String[] args) {
                  final int x;
                  SOP("Hello");
                }
              }
        </code></pre>
        
        <pre><output>
            Hello
        </output></pre>

        <p>Even though local variables is final, before using only we have to perform initialization
            i.e if we are not using then it is not required to perform initialization even though it is final</p>

        <p>The only applicable modifier for local variables is final. By mistake if we are trying to apply any other modifier then we will get compile time error</p>

        <pre><code>
            class Test {
                p s v m(String[] args) {
                  public int x = 10;
                  private int x = 10;
                  protected int x = 10;
                  static int x = 10;
                  transient x = 10;
                  volatile x = 10;
                  final int x = 10;
                }
              }
        </code></pre>
        
        <pre><output>
            CE: Illegal start of expression
        </output></pre>
        <img src="images/ss4.png" alt="ss12" width="700" height="400">
   
    <p>If we are not declaring with any modifier then by default it is default but this rule is applicable only for instance and static variables but not for local variables</p>
   
    <p>Formal parameters of a method simply acts as local variables of that method hence formal parameter can be declared as fianl</p>
    <p>If formal parameter declared as final then within a method we cant perform reassignment</p>
    
    <pre><code>
    class Test {
        p s v m(String[] args) {
          m1(10, 20);
        }
        public static void m1(final int x, int y) {
            x = 100;
            y = 200;
            SOP(x + "    " + y);
        }
    }
    </code></pre>
    
    <pre><output>
        CE: cannot assign a value to final variable x
    </output></pre>

    <h1>8. static modifier</h1>
    <h5>static modifiers</h5>
    <p>Static is a modifier applicable for methods and variables but not for classes</p>
    <p>We cant declare top level class with static modifier but we can declare inner class as static(such type of inner classes are called
        static inner classes)</p>

    <p>In the case of instance variables for every object a separate copy will be created but in the case of static variable
        a single copy will be created at class level and shared by every object of that class</p>

        <pre><code>
            class Test {
                static int x = 10;
                int y = 20;
                p s v m (String[] args) {
                  Test t1 = new Test();
                  t1.x = 888;
                  t1.y = 999;
                  Test t2 = new Test();
                  SOP(t2.x + " " + t2.y);
                }
              }
        </code></pre>
        
        <pre><output>
            888 20
        </output></pre>

        <p>We cant access instance members directly from static area but we can access from instance area directly</p>
        <p>We can access static members from both instance and static areas directly</p>

        <div class="container">
            <p class="bg-warning text-white">Consider the following Declarations</p>
            <pre><code>
                1. int x = 10;
                2. static int x = 10;
                3. public void m1() {
                    SOP(x);
                }
                4. public static void m1() {
                    SOP(x);
                }
            </code></pre>
            <p>Which of the 4 options we can take simultaneously</p>
            <pre><output>
                a) 1 & 3
                b) 1 & 4
                c) 2 & 3
                d) 2 & 4
                e) 1 & 2
                f) 3 & 4
            </output></pre>
            <pre><output>
                1. valid
                2. CE: non-static variable x cannot be referenced from a static context
                3. valid
                4. valid 
                5. CE: variable x is already defined in Test
                6. CE: m1() is already defined in Test
            </output></pre>
            
        </div>

        <p>Overloading concept applicable for static methods including main method but JVM can always call String[] argument main method only</p>

        <pre><code>
            class Test {
                public static void main(String[] args) {
                  SOP("String[]");
                }
                public static void main(int[] args)  {
                  SOP("int[]");
                }
              }
        </code></pre>
        
        <pre><output>
            String[]
        </output></pre>

        <p>Other overloaded method we have to call just like a normal method</p>

        <p>Inheritance concept applicable for static methods including main method hence while executing child class if child doesn't 
            contain main method then parent class main method will be executed.</p>

            <pre><code>
                class P {
                    public static void main(String[] args) {
                      SOP("Parent main");
                    }
                  }
                  class C extends P {
                
                  }
            </code></pre>
            
            <pre><output>
                javac P.java
                java P
                Parent main
                java C
                Parent main
            </output></pre>

            <p>It seems overriding concept applicable for static methods but it is not overriding and it is method hiding</p>
        
            <pre><code>
                class P {
                    public static void main(String[] args) {
                      SOP("Parent main");
                    }
                  }
                  class C extends P {
                    public static void main(String[] args) {
                      SOP("child main");
                    }
                  }
            </code></pre>
            
            <pre><output>
                javac P.java
                java P
                Parent main
                java C
                Child main
            </output></pre>

    <mark>Note: For static methods inheritance and overloading concepts are applicable but overriding concept is not applicable. But instead of overriding, method hiding is applicable</mark>
   
    <p>Inside method implementation if we are using atleast one Instance variable then that method talks about a particular object. Hence we should declare method
        as instance method</p>

    <p>Inside method implementation if we are not using any instance variable then this method is no where related to a 
        particular object. Hence we have to declare such type of method as static method irrespective of whether we are using
        static variables or not</p>

        <pre><code>
            public class Student {
                private int rollno;
                private String name;
                private int marks;
                private static String cname;
                
                //We are using instance variable so declare as instance method
                public String getStudentInfo() {
                    return name + "    " + marks;
                }
                
                //We are not using any instance variables so declare as static
                public static String getCollegeInfo() {
                    return cname;
                }

                //We are not using any instance variables so declare as static
                public static double getAverage(int x, int y) {
                    return x + y / 2;
                }

                //We are using instance variable so declare as instance method
                public String getCompleteInfo() {
                    return name + "  " + rollno + "  " + marks + "  " + cname;
                }
            }
        </code></pre>

        <p>For static methods implementation should be available whereas for abstract methods implementation is not available.
            Hence abstract static combination is illegal for methods</p>

        <h1>9. synchronized modifier</h1>
        <h5>synchronized modifier</h5> 
        <p>synchronized is a modifier applicable for methods and blocks but not for classes and variables</p>
        
        <p>If multiple threads trying to operate simultaneously on the same java object then there may be a chance of data inconsistency problem.
            This is called race condition. We can overcome this problem by using synchronized keyword</p>

        <p>If a method or block declared as synchronized then at atime only one thread is allowed to execute that method or block or the given object
            so that data inconsistency problem will be resolved</p>
        <p>But the main disadvantage of the synchronized keyword is it increases waiting time of threads and creates performance problem.
            Hence if there is no specific requirement then it is not recommended to use synchronized keyword</p>

        <p>synchronized method should compulsory contain implementation whereas abstract method doesnt conatin any implementation. Hence abstract synchronized
            is illegal combination of modifiers for methods
        </p>

    <h1>10. native modifier</h1>
    <h5>native modifier</h5>
    <p>native is a modifier applicable only for methods and we cant apply anywhere else</p>
    <p>The methods which are implemented in non-java mostly C or C++ are called native methods or foreign methods</p>

    <p>The main objectives of the native keyword are</p>
    <p>1. To improve performance of the system</p>
    <p>2. To achieve machine level or memory level communication</p>
    <p>3. To use already existing legacy non-java code</p>
    
    <h6>psuedocode to use native keyword in java</h6>
    <pre><code>
        class Native {
            static {
                //load native libraries
                System.loadLibrary("native library path");
            }
            //declare a native method
            public native void m1();
        }
        class Client {
            public static void main(String[] args) {
                Native n = new Native();
                //invoke a native method
                n.m1();
            }
        }
    </code></pre>
    
    <p>4. For native methods implementation is already available in old languages like C or C++ and we are not
        responsible to provide implementation. Hence native method declaration should ends with semicolon</p>

        <pre><code>
            public native void m1();
            public native void m1() {}
        </code></pre>

        
<pre><output>
    CE: native methods cant have a body
</output></pre>

<p>5. For native methods implementation is already available in old languages but for abstract methods implementation should not
    be available. Hence we cant declare native method as abstract i.e native abstract combination is illegal combination for methods</p>

<p>6. We cant declare native methods as strictfp because there is no guarantee that old languages follow IEEE754 standard. Hence native strictfp is
    illegal combination for methods</p>

<p>7. The main advantage of native keyword is performance will be improved. But main disadvantage of native keyword is it breaks platform independent 
    nature of java</p>
     
<h1>11. transient keyword</h1>
<h5>transient keyword</h5>
<p>transient is a modifier applicable only for variables. We can use transient keyword in serialization context</p>
<p>At the time of serialization if we dont want to save the value of a particular variables to meet security constraint then we should declare that variables as transient</p>
<p>At the time of serialization JVM ignores original value of transient variables and save default value to the file. Hence transient means not to serialize</p>
<img src="images/ss20.png" alt="ss12" width="600" height="600">

<h1>12. volatile modifier</h1>
<h5>volatile modifier</h5>
<p>1. volatile is a modifier applicable only for variables and we cant apply anywhere else</p>
<p>2. If the value of a variable keep on changing by multiple threads then there may be a chance of data inconsistency problem. We can solve this problem by using volatile modifier</p>
<p>3. If a variable declared as volatile then for every thread JVM will create a separate local copy. Every modification performed by the thread will takes place in local copy.
    So that there is no effect on remaining threads</p>
<p>4. The main advantage of volatile keyword is we can overcome data inconsistency problem but the main disadvantage of volatile keyword is creating and maintaining a separate copy
    for every thread increases complexity of programming and creates performance problems. Hence if there is no specific requirement then it is never recommended to use volatile keyword 
    and it is almost depricated keyword</p>
<p>5. Final variables means the value never changes whereas volatile variable means the value keep on changing. Hence volatile final is illegal combination for variables</p>

<table class="table table-striped table-bordered">
    <thead class="thead-dark">
        <tr>
            <th>modifier</th>
            <th colspan="2" style="text-align: center;">classes</th>
            <th>methods</th>
            <th>variables</th>
            <th>blocks</th>
            <th colspan="2" style="text-align: center;">interfaces</th>
            <th colspan="2" style="text-align: center;">enum</th>
            <th>constructors</th>
        </tr>
        <tr>
            <th></th>
            <th style="text-align: center;">outer</th>
            <th style="text-align: center;">inner</th>
            <th></th>
            <th></th>
            <th></th>
            <th style="text-align: center;">outer</th>
            <th style="text-align: center;">inner</th>
            <th style="text-align: center;">outer</th>
            <th style="text-align: center;">inner</th>
            <th></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>public</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
        </tr>
        <tr>
            <td>private</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10004</td>
        </tr> 
        <tr>
            <td>protected</td>
            <td>&#10060</span></td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10004</td>
        </tr> 
        <tr>
            <td>&ltdefault></td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
        </tr> 
        <tr>
            <td>final</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
        </tr> 
        <tr>
            <td>abstract</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
        </tr> 
        <tr>
            <td>static</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10060</td>
        </tr> 
        <tr>
            <td>synchronized</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
        </tr> 
        <tr>
            <td>native</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
        </tr> 
        <tr>
            <td>strictfp</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10004</td>
            <td>&#10060</td>
        </tr> 
        <tr>
            <td>transient</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
        </tr> 
        <tr>
            <td>volatile</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10004</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
            <td>&#10060</td>
        </tr> 
    </tbody>
</table>

<p>1. The only applicable modifier for local variable is final</p>
<p>2. The only applicable modifiers for constructor are public, private, protected and default</p>
<p>3. The modifiers which are applicable only for methods are native</p>
<p>4. The modifiers which are applicable only for variables are volatile and transient</p>
<p>5. The modifiers which are applicable for classes but not for interfaces are final</p>
<p>6. The modifiers which are applicable for classes but not for enum are final and abstract</p>




    
<h3>4. Interfaces</h3>
<h5>1. Introduction</h5>
<h5>2. Interface declaration and implementation</h5>
<h5>3. extends vs implements</h5>
<h5>4. interface methods</h5>
<h5>5. interface variables</h5>
<h5>6. interface naming conflicts</h5>
<h6>1. methods naming conflicts</h6>
<h6>2. variable naming conflicts</h6>
<h5>7. marker interface</h5>
<h5>8. Adapter classes</h5>
<h5>interface vs abstract class vs concrete class</h5>
<h5>Difference between interfaces and abstract class</h5>
<h5>Conclusions</h5>

<h5>1. Introduction</h5>
<p>Definition 1: Any service requirement specification(SRS) is considered as an interface</p>
<p>Example 1: JDBC API acts as requirement specification to develop database driver. Database vendor is responsible to implement JDBC API</p>
<img src="images/ss21.png" alt="ss12" width="500" height="500">

<p>SUN people responsible to define JDBC API. Database vendor is responsible to implement database to develop their own driver classes</p>

<p>Example 2: Servlet API acts as requirement specification to develop web server. Web server vendor is responsible to implement servlet API</p>
<img src="images/ss22.png" alt="ss12" width="500" height="500">

<p>Definition 2: From client point of view an interface defines the set of services what he is expecting</p>
<p>From service provider point of view an interface defines the set of services what he is offering.</p>
<p>Hence any contract between client and service provider is considered as an interface</p>

<p>Example</p>
<p>Through bank ATM GUI screen bank people are highlighting the set of services what they are offering, at the same time the same GUI screen represents 
    the set of services what customer is expecting. Hence this GUI screen acts as contract between customer and bank people</p>

    <img src="images/ss23.png" alt="ss12" width="500" height="500">

<p>Definition 3: Inside interface every method is always abstract whether we are declaring or not hence interface is considered as 100% pure abstract class</p>

<p>Summary Definition : Any service requirement specification or any contract between client and service provider or 100% pure abstract class
    is nothing but interface</p>

<h5>2. Interface declaration and implementation</h5>
<pre><code>
    interface Interf {
        void m1();
        void m2();
    }
    class ServiceProvider implements Interf {
        void m1() {
        
        }
    }
</code></pre>

<pre><output>
    CE error: ServiceProvider is not abstract and does not override abstract
     method m2() in Interf
    error: m1() in ServiceProvider cannot implement m1() in Interf
        void m1() {
             ^
  attempting to assign weaker access privileges; was public
2 errors
</output></pre>

<pre><code>
    interface Interf {
        void m1();
        void m2();
    }
    class ServiceProvider implements Interf {
        public void m1() {
        
        }
    }
</code></pre>

<pre><output>
    CE error:  error: ServiceProvider is not abstract and does not override
     abstract method m2() in Interf
</output></pre>

<pre><code>
    interface Interf {
        void m1();
        void m2();
    }
    abstract class ServiceProvider implements Interf {
        public void m1() {
        
        }
    }
</code></pre>

<pre><output>
    compiling fine
</output></pre>

<pre><code>
    interface Interf {
        void m1();
        void m2();
    }
    <span style="color: red;">abstract</span> class ServiceProvider <span style="color: red;">implements</span> Interf {
        <span style="color: red;">public</span> void m1() {
        
        }
    }
    class SubServiceProvider <span style="color: red;">extends</span> ServiceProvider  {
        <span style="color: red;">public</span> void m2() {

        }
    }
</code></pre>

<pre><output>
    compiling fine
</output></pre>

<p>1. Whenever we are implementing an interface, for each and evry method of that interface we have to provide implementation o/w 
    we have to declare class as abstract then next level child class is responsible to provide implementation
</p>
<p>2. Every interface method is always public and abstract whether we are declaring or not . Hence whenever we are implementing an interface method
    compulsory we should declare as public o/w we will get compile time error</p> 
 
    <h5>3. extends vs implements</h5>
    <p>1. A class can extend only one class at a time</p>
    <p>2. An interface can extend any number of interface simultaneously</p>
    <pre><code>
        interface A {

        }
        interface B {

        }
        interface C extends A, B {

        }
    </code></pre>
    <p>3. A class can implement any number of interfaces simultaneously</p>
    <p>4. A class can extend another class and can implement any number of interfaces simultaneously</p>
    <pre><code>
        class A extends B implements c, D, E {

        }
    </code></pre>

    <div class="container">
        <p class="bg-warning text-white">Which of the following is valid?</p>
        
        <pre><code>
        <p>1. A class can extend any number of classes at a time.</p>
        <p>2. A class can implement only one interface at a time</p>
        <p>3. An interface can extend only one interface at a time</p>
        <p>4. An interface can implement any number of interfaces simultaneously</p>
        <p>5. A class can extend another class or can implement an interface 
            but not both simultaneously</p>
        <p>6. None of the above</p>
        </code></pre>
        
        <pre><output>
            None of the above
        </output></pre>
    </div>

    <div class="container">
        <p class="bg-warning text-white">Consider the following expression <span class="bg-primary text-white">X extends Y</span>. For which of the
            following possibilities of X and Y the above expression is valid? 
            <pre><code>
                1. Both X and Y should be classes
                2. Both X and Y should be interfaces
                3. Both X and Y can be either classes or interfaces
                4. No restrictions
            </code></pre>
            
            <pre><output>
                Both X and Y can be either classes or interfaces
            </output></pre>
        </p>
    </div>

    <pre><code>
        X extends Y, Z
    </code></pre>
    
    <pre><output>
        X, Y, z should be interfaces
    </output></pre>

    <pre><code> 
        X implements Y, Z
    </code></pre>
    
    <pre><output>
        X should be class and Y, Z should be interfaces
    </output></pre>

    <pre><code>
        X extends Y implements Z
    </code></pre>
    
    <pre><output>
        X should be class and Y should be class and Z should be interface
    </output></pre>

    <pre><code>
        X implements Y extends z
    </code></pre>
    
    <pre><output>
        CE: because we have to take extends first followed by interface
    </output></pre>

    <h5>4. interface methods</h5>
    <p>1. Every method present inside interface is always public and abstract whether we are declaring or not</p>
    <pre><code>
        interface Interf {
            void m1();
        }
    </code></pre>

    <p>2. Why interface methods is always public?<br> To make that method available
        to every implementation class</p>
    <p>3. Why interface methods is always abstract?<br> Implementation class is responsible to provide implementation</p>

    <p>Hence inside interface the following method Declarations are equal</p>
    <pre><code>
        void m1();
        public void m1();
        abstract void m1();
        public abstract void m1();
    </code></pre>

    <p>4. As every interface method is always public and abstract we cant declare interface method with the following modifiers</p>
    <img src="images/ss24.png" alt="ss12" width="400" height="600"><br><br><br>

    <div class="container">
        <p class="bg-warning text-white">Which of the following method declarations are allowed inside interface</p>
            <pre><code>
                public void m1() {}
                private void m1();
                protected void m1();
                static void m1();
                public abstract native void m1();
                abstract public void m1();
            </code></pre>
            
            <pre><output>
                not allowed
                not allowed
                not allowed
                not allowed
                not allowed
                allowed
            </output></pre>    
    </div>


    <h5>5. interface variables</h5>
    
    <p>1. An interface can contain variables, the main purpose of interface variable is to define requirement level constants</p>
    <p>Every interface variable is always public, static, final whether we are declaring or not</p>
    <pre><code>
        interface Interf {
            int x = 10;
        }
    </code></pre>
    
    <p>Why interface variables is always public?<br>To make this variable available to every implementation class</p>
    <p>Why interface variables is always static?<br>We cant create object of interfce. Without existing object also, implementation class
        has to access this variable</p>
    <p>Why interface variable is always final?<br>If one implementation class changes value then remaining implementation classes will be affected.
        To restrict this every interface variable is always final.</p>
    
    <p>Hence within the interface the following variable declarations are equal</p>
    <pre><code>
        int x = 10;
        public int x = 10;
        static int x = 10;
        final int x = 10;
        public static int x = 10;
        public final int x = 10;
        static final int x = 10;
        public static final int x = 10;
    </code></pre>

    <p>As every interface variable is always public static final we cant declare with the following modifiers</p>
    <img src="images/ss25.png" alt="ss12" width="400" height="600">

    <p>For interface it is not possible to create object. If the object is not there serialization concept is not there. serialization
        means saving state of an object. Object itself is not there, serialization is not there. If serialization not there then there is no requirement 
        of transient keyword</p>
    </p>

    <p>For interface variables compulsory we should perform initialization at the time of declaration o/w we will get compile time error</p>
    <pre><code>
        interface Interf { 
            int x;
        }
    </code></pre>
    
    <pre><output>
        CE: = expected
    </output></pre>

    <div class="container">
        <p class="bg-warning text-white">Inside interface which of the following declarations are allowed</p>
        <pre><code>
            int x;
            private int x = 10;
            protected int x = 10;
            volatile int x = 10;
            transient int x = 10;
            public static int x =10;
        </code></pre>
        
        <pre><output>
            not allowed
            not allowed
            not allowed
            not allowed
            not allowed
            allowed
        </output></pre>
    </div>

    <p>Inside implementation class we can access interface variables but we cant modify values</p>
    <pre><code>
        interface Interf {
            int x = 10;
        }        
        class Test implements Interf{

            public static void main(String[] args) {
                x = 777;
                System.out.println(x);
            }
        }
        
    </code></pre>
    
    <pre><output>
        CE: cant assign a value to final variable x
    </output></pre>

    <pre><code>
        interface Interf {
            int x = 10;
        }        
        class Test implements Interf{

            public static void main(String[] args) {
                int x = 777;
                System.out.println(x);
            }
        }
    </code></pre>
    
    <pre><output>
        777
    </output></pre>

    <h5>6. interface naming conflicts</h5>

    <h6>1. methods naming conflicts</h6>
    <p>case 1: If two interface conatins a method with same signature and same return type then in the implementation class we have to provide
        implementation for only one method</p>
        <pre><code>
            interface Left {
                public void m1();
            }
            interface Right {
                public void m1();
            }
            class Test implements Left, Right {
                public void m1() {

                }
            }
        </code></pre>
        
    <p>case 2: If two interfaces contains a method with same name but different arguments types then in the implementation class
        we have to provide implementation for both methods and these methods acts as overloaded methods</p>
    
        <pre><code>
            interface Left {
                public void m1();
            }
            interface Right {
                public void m1(int i);
            }
            class Test implements Left, Right {
                public void m1() {

                }
                public void m1(int i) {

                }
            }
        </code></pre> 

    <p>case 3: If two interfaces contains a method with same signature but different return types then it is impossible to implement
        both interfaces simultaneously(if return types are not co-varient)</p>
        <pre><code>
            interface Left {
                public void m1();
            }
            interface Right {
                public int m1();
            }
            class Test implements Left, Right {
                public void m1() {

                }
                public int m1() {

                }
            }
        </code></pre> 
        <pre><output>
            We cant write any java class which implements both interfaces  
        </output></pre>

        <div class="container">
            <p class="bg-warning text-white">Is a java class can implement any number of interfaces simultaneously.</p>
            <p>Yes. Except a particular case. If two interfaces contains a method with same signature but different return types then it is
                impossible to implement both interfaces simultaneously</p>
        </div>

    
    <h6>2. variable naming conflicts</h6>
    <p>Two interfaces can contain a variable with the same name and there may be a chance of variable naming conflicts but we can 
        solve this problem by using interface names</p>
    <pre><code>
        interface Left {
            int x = 777;
        }
        interface Right {
            int x = 888;
        }
        class Test implements Left, Right {
            public static void main(String[] args) {
                <span style="color: red;">//SOP(x); //CE: reference to x is ambiguous</span>
                SOP(Left.x);
                SOP(Right.x);
            }
        }
    </code></pre> 
    <pre><output>
        777
        888  
    </output></pre>

    <h5>7. marker interface</h5>
    <p>If an interfaec doent contain any methods and by implementing that interface if our objects will get some ability, such type of interfaces are called 
        marker interfaces or ability interface or tag interface</p>
    <p>Example:</p>
    <pre><code>
        Serializable(I)
        Clonable(I)
        RandomAccess(I)
        SingleThreadModel(I)
            .
            .
            .
            .
    </code></pre>
    <p>These are marked for some ability</p>

    <p>Example 1: By implementing Serializable interface our objects can be saved to the file and can 
        travel across a network.</p>
    <p>Example 2: By implementing Clonable interface our objects are in a position to produce exactly duplicate cloned objects</p>

    <div class="container">
        <p class="bg-warning text-white">Without having any methods how the objects will get some ability in marker interfaces</p>
        <p>Internally JVM is responsible to provide required ability.</p>
    </div>
    <div class="container">
        <p class="bg-warning text-white">Why JVM is providing required ability in marker interfaces</p>
        <p>To reduce complexity of programming and to make java language as simple.</p>
    </div>
    <div class="container">
        <p class="bg-warning text-white">Is it possible to create our own marker interfaces?</p>
        <p>Yes. But customization of JVM is required.</p>
    </div>




    <h5>8. Adapter classes</h5>
    <p>1. Adapter class is a simple java class that implements an interface with only empty implementation</p>
    <p>If we implement an interface, for each and every method of that interface compulsory we should provide implementation 
        whether it is required or not
    </p>
    <pre><code>
        public interface Interf {
            void m1();
            void m2();
            void m3();
            void m4();
            void m5();
            void m6();
            void m7();
            void m8();
            void m9();
        }
        class Test implements Interf {

            @Override
            public void m1() {
            
            }
            @Override
            public void m2() {
                
            }
            @Override
            public void m3() {
                
            }
            @Override
            public void m4() {
                
            }
            @Override
            public void m5() {
                
            }
            @Override
            public void m6() {
                
            }
            @Override
            public void m7() {
                
            }        
            @Override
            public void m8() {

            }
            @Override
            public void m9() {
                
            }
        }
        
    </code></pre>
    <p>The problem in this approach is it increases length of the code and reduces readibility. We can solve this problem by 
        using adapter classes. Instead of implementing interface if we extend adapter class we have to provide implementation only for required 
        methods and we are not responsible to provide implementation for each and every method of the interface so that length of the code will be reduced</p>
    </p>

    <pre><code>
        public interface Interf {
            void m1();
            void m2();
            void m3();
            void m4();
            void m5();
            void m6();
            void m7();
            void m8();
            void m9();
        } 
        <span style="color: red;">abstract</span> public class AdapterInterf implements Interf {
            @Override
            public void m1() {
            
            }
            @Override
            public void m2() {
                
            }
            @Override
            public void m3() {
                
            }
            @Override
            public void m4() {
                
            }
            @Override
            public void m5() {
                
            }
            @Override
            public void m6() {
                
            }
            @Override
            public void m7() {
                
            }        
            @Override
            public void m8() {

            }
            @Override
            public void m9() {
                
            }
        }     
        public class Test extends AdapterInterf {
	
            public void m5() {
        
            }
        
        }          
        public class Sample extends AdapterInterf {

            public void m1() {
        
            }
        }
        public class Demo extends AdapterInterf{

            public void m7() {
        
            }
        }                
    </code></pre>
    <img src="images/ss26.png" alt="ss12" width="400" height="600">

    <p>We can develop a servlet in the following 3 ways</p>
    <p>1. By implementing Servelt(I)
    <p>2. By extending GenericServlet(AI)
    <p>3. By extending HttpServlet(AI)</p>
    <img src="images/ss27.png" alt="ss12" width="400" height="600">

    <p>If we implement servlet interface for each and evry method of that interface we should provide implementation 
        It increases length of the code and reduces readibility.</p>
    <p>Instead of implementing servlet interface directly if we extend GenericServlet we have to provide implementation only 
        for service() method and for ALL remaining methods we are not required to provide implementation. Hence more or less GenericServlet acts 
        as Adapter class for Servlet(I) interface</p>

    <mark>Note: Marker interface and adapter classes simplifies complexity of programming and these are best utilites to the 
        programmer and programmer life will become simple.
    </mark>

    <h5>interface vs abstract class vs concrete class</h5>
    <p>1. If we dont know anything about implementation just we have requirement specification then we should go for interface</p>
    <p>Example : Servlet(I)</p>

    <p>2. If we are talking about implementation but not completely(partial implementation) then we should go for abstract class</p>
    <p>Example : GenericServlet, HttpServlet</p>

    <p>3. If we are talking about implementation completely and ready to provide service then we should go for concrete class</p>
    <p>Example : myOwnServlet</p>

    <img src="images/ss28.png" alt="ss12" width="600" height="700">


    <h5>Difference between interfaces and abstract class</h5>
    <table class="table table-striped">
        <thead class="thead-dark">
            <tr>
                <th>interface</th>
                <th>Abstract class</th>
            </tr>
        </thead> 
        <tbody>
            <tr>
                <td>If we dont know anything about implementation and just we have requirement specification then we should go for interface</td>
                <td>If we are talking about implementation but not completely(partial implementation) then we should go for abstract class</td>
            </tr> 
            <tr>
                <td>Inside interface every method is always public and abstract whether we are declaring or not. Hence interface is considered as 100% pure 
                    abstract class.
                </td>
                <td>Every method present inside abstract class need not be public and abstract and we can take concrete mthods also.</td>
            </tr>
            <tr>
                <td>As every interface method is always public and abstract and hence we cant declare with the following modifiers(private, protected 
                    final, static, synchronized, native and strictfp)</td>
                <td>There are no restrictions on abstract class modifiers</td>
            </tr>
            <tr>
                <td>Every variables present inside interface is always public static final whether we are declaring or not</td>
                <td>Every variable present inside abstract class need not be public static final</td>
            </tr>
            <tr>
                <td>AS every interface variables is always public static final we cant declare with the following modifiers(private protected volatile and transient)</td>
                <td>There are no restrictions on abstract class variables modifiers</td>
            </tr>
            <tr>
                <td>For interface variables compulsory we should perform initialization at the time of declaration only o/w we will get CE</td>
                <td>For abstract class variables we are not required to perform initialization at the time of declaration</td>
            </tr>
            <tr>
                <td>Inside interface we cant declare static and instance blocks</td>
                <td>Inside abstract class we can declare static and instance blocks</td>
            </tr>
            <tr>
                <td>Inside interface we cant declare constructors</td>
                <td>Inside abstract class we can declare constructors</td>
            </tr>
        </tbody>
</table>

<div class="container">
    <p class="bg-warning text-white">Anyway we cant create object for abstract class but abstract class can contain constructor. What is the need?</p>
    <p>Abstract class constructors will be executed whenever we are creating child class object to perform initialization of child class object</p>
</div>
<p>Approach 1 : Without having constructor in abstract class</p>
<pre><code>
    abstract class Person {
        String name;
        int age;
            .
            . 
            . 
            . 
            .(100 properties)
    }
    class Student extends Person {
        int rollno;
        Student(String name, int age, ......(101 properties)) {
            this.name = name;
            this.age = age;
                . 
                . 
                . 
                .(100 properties)
            this.rollno = rollno;
        }
    }
    Student s1 = new Student(101 properties);
    class Teacher extends Person {
        String subject;
        Teacher(String name, int age, ......(101 properties)) {
            this.name = name;
            this.age = age;
                . 
                . 
                . 
                .(100 properties)
            this.subject = subject;
        } 
    }
    Teacher t = new Teacher(101 properties);
                . 
                . 
                . 
                .(1000 child classes)
    (More code, code redundancy)
</code></pre>

<p>Approach 2: With constructor inside abstract class</p>
<pre><code>
    abstract class Person {
        String name;
        int age;
            .
            . 
            . 
            . 
            .(100 properties)
            //This constructor will work for every child object initialization
        Person(String name, int age.........(100 properties)) {
            this.name = name;
            this.age = age;
                . 
                . 
                . 
                .(100 properties)
        }
        
    }
    class Student extends Person {
        int rollno;
        Student(String name, int age, ......(101 properties)) {
            super(100 properties);
            this.rollno = rollno;
        }
    }
    Student s1 = new Student(101 properties);
    class Teacher extends Person {
        String subject;
        Teacher(String name, int age, ......(101 properties)) {
            super(100 properties);
            this.subject = subject;
        } 
    }
    Teacher t = new Teacher(101 properties);
                . 
                . 
                . 
                .(1000 child classes)

    (less code and code reusability)
</code></pre>

<mark> Note: 1. Either directly or indirectly we cant create object for abstract class</mark>
<br><br>
<div class="container">
    <p class="bg-warning text-white">Anyway we cant create objects for abstract class and interface but abstract class can contain constructor 
        but interface doesnt contain constructor. What is the reason?</p>
    <p>The main purpose of constructor is to perform initialization for the instance variables</p>
    <p>Abstract class can contain instance variables which are required for child object. To perform initialization of those instance variables
        constructor is required for abstract class</p>
    <p>But every variable present inside interface is public static final whether we are declaring or not and there is no chance of existing instance 
        variables inside interface. Hence constructor concept not required for interface
</div>

<p>Whenever we are creating child class object, parent object wont be created just parent class constructor will be executed for the child object 
    purpose only</p>

    <pre><code>
        class P {
            P() {
                System.out.println(this.hashCode() + " Inside Parent");
            }
        }
        class C extends P {
            C() {
                System.out.println(this.hashCode() + " Inside Child");
            }
        }
        public class Test {
            public static void main(String[] args) {
                C c = new C();
                System.out.println(c.hashCode() + " Inside Test");
            }
        }
    </code></pre>
    
<pre><output>
2055281021 Inside Parent
2055281021 Inside Child
2055281021 Inside Test
</output></pre>

<div class="container">
    <p class="bg-warning text-white">Inside interface every method is always abstract and we can take only abstract methods in abstract class also then what is the difference between interface and 
        abstract class? i.e Is it possible to replace interface with abstract class?</p>
    <p>We can replace interface with abstract class but it is not a good programming practice. This is something like recruiting IAS officer 
        for sweeping activity</p>
    <p>If everything is abstract then it is highly recommended to go for interface but not for abstract class</p>
</div>

<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>abstract class</th>
            <th>interface</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td><pre><code>
                abstract class X {

                }
            </code></pre>
            </td>
            <td>
                <pre><code>
                    interface X {

                    }
                </code></pre>
            </td>
        </tr> 
        <tr>
            <td><pre><code>
                class Test extends X {

                }
            </code></pre>
            While extending abstract class it is not possible to extend any other class and hence we are missing inheritance benefit
            </td>
            <td><pre><code>
                class Test implements X {

                }
            </code></pre>
            While implementing interface we can extend some other class and hence we wont miss any inheritance benefit.
            </td>
        </tr>
        <tr>
            <td><pre><code>
                Test t = new Test();(2 min)
            </code></pre>
            In this case object creation is costly 
            </td>
            <td><pre><code>
                Test t = new Test();(2 sec)
            </code></pre>
            In this case object creation is not costly 
            </td>
        </tr>  
    </tbody>
</table>

<h5>new and constructor</h5>
<p>The main objective of new operator is to create an object.</p> 
<p>The main purpose of constructor is to initialize object</p>
<p>First object will be created by using new operator with default value and then initialization will be performed by constructor</p>



    <h5>Conclusions</h5>


    <h1>Object Oriented Programming</h1>
    <h1>Module 1:</h1>
    <h5>1. Data hiding</h5>
    <p>Outside person cant access our internal data directly or our internal data should not go out directly. This OOP feature is nothing but data hiding</p>
    <p>After validation or authentication outside person can access our internal data</p>
    <p>Example 1: After providing proper username and password we can access our gmail information</p>
    <p>Example 2: Even though we are valid customer of the bank we can able to access our account information and we cant access others account information</p>
    <p>By declaring data member(variable) as private we can achieve data hiding</p>
    
    <pre><code>
        public class Account {
            private double balance;
            public double getBalance() {
                //validation
                return balance;
            }
        } 
    </code></pre>

    <p>The main advantage of data hiding is security</p>
    <p>Note : It is highly recommended to declare data member(variable) as private.</p>

    <h5>2. Abstraction</h5>
    <p>Hiding internal implementation and just highlight the set of services what we are offering is the concept of Abstraction</p>
    <p>Through bank ATM GUI screen bank people are highlighting the set of services what they are offering w/o highlighting internal implementation</p>

    <img src="images/ss23.png" alt="ss12" width="400" height="600">

    <p>The main advantages of Abstraction are </p>
    <p>1. We can achieve security because we are not highlighting our internal implementation</p>
    <p>2. Without effecting outside person we can able to perform any type of changes in our internal system and hence enhancement will become easy</p>
    <p>3. It improves maintainability of the application</p>
    <p>4. It improves easiness to use our system</p>

    <p>By using interfaces and abstract classes we can implement abstraction</p>

    <h5>3. Encapsulation</h5>
    <p>The process of binding data and corresponding methods into a single unit is nothing but encapsulation.</p>
    <p>Example : Capsule</p>
    <pre><code>
        class Student {
            data members

                +

            methods(behaviors)
        }
    </code></pre>

    <p>If any component follows data hiding and abstraction such type of component is said to be encapsulated component</p>
    <p class="bg-primary text-white">Encapsulation = Data hiding + Abstraction</p>

    <pre><code>
        public class Account {
            private double balance;
            public double getBalance() {
                //validation
                return balance;
            }
            public void setBalance() {
                //validation
                this.balance = balance;
            }
        }
    </code></pre>

    <p>Here how abstraction we are achieveing. Example of bank atm GUI screen there when we click balance enquiry we dont know what is happening internally 
        or what method is calling internally so abstraction is there.
    </p>

    <p>The main advantages of encapsulation are</p>
    <p>1. We can achieve security</p>
    <p>2. enhancement will become easy</p>
    <p>3. It improves maintainability of the application</p>

    <p>The main disadvantage of encapsulation is it increases length of the code and slows down execution</p>

    <h5>4. Tightly encapsulated class</h5>
    <p>A class is said to be tightly encapsulated iff each and every variable declared as private. Whether class contains corresponding getter and setter methods 
        are not and Whether these methods are declared as public or not. These things we are not required to check</p>

        <pre><code>
            public class Account {
                private double balance;
                public double getBalance() {}
                    return balance;
                }
            }
        </code></pre>

    
<div class="container">
    <p class="bg-warning text-white">Which of the following classes are tightly encapsulated</p>
    <p>Example 1: </p>
    <pre><code>
        class A {
            private int x = 10;
        }
        class B extends A {
            int y = 10;
        }
        class C extends A {
            private int z = 10;
        }
    </code></pre>
    <pre><output>
        A and C are tightly encapsulated
    </output></pre>
    <p>Example 2:</p>
    <pre><code>
        class A {
            int x =10;
        }
        class B extends A {
            private int y =20;
        }
        class C extends B {
            private int z = 30;
        }
    </code></pre>
    
    <pre><output>
        No one is tightly encapsulated
    </output></pre>

    <p>Conclusion : </p>
    <p>If the parent class is not tightly encapsulated then no child class is tightly encapsulated</p>
</div>

    <h5>5. Is-A relationship</h5>
    <p>1. It is also known as inheritance.</p>
    <p>2. The main advantage of Is-A relationship is code reusability</p>
    <p>3. By using extends keyword we can implement Is-A relationship</p>

    <pre><code>
        class P {
            public void m1() {
                SOP("Parent");
            }
        }
        class C extends P {
            public void m2() {
                SOP("Child");
            }
        }
        class Test {
            public static void main(String[] args) {
                P p = new P();
                p.m1();
                p.m2();
            }
        }
    </code></pre>
    
    <pre><output>
        CE: cant find symbol
        symbol : method m2()
        location : class P
    </output></pre>

    <pre><code>
        class P {
            public void m1() {
                SOP("Parent");
            }
        }
        class C extends P {
            public void m2() {
                SOP("Child");
            }
        }
        class Test {
            public static void main(String[] args) {
                C c = new C();
                c.m1();
                c.m2();
            }
        }
    </code></pre>
    
    <pre><output>
        Parent
        Child
    </output></pre>

    <pre><code>
        class P {
            public void m1() {
                SOP("Parent");
            }
        }
        class C extends P {
            public void m2() {
                SOP("Child");
            }
        }
        class Test {
            public static void main(String[] args) {
                P p = new C();
                p.m1();
                p.m2();
            }
        }
    </code></pre>
    
    <pre><output>
        CE: cant find symbol
        symbol : method m2()
        location : class P
    </output></pre>

    <pre><code>
        class P {
            public void m1() {
                SOP("Parent");
            }
        }
        class C extends P {
            public void m2() {
                SOP("Child");
            }
        }
        class Test {
            public static void main(String[] args) {
                C c = new P();
            }
        }
    </code></pre>
    
    <pre><output>
        CE: incompatible types
        found : P
        required : C
    </output></pre>

    <p>Conclusions : </p>
    <p>1. Whatever methods parent has by default available to the child and hence on the child reference we can call both parent and child class methods.</p>
    <p>2. Whatever methods child has by default not available to the parent and hence on the parent reference we cant call child specific methods</p>
    <p>3. Parent reference can be used to hold child object but by using that reference we cant call child specific methods but we can call the methods present in parent class.</p>
    <p>4. Parent reference can be used to hold child objects but child reference cant be used to hold parent object</p>

    <p>Note: The most common methods which are applicable for any type of child, we have to define in parent class. The specific methods which are applicable for a particular child we have to define in child class</p>
    <p>Total java API is implemented based on inheritance concept.</p>
    <p>The most common methods which are applicable for any java object are defined in object class and hence every class in java is the child class of object either directly or indirectly so that object class methods by default available to every java class w/o rewriting. 
        Due to this, object class acts as root for all java classes</p>

    <p>Throwable class defines the most common methods which are required for every exception and error classes. Hence this class acts as root for java exception heirarchy</p>

    <img src="images/ss29.png" alt="ss12" width="400" height="600">

    <h6>Multiple inheritance</h6>
    <p>A java class cant extend more than one class at a time hence java wont provide support for Multiple inheritance in classes.</p>
    <pre><code>
        class A extends B,C {

        }
    </code></pre>
    
    <pre><output>
        Compile time error
    </output></pre>    

    <p>Note : </p>
    <p>1.  If our class doesnt extend any other class then only our class is direct child class of Object</p>
    <img src="images/ss30.png" alt="ss12" width="300" height="300">
    <p>2. If our class extends any other class then our class is indirect child class of object</p>
    <img src="images/ss31.png" alt="ss12" width="400" height="400">

    <p>Note: Either directly or indirectly java wont provide support for multiple inheritance with respect to classes</p>
 
    <div class="container">
        <p class="bg-warning text-white">Why java wont provide support for multiple inheritance?</p>
        <p>There may be a chance of ambiguity problem hence java wont provide support for multiple inheritance.</p>
        <img src="images/ss32.png" alt="ss12" width="300" height="300">
    </div>

    <mark>But interface can extend any number of interfaces simultaneously hence java provide support for multiple inheritance with respect to interfaces.</mark>
    <pre><code>
        interface A {

        }
        interface B {

        }
        interface C extends A, B {

        }
    </code></pre>
    
    
<div class="container">
    <p class="bg-warning text-white">Why ambiguity problem wont be there in interfaces?</p>
    <p>Even though multiple method declarations are available but implementation is unique hence there is no chance of ambiguity problem in interfaces.</p>
    <img src="images/ss33.png" alt="ss12" width="400" height="400">    
</div>

<mark>Strictly speaking through interfaces we wont get any inheritance</mark>
<br><br>
<h6>Cyclic inheritance</h6>
<p>Cyclic inheritance is not allowed in java. Ofcourse it is not required</p>
<pre><code>
    class A extends A {

    }
</code></pre>

<pre><output>
    CE: cyclic inheritance involving A
</output></pre>

<img src="images/ss34.png" alt="ss12" width="200" height="200">

<pre><code>
    class A extends B {

    }
    class B extends A {

    }
</code></pre>

<pre><output>
    CE: cyclic inheritance 
</output></pre>

<img src="images/ss35.png" alt="ss12" width="200" height="200">

    <h5>6. Has-A relationship</h5>
    <p>1. Has-A relationship is also known as composition or aggregation</p>
    <p>2. There is no specific keyword to implement Has-A relation but most of the times we are depending on new keyword</p>
    <p>3. The main advantages of Has-A relationship is reusability of the code</p>

    <p>Example: </p>
    <pre><code>
        class Engine {
            //Engine specific functionality
        }
        class Car {
            Engine e = new Engine();
                . 
                . 
                . 
        }
    </code></pre>
    
    <pre><output>
        Car <span style="color: red;">Has-A</span> Engine reference
    </output></pre>

    
<div class="container">
    <p class="bg-warning text-white">Difference between composition & aggregation</p>
    <h6>Composition :</h6>
    <p>Without existing container object if there is no chance of contained objects then container and contained objects are strongly associated and this strong association i s 
        nothing but composition</p>
    <p>Example : </p>
    <p>University consists of several departments, without existing University there is no chance of existing department. Hence University and department are strongly associated 
        and this strong association is nothing but composition.</p>
        <img src="images/ss36.png" alt="ss12" width="400" height="600">
    <h6>Aggregation : </h6>
    <p>Without existing container object if there is a chance of existing contained objects then container and contained objects are weakly associated and this weak association is nothing 
        but aggregation</p>
    <p>Example : </p>
    <p>Department consists of several professors without existing department there may be a chance of existing professor objects hence department and professor objects are weakly associated and 
        this weak association is nothing but aggregation
    </p>   
    
    <img src="images/ss37.png" alt="ss12" width="400" height="600">
    <br><br>
    <mark>Note: 1. In composition objects are strongly associated whereas in aggregation objects are weakly associated.
        <br>2. In composition container object holds directly contained objects whereas in aggregation container object holds just references of contained objects</mark>
    </div>

    <h6> Is-A vs Has-A</h6>
    <p>If we want total functionality of a class automatically then we should go for Is-A relationship</p>
    <p>Example</p>
    <img src="images/ss38.png" alt="ss12" width="300" height="300">
    <p>If we want part of the functionality then we should go for Has-A relationship</p>
    <img src="images/ss39.png" alt="ss12" width="400" height="400">

    <h1>Module 2:</h1>
    <h5>7. Method Signature</h5>
    <p>In java  method Signature consist of method name followed by argument types.</p>
    <pre><code>
        public static int m1(int i, float f)

        Method signature will be --- m1(int i, float f)
    </code></pre>
    <p>Return type is not part of method signature in java</p>

    <p>Compiler will use method signature to resolve method calls</p>
    <pre><code>
        class Test {
            public void m1(int i) {

            }
            public void m2(String s) {

            }
        }
        Test t = new Test();
        t.m1(10);   
        t.m2("durga");
        t.m3(10.5);
    </code></pre>
    
    <pre><output>
        &#10004
        &#10004
        CE: cant find symbol, symbol : method m3(double), location : class Test
    </output></pre>

    <pre><code>
        class Test {
            public void m1(int i) {

            }
            public int m1(int x) {
                return 10;
            }
        }
        Test t = new Test();
        t.m1(10);
    </code></pre>

    <pre><output>
       CE: m1(int) is already defined in Test
    </output></pre>

    <p>Within a class two methods with the same signature not allowed</p>

    <h5>Overloading</h5>
    <p>Two methods are said to be overloaded iff both methods having same name but different argument types</p>
    <p>In C language method Overloading concept is not available hence we cant declare multiple methods with same name but different argument 
        types. If there is a change in argument type compulsory we should go for new method name which increases complexity of Programming</p>
        <pre><code>
            abs(int i)
            labs(long l)
            fabs(float f)
        </code></pre>
    <p>But in java we can declare multiple methods with the same name but different argument types such type of methods are called overloaded methods</p>
    <pre><code>
        abs(int i)
        abs(long l)
        abs(float f)
    </code></pre>
    <p>Having Overloading concept in java reduces complexity of Programming</p>
    <pre><code>
        class Test {
            public void m1() {
                SOP("no-arg");
            }
            public void m1(int i) {
                SOP("int-arg");
            }
            public void m1(double d) {
                SOP("double-arg");
            }
        }
        public static void main(String[] args) {
            Test t = new Test();
            t.m1();
            t.m1(10);
            t.m1(10.5);
        }
    </code></pre>

    <pre><output>
        no-arg
        int-arg
        double-arg
    </output></pre>

    <mark>In Overloading method resolution always takes care by compiler based on reference type hence Overloading is also considered as 
        compile time polymorphism or static polymorphism or early binding</mark>
    
    
    <h6>case 1:</h6>
    <h6>Automatic promotion in Overloading</h6>
    <p>While resolving overloaded methods if exact match method is not available then we wont get any CE immediately. 
        First it will promote argument to the next level and check Whether matched method is available or not. If matched method 
        is available then it will be considered and if the matched method is not available then compiler promotes argument once again to the next level. 
        This process will be continued until all possible promotions still if the matched method is not available then we will get CE. 
        The following are all possible promotions in Overloading
    </p>
    <img src="images/ss13.png" alt="ss12" width="400" height="600">
    <p>This process is called Automatic promotion in Overloading</p>

    <pre><code>
        class Test {
            public void m1(int i) {
                SOP("int-arg")
            }
            public void m1(float f) {
                SOP("float-arg")
            }
        }
        public static void main(String[] args) {
            Test t = new Test();
            t.m1(10);
            t.m1(10.5f);
            t.m1('a');
            t.m1(10l);
            t.m1(10.5);
        }
    </code></pre>

    <pre><output>
        int-arg
        float-arg 
        int-arg 
        float-arg
        CE: cannot find symbol, symbol method m1(double), location: class Test
    </output></pre>

    <h6>Case: 2</h6>
    <pre><code>
        class Test {
            public void m1(String s) {
                SOP("String version")
            }
            public void m1(Object o) {
                SOP("Object version")
            }
        }
        public static void main(String[] args) {
            Test t = new Test();
            t.m1(new Object());
            t.m1("durga");
            t.m1(null);
        }
    </code></pre>

    <pre><output>
        Object version
        String version 
        String version 
    </output></pre>

<mark>Note : While resolving overloaded methods compiler will always gives the precedence for child type argument then compared with parent type argument</mark>

<h6>Case: 3</h6>
<pre><code>
    class Test {
        public void m1(String s) {
            SOP("String version")
        }
        public void m1(StringBuffer sb) {
            SOP("StringBuffer version")
        }
    }
    public static void main(String[] args) {
        Test t = new Test();
        t.m1("durga");
        t.m1(new StringBuffer("durga"));
        t.m1(null);
    }
</code></pre>

<pre><output></output>
    String version 
    StringBuffer version 
    CE: reference to m1() is ambigous
</output></pre>

<h6>Case: 4</h6>
    <pre><code>
        class Test {
            public void m1(int i, float f) {
                SOP("int-float version")
            }
            public void m1(float f, int i) {
                SOP("float-int version")
            }
        }
        public static void main(String[] args) {
            Test t = new Test();
            t.m1(10, 10.5f);
            t.m1(10.5f, 10);
            t.m1(10, 10);
            t.m1(10.5f , 10.5f)
        }
    </code></pre>

    <pre><output>
        int-float version
        float-int version 
        CE: reference to m1() is ambigous 
        CE: cant find symbol, symbol: method m1(float, float), location: class Test
    </output></pre>

    <h6>Case: 5</h6>
    <pre><code>
        class Test {
            public void m1(int x) {
                SOP("General method")
            }
            public void m1(int... x) {
                SOP("var-arg method")
            }
        }
        public static void main(String[] args) {
            Test t = new Test();
            t.m1();
            t.m1(10, 20);
            t.m1(10);
        }
    </code></pre>

    <pre><output>
        var-arg method
        var-arg method 
        General method
    </output></pre>
    <p>In general var-arg method will get least priority i.e if no other method matched then only var-arg method will get the chance. It is 
        exactly same as default case inside switch</p>
    
        <pre><code>
            class Animal {

            }
            class Monkey extends Animal {

            }
            class Test {
                public void m1(Animal a) {
                    SOP("Animal version");
                }
                public void m1(Monkey m) {
                    SOP("Monkey version");
                }
            }
            public static void main(String[] args) {
                Test t = new Test();
                Animal a = new Animal();
                t.m1(a);
                Monkey m = new Monkey();
                t.m1(m);
                Animal a1 = new Monkey();
                t.m1(a1);
            }
        </code></pre>

        <pre><output>
            Animal version
            Monkey version
            Animal version
        </output></pre>

    <mark>Note : In overloading, method resolution always takes care by compiler based on reference type. In overloading run time object wont play any role</mark>
    
    
    <h5>Overriding</h5>
    <p>Whatever methods parent has by default available to the child through inheritance. If child class not satisfied with parent class implementation then child is allowed 
        to redefine that method based on its requirement. This process is called Overriding.
    <p>The parent class method which is overridden is called overridden method and child class method which is overriding is called overriding method</p>
        <pre><code>

        class P {
            public void property() {
                System.out.println("cash + land + gold");
            }
            //Overridden method
            public void marry() { 
                System.out.println("Subbalakshmi");
            }
        }
        //Overriding method
        class C extends P{
            public void marry() {
                System.out.println("Isha or 9tara or 4Me");
            }
        
        }
    </code></pre>

    <pre><code>
        class Test {
            public static void main(String[] args) {
                P p = new P();
                p.marry();
                C c = new C();
                c.marry();
                P p1 = new C();
                p1.marry();
            }
        }
    </code></pre>
    
    <pre><output>
        SubbaLakshmi(Parent method)
        3sha or 9tara or 4me(Child method)
        3sha or 9tara or 4me(Child method)
    </output></pre>

    <mark>In overriding, method resolution always takes care by JVM based on run time object and hence overriding is also considered as runtime polymorphism or 
        dynamic polymorphism or late binding.
    </mark>

    <h6>Rules for overriding</h6>
    <p>1. In overriding method names and argument types must be matched i.e method signatures must be same</p>
    <p>2. In overriding return types must be same but this rule is applicable until 1.4 version only. From 1.5 version onwards we can take <span style="color: red;">co-varient return types</span>. 
        According to this child class method return type need not be same as parent method return type. Its child type also allowed.
    </p>
    <pre><code>
        class P {
            public Object m1() {
                retun null;
            }
        }
        class C extends P {
            public String m1() {
                retun null;
            }
        }
    </code></pre>
    
    <mark>Above example is invalid in 1.4v but from 1.5v onward it is valid</mark>
<br><br>
    <img src="images/ss41.png" alt="ss12" width="600" height="500">

    <p>Co-varient return type concept applicable only for object types but not for primitive types</p>
    <p>3. Parent class private methods not available to the child and hence overriding concept not applicable for private methods</p>

    <p>Based on our requirement we can define exactly same private method in child class. It is valid but not overriding</p>

    <pre><code>
        class P {
            private void m1() {

            }
        }
        class C extends P {
            //It is valid but not overriding
            private void m1() {

            }
        }
    </code></pre>

    <p>4. We cant override parent class final methods in child classes. If we are trying to override we will get CE</p>
    <pre><code>
        class P {
            public final void m1() {

            }
        }
        class C extends P {
            public void m1() {

            }
        }
    </code></pre>

    <pre><output>
        CE: m1() in C cant override m1() in P, Overridden method is final 
    </output></pre>

    <p>5. Parent class abstraction methods we should override in child class to provide implementation.</p>
    <pre><code>
        abstract class P {
            public abstract void m1();
        }
        class C extends P {
            public void m1() {

            }
        }
    </code></pre>
    

    <p>We can override non-abstract method as abstract</p>
    <pre><code>
        class P {
            public void m1() {

            }
        }
        abstract class C extends P {
            public abstract void m1();
        }
        class SubC extends C {
            public void m1() {

            }
        }
    </code></pre>
        
<mark>The main advantage of this approach is we can stop the availability of parent method implementation to the next level child classes
    (implementation in parent class is by default available to child classes so in this case m1() implementation is available to C and SubC 
    but when we made m1() abstract in C so now SubC have to redefine or reimplement m1() method because parent class implementation is not available to SubC because of declaring m1() abstract in C class)
</mark>

<p>6. In overriding the following modifiers wont keep any restriction</p>
<p>1. synchonized</p>
<p>2. native</p>
<p>3. strictfp</p>

<img src="images/ss42.png" alt="ss12" width="400" height="600">

<p>7. While overriding we cant reduce scope of access modifier but we can increase the scope</p>
<pre><code>
    class P {
        <span style="color: red;">public</span> void m1() {

        }
    }
    class C extends P {
        void m1() {

        }
    }
</code></pre>
<pre><output>
    CE: m1() in C can not override m1() in P;
    attempting to assign weaker access privileges; was public
</output></pre>

<p class="bg-primary text-white">private&ltdefault&ltprotected&ltpublic</p>

<img src="images/ss43.png" alt="ss12" width="500" height="600">

<div class="container">
    <p class="bg-warning text-white">Why scope of modifierswe cant reduce?</p>
    <p>Because outside people there may be a chance of effecting</p>    
</div>

<pre><code>
    class P {
        public void m1() {

        }
    }
    class C extends P {
        
    }

    //Outside people accessing m1() method
    P p = new C();
    p.m1(); //Suppose 100 outside people is accessing m1() in P because it is public anyone can access
</code></pre>
<pre><code>
    class P {
        public void m1() {

        }
    }
    class C extends P {
        public void m1() {

        }
    }

    //Outside people accessing m1() method
    P p = new C();
    p.m1(); // since we are overriding m1() so in overriding 
            run time polymorphism concept is there so child class m1() will be executed
            and same people can access now also because in child class also m1() is public
</code></pre>

<pre><code>
    class P {
        public void m1() {

        }
    }
    class C extends P {
        void m1() {

        }
    }

    //Outside people accessing m1() method
    P p = new C();
    p.m1(); //Earlier when we were not overriding m1() in P, many people 
            were able to access m1() method but now we are overriding and scope is reduced
            so within the package only we can access so scope of modifier we cant reduce
</code></pre>

 <h6>Case 1: </h6>
 <p>9. If child class method throws any checked exception compulsory parent class method should throw the same checked exception or 
     its parent o/w we will get CE but there are no restrictions for unchecked exceptions
 </p>

 <pre><code>
    class P {
        public void m1() throws IOException {

        }
    }
    class C extends P {
        public void m1() throws EOFException, InterruptedException {

        }
    }
</code></pre>

<pre><output>
    CE: m1() in C can not override m1() in P; overridden method does not 
    throw java.lang.InterruptedException
</output></pre>

<pre><code>
    1.  P : public void m1() throws Exception 
        C : public void m1()

    2.  P : public void m1()  
        C : public void m1() throws Exception

    3.  P : public void m1() throws Exception
        C : public void m1() throws Exception

    4.  P : public void m1() throws IOException 
        C : public void m1() throws Exception

    5.  P : public void m1() throws IOException 
        C : public void m1() throws FileNotFoundException, EOFException

    6.  P : public void m1() throws IOException 
        C : public void m1() throws EOFException, InterruptedException

    7.  P : public void m1() throws IOException 
        C : public void m1() throws ArithmaticException, NullPointerException, ClassCastException
</code></pre>

<pre><output>
    1. valid
    2. invalid 
    3. valid 
    4. invalid 
    5. valid 
    6. invalid 
    7. valid
</output></pre>

<h6>Overriding with respect to static methods</h6>

<pre><code>
    class P {
        public static void m1() {

        }
    }
    class C extends P {
        public void m1() {

        }
    }
</code></pre>
<pre><output>
    CE: m1() in C cant override m1() in P; Overridden method is static
</output></pre>

<p>1. We cant override a static method as non static o/w we will get CE</p>

<pre><code>
    class P {
        public void m1() {

        }
    }
    class C extends P {
        public static void m1() {

        }
    }
</code></pre>
<pre><output>
    CE: m1() in C cant override m1() in P; overriding method is static
</output></pre>

<p>2. Similarily, we cant override a non-static method as static</p>
<pre><code>
    class P {
        public static void m1() {

        }
    }
    //It is method hiding but not overriding
    class C extends P {
        public static void m1() {

        }
    }
</code></pre>

<p>3. If both parent and child class methods are static then we wont get any CE it seems overriding concept 
    applicable for static methods but it is not overriding and it is method hiding</p>

<h6>Method Hiding</h6>
<p>All rules of method hiding are exactly same as overriding except the following differences.</p>
<table class="table table-striped">
    <thead class="thead-dark">
         <tr>
            <th>Method hiding</th>
            <th>Overriding</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>Both parent and child class methods should be static</td>
            <td>Both parent and child class methods should be non-static</td>
        </tr> 
        <tr>
            <td>Compiler is responsible for method resolution based on reference type</td>
            <td>JVM is responsible for method resolution based on run time object</td>
        </tr> 
        <tr>
            <td>It is also known as compile time polymorphism or static polymorphism or early binding</td>
            <td>It is also known as run time polymorphism or dynamic polymorphism or late binding</td>
        </tr> 
    </tbody>
</table>

<pre><code>
    class P {
        public <span style="color: red;">static</span> void m1() {
            SOP("Parent");
        }
    }
    //It is method hiding but not overriding
    class C extends P {
        public <span style="color: red;">static</span> void m1() {
            SOP("Child");
        }
    }
    class Test {
        public static void main(String[] args) {
            P p = new P();
            p.m1();

            C c = new C();
            c.m1();

            P p1 = new C();
            p1.m1();
        }
    }
</code></pre>

<pre><output>
    Parent
    Child 
    Parent
</output></pre>

<p>If both parent and child class methods are non-static then it will become overriding. In that case o/p will become : </p>
<pre><output>
    Parent
    Child 
    Child
</output></pre>

<h6>Overriding with respect to var-args method</h6>
<pre><code>
    class P {
        public void m1(int... x) {
            SOP("Parent");
        }
    }
    //It is Overloading but not overriding
    class C extends P {
        public void m1(int x) {
            SOP("Child");
        }
    }
    class Test {
        public static void main(String[] args) {
            P p = new P();
            p.m1();

            C c = new C();
            c.m1();

            P p1 = new C();
            p1.m1();
        }
    }
</code></pre>

<pre><output>
    Parent
    Child
    Parent
</output></pre>

<p>We can override var-arg method with another var-arg method only. If we are trying to override 
    with normal method then it will become Overloading but not overriding.
</p>

<p>In the above program if we replace child method with var-arg method then it will become overriding. In 
    this case the output is</p>
    <pre><output>
        Parent
        Child
        Child
    </output></pre>

<h6>Overriding with respect to variables</h6>
<h6>P: non-static C: non-static</h6>
<pre><code>
    class P {
        int x = 888;
    }
    class C extends P {
        int x = 999;
    }
    class Test {
        public static void main(String[] args) {
            P p = new P();
            SOP(p.x);

            C c = new C();
            SOP(c.x);

            P p1 = new C();
            SOP(p1.x);
        }
    }
</code></pre>

<pre><output>
    888 
    999 
    888
</output></pre>

<p>variable resolution always takes care by compiler based on reference type irrespective of Whether the 
    variable is static or non-static(overriding concept applicable only for methods but not for variables) </p>

    <h6>P: static C: non-static</h6>
    <pre><code>
        class P {
            static int x = 888;
        }
        class C extends P {
            int x = 999;
        }
        class Test {
            public static void main(String[] args) {
                P p = new P();
                SOP(p.x);
    
                C c = new C();
                SOP(c.x);
    
                P p1 = new C();
                SOP(p1.x);
            }
        }
    </code></pre>
    
    <pre><output>
        888 
        999 
        888
    </output></pre>

    <h6>P: non-static C: static</h6>
    <pre><code>
        class P {
            int x = 888;
        }
        class C extends P {
            static int x = 999;
        }
        class Test {
            public static void main(String[] args) {
                P p = new P();
                SOP(p.x);
    
                C c = new C();
                SOP(c.x);
    
                P p1 = new C();
                SOP(p1.x);
            }
        }
    </code></pre>
    
    <pre><output>
        888 
        999 
        888
    </output></pre>

    <h6>P: static C: static</h6>
    <pre><code>
        class P {
            static int x = 888;
        }
        class C extends P {
            static int x = 999;
        }
        class Test {
            public static void main(String[] args) {
                P p = new P();
                SOP(p.x);
    
                C c = new C();
                SOP(c.x);
    
                P p1 = new C();
                SOP(p1.x);
            }
        }
    </code></pre>
    
    <pre><output>
        888 
        999 
        888
    </output></pre>

<h6>Differences between overloading and overriding</h6>
<table class="table table-striped">
    <thead class="thead-dark">
         <tr>
            <th>Property</th>
            <th>Overloading</th>
            <th>Overriding</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>Method names</td>
            <td>Must be same</td>
            <td>Must be same</td>
        </tr>
        <tr>
            <td>Argument Types</td>
            <td>Must be different(atleast order)</td>
            <td>Must be same(including order)</td>
        </tr>
        <tr>
            <td>Method signatures</td>
            <td>Must be different</td>
            <td>Must be same</td>
        </tr> 
        <tr>
            <td>Return types</td>
            <td>No restrictions</td>
            <td>Must be same until 1.4v but from 1.5v onwards co-varient return types also allowed</td>
        </tr>
        <tr>
            <td>private, static and final methods</td>
            <td>Can be overloaded</td>
            <td>Can not be Overridden</td>
        </tr>
        <tr>
            <td>Access modifiers</td>
            <td>No restrictions</td>
            <td>We cant reduce scope of access modifier but we can increase the scope</td>
        </tr>
        <tr>
            <td>throws clause</td>
            <td>No restrictions</td>
            <td>If child class method throws any checked exception compulsory parent class method should throw the same checked exception or its parent but no restrictions for unchecked exception</td>
        </tr>
        <tr>
            <td>Method resolution</td>
            <td>Always takes care by compiler based on reference type</td>
            <td>Always takes care by JVM based on run time object</td>
        </tr>
        <tr>
            <td>It is also known as</td>
            <td>Compile time polymorphism or Static polymorphism or early binding</td>
            <td>Run time polymorphism or dynamic polymorphism or late binding</td>
        </tr>
    </tbody>
</table>

<mark>Note : In overloading we have to check only method names(must be same) and argument types must be different. We are not required to check remaining like 
    return types, access modifiers etc. But in overriding everything we have to check like method names, argument types, retun types, access modifiers, throws clause etc</mark>
    

    <div class="container">
        <p class="bg-warning text-white">Consider the below method in the parent class. 
        <pre><code>
            public void m1(int x) throws IOException
        </code></pre>
        In the child class which of the following methods we can take</p>
        <pre><code>
            public void m1(int i)
            public static int m1(long l)
            public static void m1(int i)
            public void m1(int i) throws Exception
            public static abstract void m1(double d)
        </code></pre>
        
        <pre><output>
            overriding
            overloading
            overriding &#10060
            overriding &#10060
            CE: illegal combination of modifiers i.e static abstract
        </output></pre>
            
    </div>

    <h6>Polymorphism</h6>
    <p>One name but multiple forms is the concept of polymorphism</p>

    <p>Example 1 : Method name is the same but we can apply for different types of arguments(Overloading)</p>
    <pre><code>
        abs(int)
        abs(long)
        abs(float)
    </code></pre>
   
    <p>Example 2: Method signature is same but in parent class one type of implementation and in the child class another type of implementation(overriding)</p>
    <pre><code>
        class P {
            marry() {
                SOP("Subbalakshmi");
            }
        }
        class C extends P {
            marry() {
                SOP("3sha or 9tara or 4me");
            }
        }
    </code></pre>
    
    <p>Example 3: Usage of parent reference to hold child object is considered as polymorphism</p>
    <pre><code>
        List l = new ArrayList();
        List l = new LinkedList();
        List l = new Stack();
        List l = new Vector();
    </code></pre>

    <img src="images/ss44.png" alt="ss12" width="400" height="600">
    <p>Parent class reference can be used to hold child class object but by using that reference we can only call the methods available in parent class. 
        And we cant call child specific methods</p>
     
        <pre><code>
            class P {
                public void m1() {
        
                }
            }
            class C extends P {
                public void m2() {
        
                }
            }
            P p = new C();
            p.m1();
            p.m2();
        </code></pre>
        
        <pre><output>
            valid
            CE : cant find symbol, symbol : method m2(), location : class P
        </output></pre>

        <p>But by using child reference we can call both parent and child class methods.</p>

        <pre><code>
            C c = new C();
            c.m1();
            c.m2();
        </code></pre>
        
        <div class="container">
            <p class="bg-warning text-white">When we should go for parent reference to hold child object?</p>
            <p>If we dont know exact run time type of object then we should go for parent reference</p>
            <p>Example 1 : The first element present in the ArrayList can be any type, it may be student object, customer object, String object or StringBuffer object. 
                Hence the return type of get method is object which can hold any object</p>
                
                <pre><code>
                    Object o = l.get(0);
                </code></pre>
                <img src="images/ss45.png" alt="ss12" width="400" height="200">
        </div >

        <table class="table table-striped">
            <thead class="thead-dark">
                 <tr>
                    <th>C c = new C();</th>
                    <th>P p = new C();</th>
                </tr>
            </thead> 
            <tbody>
                <tr>
                    <td>Eg : ArrayList l = new ArrayList();</td>
                    <td>Eg : List l = new ArrayList();</td>
                </tr>
                <tr>
                    <td>We can use this approach if we know exact run time type of object</td>
                    <td>We can use this approach if we dont know exact run time type of object</td>
                </tr>
                <tr>
                    <td>By using child reference we can call both parent class and child class methods.(This is the advantage of this approach)</td>
                    <td>By using parent reference we can call only methods available in parent class and we cant call child specific methods(This is the disadvantage of this approach)</td>
                </tr>
                <tr>
                    <td>We can use child reference to hold only particular child class object(This is the disadvantage of this approach)</td>
                    <td>We can use parent reference to hold any child class object.(This is the advantage of this approach)</td>
                </tr> 
            </tbody>
    </table>
    
    <img src="images/ss46.png" alt="ss12" width="400" height="600">

    <img src="images/ss47.png" alt="ss12" width="400" height="600">

    <br><br>
    <mark>A BOY starts LOVE with the word FRIENDSHIP, but girl ends LOVE with the same word FRIENDSHIP. Word is the same but attitude is different. 
        This beautiful concept of OOPS is nothing but polymorphism</mark>
    
    
    <h5>Static control flow</h5>
    <p>Whenever we are executing a java class the following sequence of steps will be executed as a part of static control flow</p>
    <p>1. Identification of static members from top to bottom(1 - 6)</p>
    <p>2. Execution of static variable assignments and static blocks from top to bottom(7 - 12)</p>
    <p>3. Execution of main method(13 - 15)</p>
    <pre><code>
        class Base {
            1. static int i = 10; //7th step
            2. static {
                    m1();   //8th step
                    SOP("First static block");  //10th step
                }
            3.  public static void main(String[] args) {
                    m1();   //13th step
                    SOP("main method"); //15th step
                }
            4.  public static void m1() {
                    SOP(j); //9th step  //14th step
                }
            5.  static {
                    SOP(Second static block);   //11th step
                }
            6.  static int j = 20;  //12th step
        }
    </code></pre>

    <pre><output>
        0
        First static block
        Second static block
        20
        main method
    </output></pre>

    <p>First step - Identification</p>
    <p>In first step - i = 0[RIWO](default value at the time of Identification. RIWO - read indirectly write only)</p>
    <p>In sixth step - j = 0[RIWO]</p>

    <p>Second step - Execution</p>
    <p>In seventh step - i = 10[R&W]</p>
    <p>In 12th step - j = 20[R&W]</p>

    <h6>Read indirectly write only(RIWO)</h6>
    <p>Inside static block if we are trying to read a variable that read operation is called direct read</p>
    <p>If we are calling a method, and within that method if we are trying to read a variable that read operation is called 
        indirect read</p>
    <pre><code>
        class Test {
            static int i = 10;
            static {
                m1();
                SOP(i); //Direct read
            }
            public static void m1() {
                SOP(i); //Indirect read
            }
        }
    </code></pre>

    <p>If a variable is just identified by the JVM and original value not yet assigned then the variable is said to be in  
        read indirectly and write only state(RIWO)
    </p>
    <p>If a variable is in RIWO state then we cant perform direct read but we can perform indirect read</p>
    <p>If we are trying to read directly then we will get CE saying illegal forward reference</p>

    <pre><code>
        class Test {
            static int x = 10;
            static {
                SOP(x);
            }
        }
    </code></pre>

    <pre><output>
        10
        RE : NoSuchMethodError : main
    </output></pre>

    <pre><code>
        class Test {
            static {
                SOP(x);
            }
            static int x = 10;
        }
    </code></pre>

    <pre><output>
        CE : illegal forward reference
    </output></pre>

    <pre><code>
        class Test {
            static {
                m1();
            }
            public static void m1() {
                SOP(x);
            }
            static int x = 10;
        }
    </code></pre>

    <pre><output>
        0
        RE : NoSuchMethodError : main
    </output></pre>

    <h5>Static block</h5>
    <p>Static blocks will be executed at the time of class loading, hence at the time of class loading 
        if we want to perform any activity we have to define that inside a static block</p>
    <p>Example 1 : </p>
    <p>At the time of java class loading the corresponding native libraries should be loaded, hence we have to define this activity inside 
        static bloc</p>
        <pre><code>
            class Test {
                static {
                    System.loadLibrary("native library path");
                }
            }
        </code></pre>
    
    <p>After loading every database driver class, we have to register driver class with driver manager but inside database driver class there is a 
        static block to perform this activity and we are not responsible to register explicitly
    </p>

    <pre><code>
        class DbDriver {
            static {
                Register this Driver with DriverMAnager
            }
        }
    </code></pre>

    <mark>Note : Within a class we can declare any number of static blocks but all these static blocks will be executed from top to bottom</mark>

    <div class="container">
        <p class="bg-warning text-white">Without writing main method is it possible to print some statement to the console?</p>
        <p>Yes. By using static block</p>
        <pre><code>
            class Test {
                static {
                    SOP("Hello I can print...");
                    System.exit(0);
                }
            }
        </code></pre>
        <pre><output>
            Hello I can print...
        </output></pre>
        
    </div>
    <div class="container">
        <p class="bg-warning text-white">Without writing main method and static block is it possible to print some statement to the console</p>
        <p>Yes ofcourse there are multiple ways</p>
        <p>Example 1 :</p>
        <pre><code>
            class Test {
                static int x = m1();
                public static int m1() {
                    System.out.println("Hello I can print");
                    System.exit(0);
                    return 10;
                }
            }
        </code></pre>
        <p>Example 2 : </p>
        <pre><code>
            class Test {
                static Test t = new Test();
                {
                    SOP("Hello I can print");
                }
            }
        </code></pre>
        <p>Example 3 : </p>
        <pre><code>
            class Test {
                static Test t = new Test();
                Test() {
                    SOP("Hello I can print");
                    System.exit(0);
                }
            }
        </code></pre>
    </div>

    <mark>Note : From 1.7v onwards main method is mandatory to start a program execution hence from 1.7v onwards 
        w/o writing main method it is impossible to print some statements to the console</mark>
    
    <h6>Static control flow in parent to child relationship</h6>
    <p>Whenever we are executing child class the following sequence of events will be executed automatically as a part of static control flow</p>
    <p>1. Identification of static members from parent to child(1 - 11)</p>
    <p>2. Execution of static variable assignments & static blocks from parent to child(12 - 22)</p>
    <p>3. Execution of only child class main method(23 - 25)</p>

    <pre><code>
        class Base {
            static int i = 10;  //1st step  //12th step
            static {    //2nd step
                m1();   //13th step
                SOP("Base static block");   //15th step
            }
            public static void main(String[] args) {    //3rd step
                m1();  
                SOP("Base main");
            }
            public static void m1() {   //4th step
                SOP(j); //14th step 
            }
            static int j = 20;  //5th step  //16th step
        }

        class Derived extends Base {
            static int x = 100; //6th sep   //17th step
            static {    //7th step
                m2();   //18th step
                SOP("Derived first static block");  //20th step
            }
            public static void main(String[] args) {    //8th step 
                m2();   //23th step
                SOP("Derived main");    //25th step
            }
            public static void m2() {   //9th step
                SOP(y); //19th step //24th step
            }
            static {    //10th step
                SOP("Derived second static block"); //21th step
            }
            static int y = 200; //11th step //22th step
        }
    </code></pre>

    <pre><output>
        javac Base.java<kbd>enter</kbd>
        java Derived<kbd>enter</kbd>
        0
        Base static block
        0
        Derived first static block
        Derived second static block
        200
        Derived main
    </output></pre>

    <p>Initialization</p>
    <p>1st step -  i = 0[RIWO]
    <p>5th step -  j = 0[RIWO]
    <p>6th step -  x = 0[RIWO]
    <p>11th step - y = 0[RIWO]

    <p>Execution</p>
    <p>12th step - i = 10[R&W]</p>
    <p>16th step - j = 20[R&W]</p>
    <p>17th step - x = 100[R&W]</p>
    <p>22th step - y = 200[R&W]</p>

    <p>Whenever we are executing child class only child class main method will be executed if the child class 
        doesnt contain main method then only parent class main method will be executed.
    </p>

    <pre><output>
        java Base<kbd>enter</kbd>
        0
        Base static block 
        20 
        Base main 
    </output></pre>

    <mark>Note : Whenever we are loading child class automatically parent class will be loaded but Whenever we are loading parent class child 
        class wont be loaded(Because parent class members by default available to the child class whereas child class members by default 
        wont available to the parent)</mark>

    <h5>Instance control flow</h5>
    <p>Whenever we are executing a java class first static control floww will be executed. In the static control flow if we are creating an object 
        the following sequence of events will be executed as the part of Instance control flow</p>
    <p>1. Identification of instance memebers from top to bottom(3 - 8)</p>
    <p>2. Execution of instance variable assignments and instance blocks from top to bottom(9 - 14)</p>
    <p>3. Execution of Constructor(15)</p>

    <pre><code>
        class Test {
            int i = 10; //3rd step  //9th step
            {   //4th step
                m1();   //10th step
                SOP("First instance block");    //12th step
            }
            Test() {    //5th step
                SOP("Constructor"); //15th step
            }
            public static void main(String[] args) {    //1st step
                Test t = new Test();    //2nd step
                SOP("main");    //16th step
            }
            public void m1() {  //6th step
                SOP(j); //11th step
            }
            {   //7th step
                SOP("Second Instance Block")    //13th step
            }
            int j = 20; //8th step  //14th step
        }
    </code></pre>

    <pre><output>
        0
        First instance block
        Second instance block
        Constructor
        main
    </output></pre>

    <p>Identification</p>
    <p>3rd step i = 0[RIWO]</p>
    <p>8th step j = 0[RIWO]</p>

    <p>Execution</p>
    <p>9th step i = 10[R&W]</p>
    <p>14th step j = 20[R&W]</p>

    <pre><code>
        class Test {
            int i = 10; 
            { 
                m1(); 
                SOP("First instance block");    
            }
            Test() {  
                SOP("Constructor"); 
            }
            public static void main(String[] args) {    
                //Test t = new Test();  //line1
                SOP("main");   
            }
            public void m1() {  
                SOP(j);
            }
            {   
                SOP("Second Instance Block")   
            }
            int j = 20; 
        }
    </code></pre>
    <pre><output>
        main
    </output></pre>

    <p>If we comment line1 then the output is main</p>

    <pre><code>
        class Test {
            int i = 10; 
            { 
                m1(); 
                SOP("First instance block");    
            }
            Test() {  
                SOP("Constructor"); 
            }
            public static void main(String[] args) {    
                Test t = new Test();
                SOP("main");   
                Test t = new Test();
            }
            public void m1() {  
                SOP(j);
            }
            {   
                SOP("Second Instance Block")   
            }
            int j = 20; 
        }
    </code></pre>
    <pre><output>
        0
        First instance block
        Second instance block
        Constructor
        main
        0
        First instance block
        Second instance block
        Constructor
    </output></pre>
    <mark>Note 1 : static control flow is one time activity which will be performed at the time of class loading 
        But instance control flow is not one time activity and it will be performed for every object creation</mark>
    <br><mark>Note 2 : Object creation is the most costly operation. If there is no specific requirement then it is not recommended to create object</mark>

    <h6>Instance control flow in parent to child relationship</h6>
    <p>Whenever we are creating child class object, the following sequence of events will be performed automatically as the part of instance control flow</p>
    <p>1. Identification of instance variables from parent to child(4 - 14)</p>
    <p>2. Execution of instance variable assignments and instance blocks only in parent class(15 - 19)</p>
    <p>3. Execution of parent Constructor(20)</p>
    <p>4. Execution of instance variable assignments and instance blocks only in child class</p>(21 - 26)
    <p>5. Execution of child Constructor(27)</p>

    <pre><code>
        class Parent {
            int i = 10; //4th   //15th
            {   //5th
                m1();   //16th
                SOP("Parent instance block");   //18th
            }
            Parent() {  //6th
                SOP("Parent Constructor")   //20th
            }
            public static void main(Strig[] args) { //1st
                Parent p = new Parent();
                SOP("Parent main");
            }
            public void m1() {  //7th
                SOP(j); //17th
            }
            int j = 20; //8th   //19th
        }

        class Child extends Parent {
            int x = 100;    //9th   //21st
            {   //10th
                m2();   //22nd
                SOP("Child first instance block");  //24th
            }
            Child() {   //11th
                SOP("Child Constructor")    //27th
            }
            public static void main(Strig[] args) { //2nd
                Child c = new Child();  //3rd
                SOP("Child main");  //28th
            }
            public void m2() {  //12th
                SOP(y); //23rd
            }
            {   //13th
                SOP("Child second instance block"); //25th
            }
            int y = 200;    //14th  //26th
        }
    </code></pre>

    <pre><output>
        javac Parent.java<kbd>enter</kbd>
        java Child<kbd>enter</kbd>
        0
        Parent instance block
        Parent Constructor
        0
        Child first instance block
        Child second instance block
        Child Constructor
        Child main
    </output></pre>

    <p>Identification</p>
    <p>4rd i = 0[RIWO]</p>
    <p>8th j = 0[RIWO]</p>
    <p>9th x = 0[RIWO]</p>
    <p>14th y = 0[RIWO]</p>

    <p>Execution</p>
    <p>15th i = 10[R&W]</p>
    <p>19th j = 20[R&W]</p>
    <p>21th x = 100[R&W]</p>
    <p>26th y = 200[R&W]</p>


    <pre><code>
        class Test {    
            {   //7th  //15th
                SOP("First Instance Block");    //10th  //18th
            }
            static {    //1st
                SOP("First static block");  /4th
            }
            Test() {    //8th   //16th
                SOP("Constructor"); //12th  //20th
            }
            public static void main(String[] args) {    //2nd
                Test t1 = new Test();   //6th
                SOP("main");    //13th
                Test t2 = new Test();   //14th
            }
            static {        //3rd
                SOP("Second static block"); //5th
            }
            {   //9th   //17th
                SOP("Second instance block");   //11th  //19th
            }
        }
    </code></pre>

    <pre><output>
        First static block
        Second static block
        First instance block
        Second instance block
        Constructor
        main 
        First instance block
        Second instance block
        Constructor
    </output></pre>

    <pre><code>
        public class Initialization {
            private static String m1(String msg) {  //1st
                System.out.println(msg);    //8th   //12th  //16th
                return msg; //9th   //13th  //17th
            }
            public Initialization() {   //4th
                m = m1("1");    //15th  //18th
            }
            {   //5th
                m = m1("2");    //7th   //10th
            }
            String m = m1("3"); //6th   //11th  //14th
            public static void main(String[] args) {    //2nd
                Object obj = new Initialization();  //3rd
            }
        }
    </code></pre>
    <pre><output>
        2
        3
        1
    </output></pre>

    <p>Identification of instance vaiables</p>
    <p>m = null</p>

    <p>Execution of instance variables assignments and blocks</p>
    <p>m = 1</p>

    <pre><code>
        public class Initialization {
            private static String m1(String msg) {  
                System.out.println(msg);    
                return msg;
            }

            static String m = m1("1");  

            {
                m = m1("2");
            }

            static {
                m = m1("3");    
            }

            public static void main(String[] args) {    
                Object obj = new Initialization();  
            }
        }
    </code></pre>
    <pre><output>
        1
        3
        2
    </output></pre>

    <pre><code>
        class Test {
            int x = 10;
            public static void main(String[] args) {
                SOP (x);
            }
        }
    </code></pre>
    
    <pre><output>
        CE : non-static variable x cannot be referenced from a static block.
    </output></pre>

    <mark>Note : From static area we cant access instance members directly because while executing static area 
        JVM may not identify instance members</mark>  

    <pre><code>
        class Test {
            int x = 10;
            public static void main(String[] args) {
                Test t = new Test();
                SOP(t.x);
            }
        }
    </code></pre>
    
    <pre><output>
        10
    </output></pre>

    <div class="container">
        <p class="bg-warning text-white">In how many ways we can create an object in java? or In how many 
            ways we can get object in java?
        </p>
        <p>1. By using new operator.</p >
            <pre><code>
                Test t = new Test();
            </code></pre>
        <p>2. By using newInstance() method</p>
        <pre><code>
            Test t = (Test)Class.forName("Test").newInstance();
        </code></pre>
        <p>3. By using factory method</p>
        <pre><code>
            Runtime r = Runtime.getRuntime();
            DateFormat df = DateFormat.getInstance();
        </code></pre>
        <p>4. By using clone() method</p>
        <pre><code>
            Test t1 = new Test();
            Test t2 = (Test)t1.clone();
        </code></pre>
        <p>5. By using deserialization</p>
        <pre><code>
            FileInputStream fis = new FileInputStream("abc.ser");
            ObjectInputStream ois = new ObjectInputStream(fis);
            Dog d2 = (Dog)ois.readObject(); 
        </code></pre>
        
        
        
        
            
    </div >

     


    <h5>Constructors</h5>
    <p>Once we creates an object compulsory we should perform Initialization then only the object 
        is in a position to respond properly</p>
        <pre><code>
            class Student {
                String name;
                int rollno;
                public static void main(String[] args) {
                    Student s1 = new Student();
                    Student s2 = new Student();
                        . 
                        . 
                        . 

                }
            }
        </code></pre>

        <pre><output>
            Not a good programming practice. It is meaningless every object having default values
        </output></pre>
        

        <img src="images/ss59.png" alt="ss12" width="400" height="300">
        
        <pre><code>
            class Student {
                String name = "durga";
                int rollno = 101;
                public static void main(String[] args) {
                    Student s1 = new Student();
                    Student s2 = new Student();
                        . 
                        . 
                        . 

                }
            }
        </code></pre>

        <pre><output>
            Not a good programming practice. It is meaningless every object having same values
        </output></pre>
        

        <img src="images/ss60.png" alt="ss12" width="400" height="300">

        <pre><code>
            class Student {
                String name;
                int rollno;

                {
                    name = "durga";
                    rollno = 101;
                }

                public static void main(String[] args) {
                    Student s1 = new Student();
                    Student s2 = new Student();
                        . 
                        . 
                        . 

                }
            }
        </code></pre>

        <pre><output>
            Not a good programming practice. It is meaningless every object having same values
        </output></pre>
        

        <img src="images/ss60.png" alt="ss12" width="400" height="300">

        <pre><code>
            class Student {
                String name;
                int rollno;
                public static void main(String[] args) {
                    Student s1 = new Student();
                    s1.name = "durga";
                    s1.rollno = 101;
                    Student s2 = new Student();
                    s2.name = "Ravi";
                    s2.rollno = 102;
                        . 
                        . 
                        . 

                }
            }
        </code></pre>

        <pre><output>
            Not a good programming practice. Length of code will increase like anything
        </output></pre>
        

        <img src="images/ss61.png" alt="ss12" width="400" height="300">

        <pre><code>
            class Student {
                String name;
                int rollno;
                Student(String name, int rollno) {
                    this.name = name;
                    this.rollno = rollno;
                }   
               public static void main(String[] args) {
                    Student s1 = new Student("durga", 101);
                    Student s2 = new Student("Ravi", 102);
                }
            }
        </code></pre>
    
        <p>Whenever we are creating an object some piece of the code will be executed automatically to perform Initialization 
            of the object. This piece of the code is nothing but Constructor. Hence the main purpose of Constructor is to perform 
            Initialization of an object</p>
        
        <h6>Difference between Constructor and instance blocks</h6>
        <p>The main purpose of Constructor is to perform 
            Initialization of an object</p>
        <p>But other than Initialization if we want to perform any activity for every object creation then we should go for instance block(like updating one entry in the database for every 
            object creation or incrementing count value for every object creation etc)</p>
        
        <p>Both constructor and instance block have their own different purposes and replacing one concept with another concept may not work always</p>
        <p>Both constructor and instance block will be executed for every object creation but instance block first followed by constructor</p>

        <div class="container">
            <p class="bg-warning text-white">Demo program to print number of object for a class.</p>
            <pre><code>
                class Test {
                    static int count = 0;

                    {
                        count++;
                    }
                    Test() {

                    }
                    Test(int i) {

                    }
                    Test(double d) {

                    }
                }
                public static voi main(String[] args) {
                    Test t1 = new Test();
                    Test t2 = new Test(10);
                    Test t3 = new Test(10.5);
                    SOP("The number of objects created : " + count);
                }
            </code></pre>
        </div>

        <h6>Rules of writing constructors</h6>
        <p>1. Name of the class and name of the constructor must be matched</p>
        <p>2. Return type concept not applicable for constructor even void also</p>
        <p>3. By mistake if we are trying to declare return type for the constructor then we wont get any CE because 
            compiler treats it as a method. Hence it is legal(but stupid) to have a method whose name is exactly same as class name</p>

            <pre><code>
                class Test {
                    void Test() {
                        SOP("method but not constructor");
                    }
                    public static void main(String[] args) {
                        Test t = new Test();
                        t.Test();
                    }
                }
            </code></pre>
            
            <pre><output>
                method but not constructor
            </output></pre>
        
            <h6>Constraints for constructor</h6>
            <p>The only applicable modifiers for constructor are public private protected default. If we are trying to use any 
                other modifier we will get CE</p>
                <pre><code>
                    class Test {
                        static Test() {

                        }
                    }
                </code></pre>
                <pre><output>
                    CE : modifier static not allowed here
                </output></pre>

            <h6>Default constructor</h6>
            <p>Compiler is responsible to generate default constructor but not JVM.</p>
            <p>If we are not writing any constructor then only compiler will generate default constructor i.e if we are writing atleast 
                one constructor then compile wont generate default constructor. Hence every class in java can contain constructor, it may be 
                default constructor generated by compiler or customized constructor explicitly provided by programmar but not both simultaneously</p>


    <h6>Prototype of default constructor</h6>
    <p>1. It is always no-arg constructor</p>
    <p>2. The access modifier of default constructor is exactly same as access modifier of class(this rule is applicable only for public and default)</p>
    <p>3. It contains only one line. It is a no argument call to super class constructor</p>

    <table class="table table-striped">
        <thead class="thead-dark">
             <tr>
                <th>Programmar's code</th>
                <th>Compiler generated code</th>
            </tr>
        </thead> 
        <tbody>
            <tr>
                <td>
                    <pre><code>
                        class Test {

                        }
                    </code></pre>
                </td>
		        <td>
                    <pre><code>
                        class Test {
                            Test() {
                                super();
                            }
                        }
                    </code></pre>
                </td>
            </tr>  
            <tr>
                <td>
                    <pre><code>
                        public class Test {

                        }
                    </code></pre>
                </td>
		        <td>
                    <pre><code>
                        public class Test {
                            public Test() {
                                super();
                            }
                        }
                    </code></pre>
                </td>
            </tr> 
            <tr>
                <td>
                    <pre><code>
                        public class Test {
                            void Test() {

                            }
                        }
                    </code></pre>
                </td>

		        <td>
                    <pre><code>
                        public class Test {
                            public Test() {
                                super();
                            }
                            void Test() {

                            }
                        }
                    </code></pre>
                </td>
            </tr> 
            <tr>
                <td>
                    <pre><code>
                        class Test {
                            Test() {

                            }
                        }
                    </code></pre>
                </td>
		        <td>
                    <pre><code>
                        class Test {
                            Test() {
                                super();
                            }
                        }
                    </code></pre>
                </td>
            </tr> 
            <tr>
                <td>
                    <pre><code>
                        class Test {
                            Test(int i) {
                                super();
                            }
                        }
                    </code></pre>
                </td>
		        <td>
                    <pre><code>
                        class Test {
                            Test(int i) {
                                super();
                            }
                        }
                    </code></pre>
                </td>
            </tr> 
            <tr>
                <td>
                    <pre><code>
                        class Test {
                            Test() {
                                this(10);
                            }
                            Test(int i) {

                            }
                        }
                    </code></pre>
                </td>
		        <td>
                    <pre><code>
                        class Test {
                            Test() {
                                this(10);
                            }
                            Test(int i) {
                                super();
                            }
                        }
                    </code></pre>
                </td>
            </tr> 
        </tbody>
</table>

<mark>The first line inside every constructor should be either super or this and if we are not writing anything then compiler will always place 
    super()</mark>
    
<h6>case 1: </h6>
<pre><code>
    class Test {
        Test {
            SOP("Hii");
            super();
        }
    }           
</code></pre>
<pre><output>
    CE : call to super must be first statement in constructor
</output></pre>
<p>We can take super() or this() only in first line of constructor if we are trying to get anywhere else we will get CE</p>

<h6>case 2 : </h6>
<pre><code>
    class Test {
        Test {
            super();
            this();
        }
    }           
</code></pre>
<pre><output>
    CE : call to this must be first statement in constructor
</output></pre>

<p>Within a constructor we can take either super() or this() but not both simultaneously</p>

<h6>Case 3 : </h6>
<pre><code>
    class Test {
        public void m1() {
            super();
            SOP("Hello");
        }
    }
</code></pre>
<pre><output>
    CE : call to super must be first statement in constructor
</output></pre>

<p>We can use super() or this() only inside constructor if we are trying to use outside of constructor. We will get CE i.e we can 
    call a constructor directly from another constructor only
</p>

<h6>super() and this()</h6>
 <mark>1. We can use only in constructor<br> 2. only in first line<br> 
3. Only one but not both simultaneously</mark>

<table class="table table-striped">
    <thead class="thead-dark">
         <tr>
            <th>super(), this()</th>
            <th>super, this</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>These are constructor calls to call super class and 
                current class constructors
            </td>
            <td>These are keywords to refer super class and current class instance members</td>
        </tr>  
        <tr>
            <td>We can use only in constructors as first line</td>
            <td>We can use anywhere except static area</td>
        </tr>
        <tr>
            <td>We can use only once in constructor</td>
            <td>We can use any number of times</td>
        </tr>
    </tbody>
</table>

<pre><code>
    class Test {
        int x = 100;
    }          
    class C extends P {
        int x = 200;
        public void m1() {
            SOP(this.x);    //200
            SOP(super.x);   //100
        }
    } 
</code></pre>

<pre><code>
    class Test {
        public static void main(String[] args) {
            SOP(super.hashCode());
        }
    }           
</code></pre>
<pre><output>
    CE : non-static variable super cannot be referenced from a static context
</output></pre>

<h6>Overloaded constructors</h6>
<p>Within a class we can declare multiple constructors and all these constructors having same name but different 
    type of arguments hence all these constructors are considered as overloaded constructors hence overloading concept applicable for 
    constructors</p>

    <pre><code>
        class Test {
            Test() {
                this(10);
                SOP("no-arg");
            }
            Test(int i) {
                this(10.5);
                SOP("int-arg");
            }
            Test(double d) {
                SOP("double-arg");
            }
            public static void main(String[] args) {
                Test t1 = new Test();
            }
        }
        
    </code></pre>
    
    <pre><output>
        double-arg
        int-arg
        no-arg 
    </output></pre>

    <pre><code>
        class Test {
            Test() {
                this(10);
                SOP("no-arg");
            }
            Test(int i) {
                this(10.5);
                SOP("int-arg");
            }
            Test(double d) {
                SOP("double-arg");
            }
            public static void main(String[] args) {
                Test t2 = new Test(10);
            }
        }
        
    </code></pre>
    
    <pre><output>
        double-arg
        int-arg
    </output></pre>

    <pre><code>
        class Test {
            Test() {
                this(10);
                SOP("no-arg");
            }
            Test(int i) {
                this(10.5);
                SOP("int-arg");
            }
            Test(double d) {
                SOP("double-arg");
            }
            public static void main(String[] args) {
                Test t3 = new Test(10.5);
            }
        }
        
    </code></pre>
    
    <pre><output>
        double-arg
    </output></pre>

    <pre><code>
        class Test {
            Test() {
                this(10);
                SOP("no-arg");
            }
            Test(int i) {
                this(10.5);
                SOP("int-arg");
            }
            Test(double d) {
                SOP("double-arg");
            }
            public static void main(String[] args) {
                Test t4 = new Test(10l);
            }
        }
        
    </code></pre>
    
    <pre><output>
        double-arg
    </output></pre>

     <mark>For constructors inheritance and overriding concepts are not applicable but overloading concept is applicable</mark>

    <p>Every class in java including abstract class can contain constructor but interface can not conatin constructor</p>

    <h6>case 1 : </h6>
    <p>Recursive method call is RE saying StackOverflowError but in our program if there is a chance of recursive constructor invocation 
        then the code wont compile and we will get CE
    </p>

    <pre><code>
        class Test {
            public static void m1() {
                m2();
            }
            public static void m2() {
                m1();
            }
            public static void main(String[] args) {
                m1();
                SOP("Hello");
            }
        }
    </code></pre>
    
    <pre><output>
        RE : StackOverflowError
    </output></pre>

    <pre><code>
        class Test {
            Test() {
                this(10);
            }
            Test(int i) {
                this();
            }
            public static void main(String[] args) {
                SOP("Hello");
            }
        }
    </code></pre>
    
    <pre><output>
        CE : Recursive constructor invocation
    </output></pre>

<h6>case 2 : </h6>
<p></p>

<p>Example 1 : Red color representing compiler generated code</p>
<pre><code>
    class P {
        <span style="color: red;">
            P() {
                super();
            }
        </span>
    }
    class C extends P {
        <span style="color: red;">
        C() {
            super();
        }
        </span>
    }
</code></pre>

<pre><output>
    valid
</output></pre>

<p>Example 2 :</p>
<pre><code>
    class P {
        P() {
            <span style="color: red;">super();</span>
        }
    }
    class C extends P {
        <span style="color: red;">
        C() {
            super();
        }
        </span>
    }
</code></pre>

<pre><output>
    valid
</output></pre>

<p>Example 3 : </p>
<pre><code>
    class P {
        P(int i) {
            <span style="color: red;">super();</span>
        }
    }
    class C extends P {
        <span style="color: red;">
        C() {
            super();
        }
        </span>
    }
</code></pre>

<pre><output>
    CE : cannot find symbol 
    symbol : constructor P() 
    location : class P
</output></pre>

<p>Note : </p>
<p>1. If parent class conatins any argument constructors then while writing child classes we have to  
    take special care with respect to constructors</p>
<mark>2. Whenever we are writing any argument constructor it is highly recommended to write no-arg constructor also</mark>

<h6>case 3 : </h6>
<pre><code>
    class P {
        P() throws IOException {

        }
    }
    class C extends P {
        <span style="color: red;">
        C() {
            super();
        }
        </span>
    }
</code></pre>

<pre><output>
    CE : unreported exception
    java.io.IOException in default constructor
</output></pre>
<pre><code>
    class P {
        P() throws IOException {

        }
    }
    class C extends P {
        C() <span style="color: red;">throws IOException | Exception | Throwable </span>{
            super();
        }
    }
</code></pre>

<pre><output>
    valid
</output></pre>

<p>Conclusions : </p>
<p>If parent class constructor throws any checked exception compulsory child class constructor should throw the same checked exception 
    or its parent o/w the code wont compile</p>

    <div class="container">
        <p class="bg-warning text-white">Which of the following is valid?</p>
        <p>1. The main purpose of constructor is to create an object.
        <p>2. The main purpose of constructor is to perform Initialization of an object.
        <p>3. The name of the constructor need not be same as class name.</p>
        <p>4. Return type concept applicable for constructors but only void.</p>
        <p>5. We can apply any modifier for constructor</p>
        <p>6. Default constructor generated by JVM</p>
        <p>7. Compiler is responsible to generate default constructor</p>
        <p>8. Compiler will always generates default constructor</p>
        <p>9. If we are not writing no-arg constructor then compiler will generate default constructor</p>
        <p>10. Every no argument constructor is always default constructor</p>
        <p>11. Default constructor is always no-arg constructor</p>
        <p>12. The first line inside every constructor should be either super() or this() if we are not writing anything then 
            compiler will generates this()</p>
        <p>13. For constructors both overloading and overriding concepts applicable</p>
        <p>14. For constructors inheritance concept applicable but not overriding</p>
        <p>15. Only concrete classes can conatin constructor but abstract classes can not</p>
        <p>16. Interface can contain constructors.</p>
        <p>17. Recursive constructor invocation is RE</p>
        <p>18. If parent class constructor throws some checked exception then compulsory child class constructor should throw 
            same checked exception or its child</p>
        
            <pre><output>
                1. invalid
                2. valid
                3. invalid
                4. invalid
                5. invalid
                6. invalid
                7. valid
                8. invalid
                9. invalid
                10. invalid
                11. valid
                12. invalid
                13. invalid
                14. invalid
                15. invalid
                16. invalid
                17. invalid
                18. invalid
            </output></pre>
    </div>


    <h6>Singleton class</h6>
    <p>For any java class if we are allowed to create only one object such type of class is called Singleton class</p>
    <p>Example</p>
    <p>1. Runtime</p>
    <p>2. Business delegate</p>
    <p>3. ServiceLocator etc</p>

    <h6>Advantages of Singleton class</h6>
    <p>1. If several people have same requirement then it is not recommended to create a separate object for every requirement. We have to create 
        only one object and we can reuse same object for every similar requirement so that performance and memory utilization will be improved. This is the central idea of singleton classes</p>

    <pre><code>
        Runtime r1 = Runtime.getRuntime();
        Runtime r2 = Runtime.getRuntime();
            . 
            . 
            . 
        Runtime r<sub>1lakh</sub> = Runtime.getRuntime();
    </code></pre>
    <img src="images/ss62.png" alt="ss12" width="400" height="300">

    <div class="container">
        <p class="bg-warning text-white">How to create our own singleton classes?</p>
        <p>We can create our own singleton classes, for this we have to use private constructor and private static variable 
            and public factory method</p>
        <p>approach 1 : </p>
        <pre><code>
            class Test {
                private static Test t = new Test();
                private Test() {

                }
                public static Test getTest() {
                    return t;
                }
            }
            Test t1 = Test.getTest();
            Test t2 = Test.getTest();
                . 
                . 
                .
            Test t<sub>1lakh</sub> = Test.getTest();
        </code></pre>
        <mark>Runtime class is internally implemented with this approach</mark>
        
        <p>Approach 2: </p>
        class Test {
            private static Test t = null;
            private Test() {

            }
            public static Test getTest() {
                if(t == null) {
                    t = new Test();
                }
                return t;
            }
        }
        Test t1 = Test.getTest();
        Test t2 = Test.getTest();
            . 
            . 
            .
        Test t<sub>1lakh</sub> = Test.getTest();
    </code></pre>
    <p>At any point of time for test class we can create only one object hence Test 
        class is singleton class</p>
    </div>

    <div class="container">
        <p class="bg-warning text-white">Class is not final but we are not allowed to create child classes. How it is possible?</p>
        <p>By declaring every constructor as private we can restrict child class creation</p>
        <pre><code>
            class P {
                private P() {

                }
            }
        </code></pre>
        <p>For the above class it is impossible to create child class</p>
    </div>



    <h5>Coupling</h5>
    <p>The degree of dependency between the components is called Coupling.</p>
    <p>If dependency is more then it is considered as tightly coupling and if dependency is less then it is considered as loosely coupling</p>

    <p>Example : </p>
    <pre><code>
        class A {
            static int i = B.j;
        }
        class B {
            static int j = c.k;
        }
        class C {
            static int k = D.m1();
        }
        class D {
            public static int m1() {
                return 10;
            }
        }
    </code></pre>

    <p>The above components are said to be tightly coupled with each other beacuse dependency between the components is more</p>
    <p>Tightly coupling is not a good Programming practice because it has several serious disadvantage</p>
    <p>1. Without affecting remaining components we cant modify any component and hence enhancement will become difficult</p>
    <p>2. It suppresses reusability</p>
    <p>3. It reduces maintainability of the application</p>
    
    <p>Hence we have to maintain dependency between the components as less as possible i.e loosely coupling is a good programming practice</p>
    
    <h5>Cohesion</h5>
    <p>For every component a clear well defined functionality is defined then that component is said to be follow high cohesion</p>
    <img src="images/ss49.png" alt="ss12" width="400" height="600">
    <img src="images/ss50.png" alt="ss12" width="400" height="600">

    <p>High cohesion is always a good programming practice because it has several advantages</p>
    <p>1. Without affecting remaining components we can modify any component hence enhancement will become easy</p>
    <p>2. It promotes reusability of the code(Wherever validation is required we can reuse the same validate servlet without rewriting)</p>
    <p>3. It improves maintainability of the application</p>

    <mark>Note : Loosely coupling and high cohesion are good programming practices</mark>

    <h5>Object Type casting</h5>
    <p>We can use parent reference to hold child object</p>
    <p>Example</p>
    <pre><code>
        Object o = new String("durga");
    </code></pre>
    <p>We can use interface reference to hold implemented class object</p>
    <p>Example</p>
    <pre><code>
        Runnable r = new Thread();
    </code></pre>

    <img src="images/ss51.png" alt="ss12" width="400" height="400">

    <mark>Mantra 1 : Compile Time Cheking</mark>
    <p>1. The type of 'd' and 'C' must have some relation either child to parent or parent to child or same type. O/w we will get compile 
        time error saying inconvertible types, found : d type, required : C </p>
    
    <p>Example 1 : </p>
    <pre><code>
        Object o = new String("durga");
        StringBuffer sb = (StringBuffer)o;
    </code></pre>

    <p>Example 2: </p>

    <pre><code>
        String s = new String("durga");
        StringBuffer sb = (StringBuffer)s;
    </code></pre>

    <pre><output>
        CE : inconvertible types
        found : j.l.String
        required : j.l.StringBuffer 
    </output></pre>
    
    <mark>Mantra 2 : Compile time Cheking 2</mark>
    <p>'C' must be either same or derived type of 'A' o/w we will get CE saying incompatible types found : C required : A</p>

    <p>Example 1 : </p>
    <pre><code>
        Object o = new String("durga");
        StringBuffer sb = (StringBuffer)o;
    </code></pre>

    <p>Example 2 : </p>
    <pre><code>
        Object o = new String("durga");
        StringBuffer sb = (String)o;
    </code></pre>

    <pre><output>
        CE : incompatible types
        found : j.l.String
        required : j.l.StringBuffer 
    </output></pre>

    <mark>Mantra 3 : Run time cheking</mark>
    <p>Run time object type of 'd' must be either same or derived type of 'C' o/w we will get RE saying ClassCastException</p>
    <p>Example 1: </p>
    <pre><code>
        Object o = new String("durga");
        StringBuffer sb = (StringBuffer)o;
    </code></pre>
    <pre><output>
        RE : ClassCastException : java.lang.String cannot be converted 
        to java.lang.StringBuffer
    </output></pre> 

    <p>Example 2 : </p>
    <pre><code>
        Object o = new String("durga");
        Object o1 = (String)o;
    </code></pre>

    <pre><output>
        valid
    </output></pre>

    <div class="container">
        <p class="bg-warning text-white">Which of the following are valid?</p>
        <img src="images/ss52.png" alt="ss12" width="400" height="300">
        <pre><code>
            Base2 b = new Der4();
            1. Object o = (Base2)b;
            2. Object o = (Base1)b;
            3. Object o = (Der3)b;
            4. Base2 b1 = (Base1)b;
            5. Base1 b1 = (Der4)b;
            6. Base1 b1 = (Der1)b;
        </code></pre>    
        <pre><output>
            1. valid
            2. CE : inconvertible types
                    found : Base2
                    required : Base1 
            3. RE : ClassCastException 
            4. CE : inconvertible types
                    found : Base2
                    required : Base1
            5. CE : incompatible types
                    found : Der4
                    required : Base1
            6. CE : inconvertible types
                    found : Base2
                    required : Der1
        </output></pre>
    </div >

    <p>Strictly speaking through type casting we are not creating any new object. </p>
    <p>For the existing object we are providing another type of reference variable i.e we are performing 
        type casting but not object casting</p>
    <p>Example : 1</p>
    <pre><code>
        String s = new String("durga");
        Object o = (Object)s;
        //Object o = new String("durga");
    </code></pre> 

    <p>Example 2: </p>
    <pre><code>
        Integer I = new Integer(10);
        Number n = (Number)I;
        Object o = (Object)n;
        SOP(I == n); //true
        SOP(n == o); //true
    </code></pre>

    <img src="images/ss53.png" alt="ss12" width="300" height="300">

    <p>First 3 line of code we can write as Object o = new Integer(10);</p>
    <p>First two lines of code we can write as Number n = new Integer(10);</p>

    <p> Note : </p>
    <img src="images/ss54.png" alt="ss12" width="300" height="300">
    <pre><code>
        C c = new C(); 
        (B)c;   //B b = new C();
        A((B)c) // A a = new C();
    </code></pre>

    <p>Example : 1</p>
    <img src="images/ss55.png" alt="ss12" width="300" height="300">
    <pre><code>
        C c = new C();
        c.m1();
        c.m2();
        ((P)c).m1;      //P p = new C();
        ((P)c).m2();    //P p = new C()
    </code></pre>

    <pre><output>
        valid 
        valid 
        valid 
        invalid
    </output></pre>

    <mark>Reason : Parent reference can be used to hold child object, but by using that reference we cant call child specific method and 
        we can call only methods present in parent class</mark>
        
    <p>Example 2 :</p>
        <img src="images/ss56.png" alt="ss12" width="300" height="300"> 
        <pre><code>
            C c = new C(); 
            c.m1();
            ((B)c).m1();
            ((A)((B)c)).m1();
        </code></pre>
        <pre><output>
            C 
            C 
            C
        </output></pre>

        <p>It is overriding and method resolution is always based on run time object</p>

    <p>Example 3 : </p>
    <img src="images/ss57.png" alt="ss12" width="300" height="300">
    <pre><code>
            C c = new C(); 
            c.m1();
            ((B)c).m1();
            ((A((B)c)).m1();
    </code></pre>
    <pre><output>
        C 
        B 
        A
    </output></pre>

    <p>It is method hiding and method resolution is always based on reference type</p>

    <p>Example 4 : </p>
    <img src="images/ss58.png" alt="ss12" width="300" height="300">
    <pre><code>
        C c = new C(); 
        SOP(c.x);
        SOP(((B)c).x);
        SOP((A((B)c)).x);
</code></pre>
<pre><output>
    999
    888
    777
</output></pre>

<p>Variable resolution is always based on reference type but not based on run time object</p>


<h1>Exception handling</h1>
    <h5>1. Introduction</h5>
    <p>An unexpected, unwanted event that disturbs normal flow of the program is called exception.</p>
    <p>Example : TyrePuncturedException, SleepingException, FileNotFoundException</p>
    <p>It is highly recommended to handle exceptions and the main objective of exception handling is graceful termination of the program</p>
    <p>Exception handling doesnt mean repairing an exception, we have to provide alternative way to continue rest of the program normally is the 
        concept of exception handling</p>
    <p>For example : Our programming requirement is to read data from remote file locating at London, at runtime if London file is not available, our 
        program should not be terminated abnormally. We have to provide some local file to continue rest of the program normally. This way of defining alternative 
        is nothing but exception handling</p>
        
        <pre><code>
            try {
                Read data from remote file 
                locating at london
            }
            catch(FileNotFoundException e) {
                Use local file & continue 
                rest of the program normally
            }
        </code></pre>


    <h5>2. Runtime stack mechanism</h5>
    <p>For every thread JVM will create a run time stack. Each and every method call performed by that thread will be stored 
        in the corresponding stack.</p>
    <p>Each entry in the stack is called stack frame or activation record.</p>
    <p>After completing evry method call the corresponding entry from the stack will be removed</p>
    <p>After completing evry method calls the stack will become empty and that empty stack will be destroyed by JVM just before terminating the thread</p>


    <pre><code>
        class Test {
            public static void main(String[] args) {
                doStuff();
            }
            public static void doStuff() {
                doMoreStuff();
            }
            public static void doMoreStuff() {
                SOP("Hello");
            }
        }
    </code></pre>

    <img src="images/ss63.png" alt="ss12" width="400" height="600">


    <h5>3. Default exception handling in java</h5>   
    <p>1. Inside a method if any exception occurs, the method in which  it is rised is responsible to create exception object by including the following information</p>
    <p>Name of exception</p>
    <p>Description of exception</p>
    <p>Location at which exception occurs(stack trace)</p>
    <p>2. After creating exception object method handovers that object to the JVM</p>
    <p>3. JVM will check whether the method contains any exception handling code or not
        If the method doesnt contain exception handling code, then JVM terminates that method abnormally and removes corresponding entry from the stack
    </p>
    <p>4. Then JVM identifies caller method and checks whether caller method contains any handling code or not. If the 
        caller method doesnt contain handling code then JVM terminates that caller method also abnormally and removes the corresponding entry from the stack. 
        This process will be continued until main method, and if the main method also doesnt conatin handling code then JVM terminates main method also abnormally
        and removes corresponding entry from the stack. Then JVM handovers responsibility of exception handling to default exception handler, which is the part of JVM.
        Default exception handler prints exception in the following format and terminates program abnormally.
    </p>

    <pre><code>
        Exception in thread "xxx" : Name of Exception : Description
        Stack Trace
    </code></pre>

    <p>Example 1 :</p>
    <pre><code>
        class Test {
            public static void main(String[] args) {
                doStuff();
            }
            public static void doStuff() {
                doMoreStuff();
            }
            public static void doMoreStuff() {
                SOP(10 / 0);
            }
        }
    </code></pre>
    <pre><output>
        RE : Exception in thread "main" java.lang.ArithmeticException: / by zero
        at Test.doMoreStuff
        at Test.doStuff
        at Test.main
    
    </output></pre>

    <p>Example 2 :</p>
    <pre><code>
        class Test {
            public static void main(String[] args) {
                doStuff();
                SOP(10 / 0);
            }
            public static void doStuff() {
                doMoreStuff();
                SOP("Hii");
            }
            public static void doMoreStuff() {
                SOP("Hello");
            }
        }
    </code></pre>
    <pre><output>
        Hello
        Hii
        Exception in thread "main" java.lang.ArithmeticException: / by zero
	        at Test.main
    </output></pre>

    <mark>Note : In a program if atleast one method terminates abnormally then the program termination is 
        abnormal termination. If all methods terminated normally then only program termination is normal termination</mark>
    
    
    <h5>4. Exception Hierarchy</h5>
    <p>Throwable class acts as root for java exception Hierarchy.</p>
    <p>Throwable class defines two child classes</p>
    <p>1. Exception</p>
    <p>2. Error</p>

    <h6>Exception</h6>
    <p>Most of the times exceptions are caused by our program and these are recoverable. For eaxmple : If 
        our programming requirement is to read data from remote file locating at london. At runtime if remote file 
        is not available then we will get RE saying FileNotFoundException</p>
    <p>If FileNotFoundException occurs we can provide local file and continue rest of the program normally</p>

    <pre><code>
        try {
            Read data from remote file 
            locating at london
        }
        catch(FileNotFoundException e) {
            Use local file & continue 
            rest of the program normally
        }
    </code></pre>

    <h6>Error</h6>
    <p>Most of the times errors are not caused by our program and these are due to lack of system resources. Errors 
        are non-recoverable
    </p>
    <p>If OutOfMemoryError occurs being a programmar we cant do anything and the program will be terminated abnormally</p>
    <p>System admin or server admin is responsible to increase heap memory</p>

    <img src="images/ss64.png" alt="ss12" width="1000" height="800">

    <h6>Checked exceptions vs unchecked expections</h6>
    <p>The exceptions which are Checked by compiler for smooth execution of the program are called checked exceptions</p>
    <p>Example : HallTicketMissingException, PenNotFountException, FileNotFoundException</p>
    <p>In our program if there is a chance of rising checked exception then compulsory we should handle that checked exception(either by 
        try catch or by throws keyword) o/w we will get CE</p>

        <pre><code>
            package com.cts.java;
            import java.io.PrintWriter;
            class Test {
                public static void main(String[] args) {
                    PrintWriter pw = new PrintWriter("abc.txt");
                    pw.println("String");
                }
            }
        </code></pre>
        
        <pre><output>
            unreported exception FileNotFoundException; must be caught or declared to be thrown
        </output></pre>

        <pre><code>
            package com.cts.java;
            import java.io.FileNotFoundException
            import java.io.PrintWriter;
            class Test {
                public static void main(String[] args) throws FileNotFoundException{
                    PrintWriter pw = new PrintWriter("abc.txt");
                    pw.println("String");
                }
            }
        </code></pre>
        
        <pre><output>
            compiles fine
        </output></pre>

        <pre><code>
            package com.cts.java;
            import java.io.FileNotFoundException
            import java.io.PrintWriter;
            class Test {
                public static void main(String[] args) throws FileNotFoundException{
                    PrintWriter pw = new PrintWriter("abc.txt");
                    pw.println("String");
                    SOP(10 / 0);
                }
            }
        </code></pre>
        
        <pre><output>
            compiles fine but RE
            RE : Exception in thread "main" java.lang.ArithmeticException: / by zero
            at Test.main(Test.java:6)
    
        </output></pre>

    <p>The exceptions which are not checked by compiler whether programmar handling or not such type of exceptions
        are called unchecked exceptions</p>
        <p>Example : ArithmeticException, BombBlastException etc</p>

    <mark>Note : 1. Whether it is checked or unchecked every exception occurs at runtime only. There is no chance of occuring any exception at 
        compile time<br> 2. RunTimeException and its child classes, error and its child classes are unchecked except these remaining are checked.</mark>
    
    <h6>Fully checked vs Partially checked</h6>
    <p>A checked exception is said to be fully checked iff all its child classes are also checked</p>
    <p>Example : IOException. InterruptedException</p>
    <p>A checked exception is said to be partially checked iff some of its child classes are unchecked</p>
    <p>Example : Exception, Throwable</p>
    <mark>Note : The only possible partially checked exceptions in java are Exception, Throwable</mark>

    <div class="container">
        <p class="bg-warning text-white">Describe the behavior of following exceptions?</p>
        <pre><code>
            1. IOException                  
            2. RunTimeException             
            3. InterruptedException      
            4. Error                      
            5. Throwable                    
            6. ArithmeticException       
            7. NullPointerException      
            8. Exception                 
            9. FileNotFoundException     
        </code></pre>
        
        <pre><output>
            1. Checked(fully) 
            2. unchecked
            3. Checked(fully)
            4. unchecked
            5. checked(partially)
            6. unchecked
            7. unchecked
            8. checked(partially)
            9. Checked(fully)
        </output></pre>
    </div> 

    <h5>5. Customized exception handling by using try catch</h5>
    <p>It is highly recommended to handle exceptions</p>
    <p>The code which may rise an exception is called risky code and we have to define that code inside try block. 
        And corresponding handling block we have to define inside catch block</p>

        <pre><code>
            try {
                Risky code
            }
            catch(Exception e) {
                Handling code
            }
        </code></pre>

<table class="table table-striped">
<thead class="thead-dark">
<tr>
    <th>Without try catch</th>
    <th>With try catch</th>
</tr>
</thead> 
<tbody>
<tr>
<td>
<pre><code>
class Test {
    public static void main(String[] args) {
        SOP("stat1");
        SOP(10 / 0);
        SOP("stat3");
    }
}
</code></pre>
<pre><output>
    stat1 
    RE : ArithmeticException : / by zero
</output></pre>
</td>
<td>
<pre><code>
class Test {
    public static void main(String[] args) {
        SOP("stat1");
        try {
            SOP(10 / 0);
        }
        catch(ArithmeticException e) {
            SOP(10 / 2);
        }
        SOP("stat3");
    }
}
</code></pre>
<pre><output>
    stat1
    5
    stat3
</output></pre>
    </td>
</tr>  
<tr>
    <td>Abnormal Termination</td>
    <td>Normal Termination</td>
</tr> 
    
</tbody>
</table>


    <h5>6. Control flow in try catch</h5>
    <pre><code>
        try {
            stat1; 
            stat2; 
            stat3;
        }
        catch(x e) {
            stat4; 
        }
        stat5;
    </code></pre>

    <h6>CASE 1:</h6>
    <p>If there is no exception</p>  
    <pre><output>
        1, 2, 3, 5, Normal Termination
    </output></pre>

    <h6>CASE 2:</h6>
    <p>If an exception rised at statement two and corresponding catch block matched</p>
    <pre><output>
        1, 4, 5 Normal Termination
    </output></pre>

    <h6>CASE 3:</h6>
    <p>If an exception rised at statement two and corresponding catch block not matched</p>
    <pre><output>
        1, Abnormal Termination
    </output></pre>

    <h6>CASE 4:</h6>
    <p>If an exception rised at statement four or statement 5 then it is always abnormal termination</p>
    <pre><output>
        1, 2, 3, Abnormal Termination
    </output></pre>

    <mark>Note : 1. Within the try block if anywhere an exception rised then rest of the try block wont be executed 
        even though we handled that exception hence within the try block we have to take only risky code and length of try block 
        should be as less as possible<br>
        2. In addition to try block there may be a chance of rising an exception inside catch and finally blocks<br>
        3. If any statement which is not part of try block and rises an exception then its always abnormal termination</mark> 

    <h5>7. Methods to print exception information</h5>
    <p>Throwable class defines the following methods to print exception information</p>
    <p>Internally default exception handler will use printStackTrace() method to print exception information to the console</p>
    <table class="table table-striped">
        <thead class="thead-dark">
             <tr>
                <th>Method</th>
                <th>Printable Format</th>
            </tr>
        </thead> 
        <tbody>
            <tr>
                <td>printStackTrace()</td>
		        <td>Name of Exception : Description<br>Stack Trace</td>
            </tr> 
            <tr>
                <td>toString()</td>
                <td>Name of Exception : Description</td>
            </tr>
            <tr>
                <td>getMessage()</td>
                <td>Description</td>
            </tr> 
        </tbody>
</table>
    <pre><code>
        class Test {
            public static void main(String[] args) {
                try {
                    System.out.println(10 / 0);
                }
                catch(ArithmeticException e) {
                    e.printStackTrace();
                    System.out.println(e);
                    System.out.println(e.toString());
                    System.out.println(e.getMessage());
                }
            }
        }
    </code></pre>

    <pre><output>
        java.lang.ArithmeticException: / by zero
        at Test.main(Test.java:4)
        java.lang.ArithmeticException: / by zero
        java.lang.ArithmeticException: / by zero
        / by zero
    </output></pre>

    <h5>8. try with multiple catch blocks</h5>
    <p>The way of handling an exception is varied from exception to exception hence for every exception type
        it is highly recommended to take separate catch block i.e try with multiple catch blocks is always possible 
        and recommended to use</p>
        <table class="table table-striped">
            <thead class="thead-dark">
                 <tr>
                    <th>Worst programming practice</th>
                    <th>Best programming practice</th>
                </tr>
            </thead> 
            <tbody>
                <tr>
                    <td>
<pre><code>
try {
    Risky code
}
catch(Exception e) {
    //All type of exceptions handling here
}
</code></pre>
                    </td>
                    <td>
<pre><code>
    try {
        risky code
    }
    catch(ArithmeticException e) {
        perform alternative arithmeitc operations
    }
    catch(SQLException e) {
        use mySQL db instead of oracle db
    }
    catch(FileNotFoundException e) {
        use local file instead of remote file
    }
    catch(Exception e) {
        //default exception-handling
    }                            
</code></pre>
                    </td>
                </tr>  
            </tbody>
    </table> 

<h6>Loophole 1 : </h6>
<pre><code>
    try {
        Risky code
    }
    catch(Exception e) {

    }
    catch(ArithmeticException e) {

    }
</code></pre>
<pre><output>
    CE : Exception java.lang.ArithmeticException has already been caught
</output></pre>

<pre><code>
    try {
        Risky code
    }
    catch(ArithmeticException e) {

    }
    catch(Exception e) {

    }
</code></pre>
<pre><output>
    compiles fine
</output></pre>


<mark>If try with multiple catch blocks present then the order of catch block is very important we have to take child first and then parent o/w we will get 
    CE saying Exception xxx has already been caught</mark>

<pre><code>
    try {
        Risky code
    }
    catch(ArithmeticException e) {

    }
    catch(ArithmeticException e) {

    }
</code></pre>
<pre><output>
    CE : Exception java.lang.ArithmeticException has already been caught
</output></pre>

<mark>We cant declare two catch blocks for the same exception o/w we will get compile time error</mark>
  
    <h5>9. finally block</h5>

    <h5>10. difference between final, finally, finalize</h5>
    <h6>final</h6>
    <p>final is a modifier applicable for classes, methods and variables. If a class declared as final then we cant extend that class 
        i.e we cant create child class for that class i.e inheritance is not possible for final classes</p>
    <p>If a method is final then we cant override that method in the child class</p>
    <p>If a variable declared as final then we cant perform reassignment for that variable</p>
    <h6>finally</h6>
    <p>finally is a block always associated with a try catch to maintain cleanup code</p>
    <pre><code>
        try {
            risky code
        }
        catch(Exception e) {
            Handling code
        }
        finally {
            cleanup code
        }
    </code></pre>
    <p>The speciality of finally block is it will be executed always irrespective of whether exception is risedor not rised and whether 
        handled or not handled</p>

    <h6>finalize</h6>
    <p>finalize is a method always invoked by garbage collector just before destroying an object to 
        perform cleanup activities. Once finalize method completes immediately garbage collector destroys that object</p>
    
    <mark>Note : finally block is responsible to perform cleanup activities related to try block i.e whatever resources we opened as a part of 
        try block will be closed inside finally block<br>whereas finalize method is responsible to perform cleanup activities related to object i.e 
        whatever resources associated with the object will be deallocated before destroying an object by using finalize method</mark>

    <h5>11. control flow in try-catch-finally</h5>
    <h5>12. control flow in nested try-catch-finally</h5>
    <h5>13. various possible combinations of try catch finally</h5>
    <p>1. In try catch finally order is important</p>
    <p>2. Whenever we are writing try, compulsory we should write either catch or finally o/w we will get CE i.e try w/o catch 
        or finally is invalid</p>
    <p>3. Whenever we are writing catch block compulsory try block must be required i.e catch w/o try is invalid</p>
    <p>4. Whenever we are writing finally block compulsory we should write try block i.e finally w/o try is invalid</p>
    <p>5. Inside try, catch and finally blocks we can declare try, catch and finally blocks i.e nesting of try catch finally is allowed</p>
    <p>6. For try catch and finally blocks curly braces are mandatory</p>

    <p>Example 1: </p>
    <pre><code>
        try {
            
        }
        catch(x e) {

        }
    </code></pre>
    <pre><output>
        valid
    </output></pre>
    <p>Example 2: </p>
    <pre><code>
        try {
            
        }
        catch(x e) {

        }
        catch(y e) {

        }
    </code></pre>
    <pre><output>
        valid
    </output></pre>
    <p>Example 3: </p>
    <pre><code>
        try {
            
        }
        catch(x e) {

        }
        catch(x e) {

        }
    </code></pre>
    <pre><output>
        CE : Exception x has already been caught
    </output></pre>
    <p>Example 4: </p>
    <pre><code>
        try {
            
        }
        catch(x e) {

        }
        finally {

        }
    </code></pre>
    <pre><output>
        valid
    </output></pre>
    <p>Example 5: </p>
    <pre><code>
        try {
            
        }
        finally {

        }
    </code></pre>
    <pre><output>
        valid
    </output></pre>
    <p>Example 6: </p>
    <pre><code>
        try {
            
        }
        catch(x e) {

        }
        try {

        }
        catch(y e) {

        }
    </code></pre>
    <pre><output>
        valid
    </output></pre>
    <p>Example 7: </p>
    <pre><code>
        try {
            
        }
        catch(x, e) {

        }
        try {

        }
        finally {

        }
    </code></pre>
    <pre><output>
        valid
    </output></pre>
    <p>Example 8: </p>
    <pre><code>
        try {
            
        }
    </code></pre>
    <pre><output>
        CE : try without catch or finally
    </output></pre>
    <p>Example 9: </p>
    <pre><code>
        catch(x e) {

        }
    </code></pre>
    <pre><output>
        CE: catch without try
    </output></pre>
    <p>Example 10: </p>
    <pre><code>
        finally {

        }
    </code></pre>
    <pre><output>
        CE : finally without try
    </output></pre>
    <p>Example 11: </p>
    <pre><code>
        try {
            
        }
        finally {

        }
        catch(x e) {

        }
    </code></pre>
    <pre><output>
        CE : catch without try
    </output></pre>
    <p>Example 12: </p>
    <pre><code>
        try {
            
        }
        SOP("Hello");
        catch(x e) {

        }
    </code></pre>
    <pre><output>
        CE : 1 try without catch or finally
        C E: 2 catch without try
    </output></pre>
    <p>Example 13: </p>
    <pre><code>
        try {
            
        }
        catch(x, e) {

        }
        SOP("Hello")
        catch(x e) {

        }
    </code></pre>
    <pre><output>
        CE : catch without try
    </output></pre>
    <p>Example 14: </p>
    <pre><code>
        try {
            
        }
        catch(x, e) {

        }
        SOP("Hello");
        finally {

        }
    </code></pre>
    <pre><output>
        CE : finally without try
    </output></pre>
    <p>Example 15: </p>
    <pre><code>
        try {
            try {

            }
            catch(x e) {

            }
        }
        catch(x, e) {

        }
    </code></pre>
    <pre><output>
        valid
    </output></pre>
    <p>Example 16: </p>
    <pre><code>
        try {
            try {

            }
        }
        catch(x, e) {

        }
    </code></pre>
    <pre><output>
        CE : try without catch or finally
    </output></pre>

    <p>Example 17: </p>
    <pre><code>
        try {
            try {

            }
            finally {

            }
        }
        catch(x, e) {

        }
    </code></pre>
    <pre><output>
        valid
    </output></pre>
    <p>Example 18: </p>
    <pre><code>
        try {
            
        }
        catch(x, e) {
            try {

            }
            finally {

            }
        }
    </code></pre>
    <pre><output>
        valid
    </output></pre>
    <p>Example 19: </p>
    <pre><code>
        try {
            
        }
        catch(x, e) {
            finally {

            }
        }
    </code></pre>
    <pre><output>
        CE : finally without try
    </output></pre>
    <p>Example 20: </p>
    <pre><code>
        try {
            
        }
        catch(x, e) {

        }
        finally {
            try {

            }
            catch(x e) {

            }
        }
    </code></pre>
    <pre><output>
    </output></pre>
    <p>Example 21: </p>
    <pre><code>
        try {
            
        }
        catch(x, e) {

        }
        finally {
            finally {

            }
        }
    </code></pre>
    <pre><output>
        CE : finally without try
    </output></pre>
    <p>Example 22: </p>
    <pre><code>
        try {
            
        }
        catch(x, e) {

        }
        finally {

        }
        finally {

        }
    </code></pre>
    <pre><output>
        CE : finally without try
    </output></pre>
    <p>Example 23: </p>
    <pre><code>
        try 
            SOP("try");
        catch(x, e) {
            SOP("catch");
        }
        finally {

        }
    </code></pre>
    <pre><output>
        Test.java:3: error: '{' expected
        try
           ^
Test.java:6: error: 'catch' without 'try'
        catch(Exception e) {
        ^
Test.java:9: error: 'finally' without 'try'
        finally {
        ^
Test.java:3: error: 'try' without 'catch', 'finally' or resource declarations
        try
        ^
Test.java:12: error: reached end of file while parsing
}
 ^
5 errors

    </output></pre>
    <p>Example 24: </p>
    <pre><code>
        try {
            
        }
        catch(x, e) 
            SOP("catch");
        finally {

        }
    </code></pre>
    <pre><output>
        Test.java:6: error: '{' expected
        catch(Exception e)
                          ^
Test.java:9: error: 'finally' without 'try'
        finally {
        ^
Test.java:12: error: reached end of file while parsing
}
 ^
3 errors
    </output></pre>
    <p>Example 25: </p>
    <pre><code>
        try {
            
        }
        catch(x, e) {

        }
        finally
            SOP("finally");
    </code></pre>
    <pre><output>
        Test.java:9: error: '{' expected
        finally
               ^
Test.java:12: error: reached end of file while parsing
}
 ^
2 errors

    </output></pre>

    <h5>14. throw keyword</h5>
    <img src="images/ss65.png" alt="ss65" width="400" height="300">
    <p>Sometimes we can create exception object explicitly and we can handover to the JVM manually. For this we have to use throw keyword. 
        Hence the main objective of throw keyword is to handover our created exception object to the JVM manually.
        Hence the result of following two programs is exactly same.
    </p>
    <pre><code>
        throw new ArithmeticException("/ by zero");
    </code></pre>
    <img src="images/ss66.png" alt="ss12" width="400" height="300">

    <table class="table table-striped">
        <thead class="thead-dark">
             <tr>
                <th>Without throw keyword</th>
                <th>With throw keyword</th>
            </tr>
        </thead> 
        <tbody>
            <tr>
                <td>
<pre><code>
    class Test {
        public static void main(String[] args) {
            SOP(10 / 0);
        }    
    }                        
</code></pre>
<pre><output>
    CE : Exception in thread "main" java.lang.ArithmeticException: / by zero
	at Test.main
</output></pre>
                </td>
		        <td>
<pre><code>
    class Test {
        public static void main(String[] args) {
            throw new ArithmeticException("/ by zero explicitly");
        }    
    }                        
</code></pre>
<pre><output>
    CE : Exception in thread "main" java.lang.ArithmeticException: / by zero explicitly
	at Test.main
</output></pre>
                </td>
            </tr>  
<tr>
    <td>
        In this case main method is responsible to create exception object and handover to the JVM               
    </td>
    <td>
        In this case programmer creating exception object explicitly and handover to the JVM manually               
    </td>
</tr>
        </tbody>
</table>

<mark>Note : Best use of throw keyword is for user defined exceptions or customized exceptions</mark> 

<h6>case 1:</h6>
<p>throw e; If e refers null then we will get NullPointerException</p>

 
<table class="table table-striped">
    <tbody>
    <tr>
    <td>
        <pre><code>
            class Test {
                static ArithmeticException e  = new ArithmeticException();
                public static void main(String[] args) {
                    throw e;
                }
            }
        </code></pre>
        
        <pre><output>
            RE : Exception in thread "main" java.lang.ArithmeticException
            at java.Test.<clinit>
        </output></pre>
    </td>
    <td>
        <pre><code>
            class Test {
                static ArithmeticException e;
                public static void main(String[] args) {
                    throw e;
                }
            }
        </code></pre>
        
        <pre><output>
            RE : Exception in thread "main" java.lang.NullPointerException
            at java.Test.main
        </output></pre>
    </td>
    </tr>  
    </tbody>
</table>

<h6>Case 2 : </h6>

<table class="table table-striped">
<tbody>
<tr>
    <td>
<pre><code>
    class Test {
        public static void main(String[] args) {
            SOP(10 / 0);
            SOP("Hello");
        }
}
</code></pre>
        
<pre><output>
    RE : Exception in thread "main" java.lang.ArithmeticException: / by zero
    at java.Test.main
</output></pre>
    </td>
<td>
<pre><code>
    class Test {
        public static void main(String[] args) {
            throw new ArithmeticException("/ by zero");
            SOP("Hello");
        }
    }
</code></pre>
    
<pre><output>
    CE : unreachable statement
</output></pre>
</td>
</tr>
</tbody>
</table>

<mark>After throw statement, we are not allowed to write any statement directly o/w we will get CE saying 
    unreachable statement</mark>

<h6>Case 3: </h6>
<p>We can use throw keyword only for Throwable types. If we are trying to use for normal java objects we will get CE 
    saying incompatible types
</p>
<table class="table table-striped">
    <tbody>
    <tr>
        <td>
<pre><code>
    class Test {
        public static void main(String[] args) {
            throw new Test();
        }
    }
</code></pre>

<pre><output>
    CE : incompatible types: Test cannot be converted to Throwable
</output></pre>
        </td>
        <td>
<pre><code>
    class Test extends RunTimeException {
        public static void main(String[] args) {
            throw new Test();
        }
    }
</code></pre>

<pre><output>
    RE : Exception in thread "main" Test
	at Test.main(Test.java:5)
</output></pre>
        </td>
    </tr>  
    </tbody>
</table>

    <h5>15. throws keyword</h5>
    <p>In our program if there is a possibility of rising checked exception then compulsory we should 
        handle that checked exception o/w we will get CE saying unreported exception xxx; must be caught or declared to be thrown
    <p>Example 1:</p>
    <pre><code>
        package com.cts.java;
            import java.io.PrintWriter;
            class Test {
                public static void main(String[] args) {
                    PrintWriter out = new PrintWriter("abc.txt");
                    out.println("Hello");
                }
            }
    </code></pre>
    
    <pre><output>
        CE : unreported exception java.io.FileNotFoundException; 
        must be caught or declared to be thrown
    </output></pre>

    <p>Example 2 : </p>
    <pre><code>
            class Test {
                public static void main(String[] args) {
                    Thread.sleep(1000);
                }
            }
    </code></pre>
    
    <pre><output>
        CE : unreported exception java.lang.InterruptedException; 
        must be caught or declared to be thrown
    </output></pre>

<p>We can handle this CE by using the following two ways</p>
<p>1. By using try catch</p>
<pre><code>
    class Test {
        public static void main(String[] args) {
            try {
                Thread.sleep(10000);
            }
            catch(InterruptedException e) {

            }
        }
    }
</code></pre>

<p>2. By using throws keyword</p>
<pre><code>
    class Test {
        public static void main(String[] args) throws InterruptedException {
            Thread.sleep(1000);
        }
    }
</code></pre>

<p>We can use throws keyword to delegate responsibility of exception handling to the caller(it may 
    be another method or JVM) then caller method is responsible to handle that exception</p>
    <pre><code>
        class Test {
            public static void main(String[] args) throws InterruptedException {
                Thread.sleep(1000);
            }
        }
    </code></pre>

    <pre><code>
        class Test {
            public static void main(String[] args) {
                doStuff();
            }
        
            private static void doStuff() {
                doMoreStuff();
            }
        
            private static void doMoreStuff() {
                Thread.sleep(3000);
                
            }
            
        }
    </code></pre>
    
    <pre><output>
        unreported exception InterruptedException; must be caught or declared to be thrown
        Thread.sleep(30000);
    </output></pre>

    <pre><code>
        class Test {
            public static void main(String[] args) {
                doStuff();
            }
        
            private static void doStuff() {
                doMoreStuff();
            }
        
            private static void doMoreStuff() throws InterruptedException {
                Thread.sleep(3000);
                
            }
            
        }
    </code></pre>
    
    <pre><output>
        unreported exception InterruptedException; must be caught or declared to be thrown
                doMoreStuff();
    </output></pre>

    <pre><code>
        class Test {
            public static void main(String[] args) {
                doStuff();
            }
        
            private static void doStuff() throws InterruptedException {
                doMoreStuff();
            }
        
            private static void doMoreStuff() throws InterruptedException {
                Thread.sleep(3000);
                
            }
            
        }
    </code></pre>
    
    <pre><output>
        unreported exception InterruptedException; must be caught or declared to be thrown
                doStuff();
    </output></pre>

    <pre><code>
        class Test {
            public static void main(String[] args) throws InterruptedException {
                doStuff();
            }
        
            private static void doStuff() throws InterruptedException {
                doMoreStuff();
            }
        
            private static void doMoreStuff() throws InterruptedException {
                Thread.sleep(3000);
                
            }
            
        }
    </code></pre>
    
    <pre><output>
        compiles fine and runs fine
    </output></pre>

    <p>In the above program if we remove atleast one throws statement then the code wont compile</p>

    <pre><code>
        class Test {
            public static void main(String[] args) throws InterruptedException{
                doStuff();
            }
        
            private static void doStuff() {
                doMoreStuff();
            }
        
            private static void doMoreStuff() {
                Thread.sleep(3000);
                
            }
            
        }
    </code></pre>
    
    <pre><output>
        unreported exception InterruptedException; must be caught or declared to be thrown
        Thread.sleep(30000);
    </output></pre>

    <pre><code>
        class Test {
            public static void main(String[] args) throws InterruptedException {
                doStuff();
            }
        
            private static void doStuff() {
                doMoreStuff();
            }
        
            private static void doMoreStuff() throws InterruptedException {
                Thread.sleep(3000);
                
            }
            
        }
    </code></pre>
    
    <pre><output>
        unreported exception InterruptedException; must be caught or declared to be thrown
        doMoreStuff();
    </output></pre>

    <h6>Conclusions</h6>
<p>1. Throws keyword required only for checked exceptions and usage of throws keyword for unchecked exceptions 
    there is no use or there is no impact.
</p>
<p>2. Throws keyword required only to convince compiler and usage of throws keyword doesnt prevent abnormal termination of 
    the program.</p>
<p>3. Throws clause we can use to delegate responsibility of exception handling to the caller(It may be method or JVM)
    
<mark>Note : It is recommended to use try catch over throws keyword</mark>

<h6>Case 1 :</h6>
<pre><code>
    class Test throws Exception {
        Test() throws Exception {

        }
        public void m1() throws Exception {

        }
    }
</code></pre>

<pre><output>
    CE : '{' expected  
</output></pre>

<p>We can use throws keyword for methods and constructore but not for classes</p>

<h6>Case 2 : </h6>
<pre><code>
    class Test {
        public void m1() throws Test {
             
        }
    }
</code></pre>

<pre><output>
    CE : incompatible types
    found : Test  
    required : java.lang.Throwable
</output></pre>

<pre><code>
    class Test extends RunTimeException{
        public void m1() throws Test {
             
        }
    }
</code></pre>

<pre><output>
    valid
</output></pre>

<p>We can use throws keyword only for Throwable types. If we are trying to use for normal java classes then 
    we will get CE saying incompatible types</p>

<h6>Case 3 : </h6>
<pre><code>
    class Test {
        public static void main(String[] args) {
            throw new Exception();  //Exception is checked
        }
    }
</code></pre>
    CE : unreported exception java.lang.Exception; 
    must be caught or declared to be thrown
<pre><output>

</output></pre>
<pre><code>
    class Test {
        public static void main(String[] args) {
            throw new Error();  //Error is checked
        }
    }
</code></pre>

<pre><output>
    RE : Exception in thread "main" java.lang.Error 
    at Test.main
</output></pre>

<h6>Case 4 :</h6>
<p>Example 1 :</p>
<pre><code>
    class Test {
        public static void main(String[] args) {
            try {
                SOP("Hello");
            }
            catch(ArithmeticException e) {

            }
        }
    }
</code></pre>

<pre><output>
    Hello
</output></pre>
<p>Example 2 :</p>
<pre><code>
    class Test {
        public static void main(String[] args) {
            try {
                SOP("Hello");
            }
            catch(Exception e) {
                
            }
        }
    }
</code></pre>

<pre><output>
    Hello
</output></pre>
<p>Example 3 :</p>
<pre><code>
    import java.io.*;
    class Test {
        public static void main(String[] args) {
            try {
                SOP("Hello");
            }
            catch(IOException e) {
                
            }
        }
    }
</code></pre>

<pre><output>
    CE :  exception IOException is never thrown in body of corresponding try statement
</output></pre>
<p>Example 4 :</p>
<pre><code>
    class Test {
        public static void main(String[] args) {
            try {
                SOP("Hello");
            }
            catch(InterruptedException e) {
                
            }
        }
    }
</code></pre>

<pre><output>
    CE : exception InterruptedException is never thrown in body of corresponding try statement
</output></pre>
<p>Example 5 :</p>
<pre><code>
    class Test {
        public static void main(String[] args) {
            try {
                SOP("Hello");
            }
            catch(Error e) {
                
            }
        }
    }
</code></pre>

<pre><output>
    Hello
</output></pre>

<mark>Within the try block if there is no chance of rising an exception then we cant write catch block for that 
    exception o/w we will get CE saying exception xxx is never thrown in body of corresponding try statement. But this rule is applicable 
    only for fully checked exceptions
</mark>

    <h5>16. Exception handling keywords summary</h5>
    <h6>try</h6>
    <p>To maintain risky code</p>
    <h6>catch</h6>
    <p>To maintain exception handling code</p>
    <h6>finally</h6>
    <p>To maintain cleanup code</p>
    <h6>throw</h6>
    <p>To handover our created exception object to the JVM manually</p>
    <h6>throws</h6>
    <p>To delegate the responsibility of exception handling to the caller</p>


    <h5>17. Various possible compile time errors in exception handling</h5>
    <p>1. unreported exception xxx; must be caught or declared to be thrown
</p>
    <p>2. Exception xxx has already been caught</p>
    <p>3. Exception xxx is never thrown in body of corresponding try statement</p>
    <p>4. unreachable statement</p>
    <p>5. incompatible types
        found : Test 
        required : java.lang.Throwable</p>
    <p>6. try without catch or finally</p>
    <p>7. catch without try</p>
    <p>8. finally without try</p>
    
    
    
    <h5>18. Customized or user defined exceptions</h5>
    <p>Sometimes to meet programming requirements we can define our own exceptions such type of exceptions are called 
        customized or user defined exceptions</p>

    <p>Example TooYoungException, TooOldException and InsufficientFundsException</p>

    <pre><code>
        class TooYoungException extends RuntimeException {
            public TooYoungException(String s) {
                super(s); //To make description available to default exception handler
            }
        }
        
        class TooOldException extends RuntimeException {
            TooOldException(String s) {
                super(s);
            }
        }
        
        public class CustException {
        
            public static void main(String[] args) {
                int age = Integer.parseInt(args[0]);
                if(age > 60) {
                    throw new TooOldException("Your age is already crossed marriage age.. no chance of getting marriage");
                }
                else if(age < 18) {
                    throw new TooYoungException("plz wait some more time...you will get best match soon");
                }
                else {
                    System.out.println("You will get match details soon by email...!");
                }
            }
        
        }
    </code></pre>
    
    <pre><output>
        javac CustException.java
        java CustException 61 
        CE : Exception in thread "main" TooOldException: Your age is already crossed marriage age.. no chance of getting marriage
        at CustException.main
        java CustException 17 
        CE : Exception in thread "main" TooYoungException: plz wait some more time...you will get best match soon
        at CustException.main
        java CustException 21
        You will get match details soon by email...!
    </output></pre>

    <img src="images/ss67.png" alt="ss12" width="400" height="600"><br><br>

    <mark>Note 1: Throw keyword is best suitable for user defined or customized exceptions but not for predefined exceptions<br>
    2. It is highly recommended to define customized exceptions as unchecked i.e we have to extends RuntimeException but not Exception</mark>

    <h5>19. Top-10 exceptions</h5>
    <p>Based on the person who is rising an exception all exceptions are divided into two categories </p>
    <p>1. JVM exceptions</p>
    <p>2. Programmatic exceptions</p>

    <h6>JVM exceptions</h6>
    <p>The exceptions which are rised automatically by JVM whenever a particular event occurs are called JVM exceptions</p>
    <p>Example : ArithmeticException, NullPointerException etc</p>

    <h6>Programmatic exceptions</h6>
    <p>The exceptions which are rised explicitly either by programmer or by API developer to indicate that something goes wrong are called Programmatic exceptions</p>
    <p>Example : TooOldException, IllegalArgumentException etc</p>

    <h6>1. ArrayIndexOutOfBoundsException</h6>
    <p>It is the child class of RuntimeException and hence it is unchecked</p>
    <p>Rised automatically by JVM whenever we are trying to access array element with out of range index</p>
    <p>Example</p>
    <pre><code>
        int[] x = new int[4];
        SOP(x[0]);
        SOP(x[10]); //RE : ArrayIndexOutOfBoundsException
        SOP(x[-10]);   //RE : ArrayIndexOutOfBoundsException
    </code></pre>

    <h6>2. NullPointerException</h6>
    <p>It is the child class of RuntimeException and hence it is unchecked</p>
    <p>Rise automatically by JVM whenever we are trying to perform any operation on null</p>
    <pre><code>
        String s = null; 
        SOP(s.length());
    </code></pre>

    <pre><output>
        NullPointerException
    </output></pre>

    <h6>3. ClassCastException</h6>
    <p>It is the child class of RuntimeException and hence it is unchecked</p>
    <p>Rise automatically by JVM whenever we are trying to typecast parent object to child type</p>
    <pre><code>
        String s = new String("durga");
        Object o = (Object)s;
    </code></pre>
    <pre><output>
        valid
    </output></pre>
    <pre><code>
        Object o = new Object();
        String s = (String)o;
        
    </code></pre>
    <pre><output>
        RE : ClassCastException
    </output></pre>
    <pre><code>
        Object o = new String("durga");
        String s = (String)o;
    </code></pre>
    <pre><output>
        valid
    </output></pre> 
    
    <h6>4. StackOverflowError</h6>
    <p>It is the child class of Error and hence it is unchecked</p>
    <p>Rise automatically by JVM whenever we are trying to perform recursive method call</p>
    <pre><code>
        class Test {
            public static void m1() {
                m2();
            }
            public static void m2() {
                m1();
            }
            public static void main(String[] args) {
                m1();
            }
        }
    </code></pre>
    
    <pre><output>
        RE : StackOverflowError
    </output></pre>

    <h6>5. NoClassDefFoundError</h6>
    <p>It is the child class of Error and hence it is unchecked</p>
    <p>Rised automatically by JVM whenever JVM unable to find required .class file</p>
    <p>Example</p>
    <p>java Test</p>
    <p>If Test.class file is not available then we will get RunTimeException saying NoClassDefFoundError : Test</p>

    <h6>6. ExceptionInInitializerError</h6>
    <p>It is the child class of Error and hence it is unchecked</p>
    <p>Rise automatically by JVM if any exception occurs while executing static variable assignments and static blocks</p>
    <pre><code>
        class Test {
            static int x = 10 / 0;
        }
    </code></pre>
    
    <pre><output>
        RE : ExceptionInInitializerError
        caused by java.lang.ArithmeticException : / by zero
    </output></pre>

    <pre><code>
        class Test {
            static {
                String s = null;
                SOP(s.length());
            }
        }
    </code></pre>
    
    <pre><output>
        RE : ExceptionInInitializerError
        caused by : java.lang.NullPointerException
    </output></pre>

    <h6>7. IllegalArgumentException</h6>
    <p>It is the child class of RunTimeException and hence it is unchecked</p>
    <p>Rised explicitly either by programmer or by API developer to indcate that a method has been invoked with Illegal Argument</p>
    <p>Example : The valid range of thread prioprity is 1 - 10 if we are trying to set the priority with any other value the we will get RE saying IllegalArgumentException</p>
    <p>Example</p>
    <pre><code>
        Thread t = new Thread();
        t.setPriority(7);   &#10004
        t.setPriority(15);  //RE
    </code></pre>
    
    <pre><output>
        RE : IllegalArgumentException
    </output></pre>

    <h6>8. NumberFormatException</h6>
    <p>It is the direct child class of IllegalArgumentException which is the child class of RunTimeException and 
        hence it is unchecked
    </p>
    <p>Rised explicitly either by programmer or by API developer to indicate that we are trying to convert String to Number and the 
        String is not properly formated</p>
    <pre><code>
        int i = Integer.parseInt("10"); &#10004
        int i = Integer.parseInt("ten");    //RE
    </code></pre>
    
    <pre><output>
        RE : NumberFormatException
    </output></pre>

    <h6>9. IllegalStateException</h6>
    <p>It is the child class of RuntimeException and hence it is unchecked</p>
    <p>Rised explicitly either by programmer or by API developer to indicate that a method has been invoked at 
        wrong time</p>

    <p>Example : After starting of a thread we are not allowed to restart the same thread once again o/w we will get RE saying 
        IllegalThreadStateException</p>
        <pre><code>
            Thread t = new Thread(); 
            t.start();
                . 
                . 
                . 
            t.start();
        </code></pre>
        
        <pre><output>
            RE : IllegalThreadStateException
        </output></pre>

    <h6>10. AssertionError</h6>
    <p>It is the child class of Error and hence it is unchecked</p>
    <p>Rised explicitly by the programmer or by API developer to indicate that assert statement fails</p>
    <pre><code>
        assert(x > 10);
    </code></pre>
    
    <pre><output>
        RE : AssertionError
    </output></pre>
    <p>If x is not greater than 10 then we will get RE saying AssertionError

        <table class="table table-striped">
            <thead class="thead-dark">
                 <tr>
                    <th>Exception/Error</th>
                    <th>Raised by</th>
                </tr>
            </thead> 
            <tbody>
            <tr>
            <td>ArrayIndexOutOfBoundsException</td>
            <td>Raised automatically by JVM and hence these are JVM exceptions</td>
        </tr> 
        <tr>
            <td>NullPointerException</td>
            <td>Raised automatically by JVM and hence these are JVM exceptions</td>
        </tr> 
        <tr>
            <td>ClassCastException</td>
            <td>Raised automatically by JVM and hence these are JVM exceptions</td>
        </tr>
        <tr>
            <td>StackOverflowError</td>
            <td>Raised automatically by JVM and hence these are JVM exceptions</td>
        </tr>
        <tr>
            <td>NoClassDefFoundError</td>
            <td>Raised automatically by JVM and hence these are JVM exceptions</td>
        </tr>
        <tr>
            <td>ExceptionInInitializerError</td>
            <td>Raised automatically by JVM and hence these are JVM exceptions</td>
        </tr>
        <tr>
            <td>IllegalArgumentException</td>
            <td>Raise explicitly either by programmer or API developer and hence these are Programmatic exceptions</td>
        </tr>
        <tr>
            <td>NumberFormatException</td>
            <td>Raise explicitly either by programmer or API developer and hence these are Programmatic exceptions</td>
        </tr>
        <tr>
            <td>IllegalStateException</td>
            <td>Raise explicitly either by programmer or API developer and hence these are Programmatic exceptions</td>
        </tr>
        <tr>
            <td>AssertionError</td>
            <td>Raise explicitly either by programmer or API developer and hence these are Programmatic exceptions</td>
        </tr>
            </tbody>
    </table>

    <h5>20. 1.7v enhancements</h5>
    <p>As a part of 1.7v in exception handling the following two concepts introduced.</p>
    <h6>1. try with resources</h6>
    <table class="table table-striped">
        <thead class="thead-dark">
             <tr>
                <th>1.6v</th>
                <th>1.7v</th>
            </tr>
        </thead> 
        <tbody>
        <tr>
		    <td>
<pre><code>
    BufferedReader br = null;
    try {
        br = new BufferedReader(new FileReader("input.txt"))
        //Use br based on our requirement
    }
    catch(IOException e) {
        //Handling code
    }
    finally {
        if(br != null) {
            br.close();
        }
    }
</code></pre>
    
            </td>
		    <td>
<pre><code>
    try(BufferedReader br = new BufferedReader(new FileReader(input.txt))) {
        //Use br based on our requirement, br will be closed automatically once 
        control reaches end of the block either normally or abnormally and we 
        are not responsible to close explicitly 
    }
    catch(IOException e) {
        //Handling code
    }
</code></pre>

            </td>
        </tr>  
        </tbody>
</table>

<mark>Until 1.6v it is highly recommended to write finally block to close resources which are 
    open as a part of try block</mark>
<p>The problems in this approach are<br>1. Compulsory is required to close the resources inside finally block 
    It increases complexity of programming.<br>2. We have to write finally block compulsory and hence it increases length 
    of the code and reduces readibility. </p>
    <p>To overcome this problem SUN people introduced try with resources in 1.7v</p>
    <p>The main advantage of try with resources is whatever resources we open as a part of try block will be closed 
        automatically once control reaches end of try block either normally or abnormally and hence we are not 
    required to close explicitly so that complexity of programming will be reduced</p>
<p>We are not required to write finally block so that length of the code will be reduced and readibility will be improved</p> 

<p>We can declare multiple resources but these resources should be separated with semicolon</p>
<p>Syntax</p>
<pre><code>
    try(R1; R2; R3) {

    }
</code></pre>

<pre><code>
    try(FileWriter fw  = new FileWriter("output.txt"); FileReader fr = new FileReader("input.txt")) {

    }
</code></pre>

<mark>All resources should be AutoCloseable resources.</mark>
<p>A resource is said to be AutoCloseable iff the corresponding class implements 
    java.lang.AutoCloseable interface. </p>
    <p>All IO related resources, database related resources, and network related resources are already implemented 
        AutoCloseable interface. Being a programmer we are not required to do anything just we should aware the point
    </p>
    <p>AutoCloseable interface came in 1.7v and it contains only one method public void close()</p>

<p>All resource reference variables are implicitly final and hence within the try block we cant perform reassignment o/w we will get CE</p>
<pre><code>
import java.io.BufferedReader;
import java.io.FileReader;
class Test {
	public static void main(String[] args) throws Exception {
		try (BufferedReader br = new BufferedReader(new FileReader("input.txt"))) {
			br = new BufferedReader(new FileReader("output.txt"));
		}
	}
}
</code></pre>

<pre><output>
    CE :  auto-closeable resource br may not be assigned
</output></pre>

<p>Until 1.6v try should be associated with either catch or finally but from 1.7v onwards, we can take only try with resource without catch or finally</p>
<pre><code>
    try(R) {
        - 
        - 
        -
    }
</code></pre>

<pre><output>
    valid
</output></pre>   

<p>The main advantage of try-with-resources is we are not required to write finally block explicitly because we are not required to close 
    resources explicitly hence until 1.6v finaly block is just like hero but from 1.7v onwards it is dummy and becomes zero</p>


<h6>2. muti-catch block</h6>
<mark>Until 1.6v even though multiple different exceptions having same handling code for every exception type 
    we have to write a separate catch block. It increases length of the code and reduces readibility.
</mark>
<pre><code>
    import java.io.IOException;
    import java.io.PrintWriter;
    
    class Test {
        public static void main(String[] args) {
            try {
                PrintWriter pw = new PrintWriter("abc.txt");
                Thread.sleep(3000);
            }
            catch(ArithmeticException e) {
                e.printStackTrace();
            }
            catch(IOException e) {
                e.printStackTrace();
            }
            catch(NullPointerException e) {
                System.out.println(e.getMessage());
            }
            catch(InterruptedException e) {
                System.out.println(e.getMessage());
            }
        }
    }
</code></pre>

<mark>To overcome this problem SUN people introduced multi catch block in 1.7v according to this 
    we can write a single catch block that can handle multiple different types of exceptions</mark>
<pre><code>
import java.io.IOException;
import java.io.PrintWriter;

class Test {
	public static void main(String[] args) {
		try {
			PrintWriter pw = new PrintWriter("abc.txt");
			Thread.sleep(3000);
	    }
	    catch(ArithmeticException | IOException e) {
	        e.printStackTrace();
	    }
	  
	    catch(NullPointerException | InterruptedException e) {
	        System.out.println(e.getMessage());
	    }
	}
}
</code></pre>

<mark>The main advantage of this approach is length of the code will be reduced and readibility will be improved</mark>
<pre><code>
    class Test {
        public static void main(String[] args) {
            try {
                System.out.println(10 / 0);
                String s = null;
                System.out.println(s.length());
            }
            catch(ArithmeticException | NullPointerException e) {
                e.printStackTrace();
            }
        }
    }
</code></pre>

<pre><output>
    java.lang.ArithmeticException: / by zero
	at Test.main
</output></pre>

<pre><code>
    class Test {
        public static void main(String[] args) {
            try {
                //System.out.println(10 / 0);
                String s = null;
                System.out.println(s.length());
            }
            catch(ArithmeticException | NullPointerException e) {
                e.printStackTrace();
            }
        }
    }
</code></pre>

<pre><output>
    java.lang.NullPointerException
	at Test.main
</output></pre>

<p>In the above example whether raised exception is either ArithmeticException or NullPointerException 
    the same catch block can listen.</p>

<p>In multi-catch block there should not be any relation between exception types(either child to parent or parent to child or same type) 
    o/w we will get CE</p>

    <pre><code>
        class Test {
            public static void main(String[] args) {
                try {
                    //System.out.println(10 / 0);
                    String s = null;
                    System.out.println(s.length());
                }
                catch(ArithmeticException | Exception e) {
                    e.printStackTrace();
                }
            }
        }
    </code></pre>
    
    <pre><output>
        CE : Alternatives in a multi-catch statement cannot be related by subclassing
        catch(ArithmeticException | Exception e) {
                                    ^
Alternative ArithmeticException is a subclass of alternative Exception
1 error

    </output></pre>

    <h5>Exception Propagation</h5>
    <p>Inside a method if an exception raised and if we are not handling that exception then exception object will be propagated to caller. 
        Then caller method is responsible to handle exception. This process is called exception Propagation</p>

    <h6>Rethrowing Exception</h6>
    <p>We can use this approach to convert one exception type to another exception type</p>
    <pre><code>
        try {
            SOP(10 / 0);
        }
        catch(ArithmeticException e) {
            throw new NullPointerException();
        }
    </code></pre>


    <h5>1. Introduction</h5>
    <h6>Multitasking</h6>
    <p>Executing several tasks simultaneously is the concept of Multitasking</p>
    <p>There are two types of Multitasking</p>
    <p>1. Process based multitasking</p>
    <p>2. Thread based multitasking</p>

    <h6>Process Based multitasking</h6>
    <p>Executing several tasks simultaneously where each task is a separate independent program(process), 
        is called process based multitasking</p>
    <p>Example : While typing a java program in the editor we can listen audio songs from the same system. At  
        the same time we can download a file from net. All these tasks will be executed simultaneously and independent 
        of each other. Hence it is process based multitasking
    </p>
    <p>Process based multitasking is best suitable at OS level</p>

    <h6>Thread based multitasking</h6>
    <p>Executing several tasks simultaneously where each task is a separate independent part of the same program is called thread 
        based multitasking and each independent part is called a thread.</p>
    <p>Thread based multitasking is best suitable at programmatic level</p>

    <mark>Whether it is process based or thread based the main objective of multitasking is to reduce response time 
        of the system and improve performance</mark>
    
    <p>The main important application areas of multithreading are</p>
    <p>1. To develop multimedia graphics</p>
    <p>2. To develop animations</p>
    <p>3. To develop video games</p>
    <p>4. To develop web servers and application servers etc</p>
    
    <mark>When compared with old languages, developing multithreaded applications in java is very easy because 
        java provides inbuilt support for multithreading with rich API[Thread, Runnable, ThreadGroup...]</mark>

        <h5>2. The ways to define a Thread</h5>
    <h6>Defining a thread</h6>
    <p>We can define a thread in the following two ways</p>
    <p>1. By extending Thread class</p>
    <p>2. By implementing Runnable(I)</p>

    <h6>1. By extending Thread class</h6>
    <pre><code>
        public class MyThread extends Thread {
            public void run() {
                for (int i = 0; i < 10; i++) {
                    System.out.println("Child Thread");
                }
            }
        }
        public class ThreadDemo {
            public static void main(String[] args) {
                MyThread t = new MyThread();
                t.start();
                for (int i = 0; i < 10; i++) {
                    System.out.println("Main Thread");
                }
            }
        }
        
    </code></pre>
    
    <pre><output>
    </output></pre>
    <img src="images/ss68.png" alt="ss12" width="400" height="300">
    <img src="images/ss69.png" alt="ss12" width="400" height="300">

    <h6>Case 1 : Thread scheduler</h6>
    <p>It is the part of JVM. It is responsible to schedule threads i.e if multiple threads are waiting 
        to get the chance of execution then in which order threads will be executed is decided by thread scheduler</p>
    </p>
    <p>We cant expect exact algorithm followed  by thread scheduler, it is varied from JVM to JVM. Hence we cant expect threads execution
        order and exact output.</p>
    <p>Hence whenever situation comes to multithreading there is no guarantee for exact output but we can 
        provide several possible outputs</p> 

    <p>The following are various possible outputs for the above program</p>
    <p>Output - 1</p>
    
    <pre><output>
        Main thread 
        Main thread
            . 
            . 
            . 
            . (10 times)
        Child thread 
        Child thread 
            . 
            . 
            . 
            . (10 times)
    </output></pre>
    <p>Output - 2</p>

    <pre><output>
        Child thread 
        Child thread 
            . 
            . 
            . 
            . (10 times)
        Main thread 
        Main thread
            . 
            . 
            . 
            . (10 times)
    </output></pre>
    <p>Output - 3</p>
    <pre><output>
        Main thread 
        Child Thread 
        Main thread 
        Child thread 
            . 
            . 
            . 
    </output></pre>
    <p>Output - 4</p>
    <pre><output>
        Child thread 
        Main Thread 
        Child thread 
            . 
            . 
            . 
    </output></pre>

    <h6>Difference between t.start() and t.run()</h6>
    <p>In the case of t.start() a new thread will be created which is responsible for the execution 
        of run() method. But in the case of t.run() a new thread wont be created and run() method will 
        be executed just like a normal method call by main thread. Hence in the above program if we replace 
        t.start() with t.run() then the output is</p>
        <pre><code>
            public class ThreadDemo {
                public static void main(String[] args) {
                    MyThread t = new MyThread();
                    t.run();
                    for (int i = 0; i < 10; i++) {
                        System.out.println("Main Thread");
                    }
                }
            }
        </code></pre>
        

        <pre><output>
            Child Thread
            Child thread 
                . 
                . 
                . (10 times)
            Main thread
            Main thread
                . 
                . 
                . (10 times)
        </output></pre> 

    <p>This total output produced by only main thread</p>
<h6>Case 3 : </h6>
<p>Importance of thread class start() method</p>
<p>Thread class start method is responsible to register the thread with thread scheduler and 
    all other mandatory activities. Hence w/o executing thread class start() method, there is no chance 
    of starting a new thread in java. Due to this thread class start() method is considered as multithreading</p>

    <pre><code>
        start() {
            1. Register this thread with Thread scheduler
            2. Perform all other mandatory activities
            3. Invoke run() 
        }
    </code></pre>

<h6>Case 4 : Overloading of run() method</h6>
<p>Overloading of run() method is always possible but thread class start() method can invoke no-arg run() method, the 
    other overloaded method we have tocall explicitly like a normal method call</p>

    <pre><code>
        class MyThread extends Thread {
            public void run() {
                SOP("no-arg method");
            }
            public void run(int i) {
                SOP("int-arg method");
            }
        }
        class ThreadDemo {
            public static void main(String[] args) {
                MyThread t = new MyThread();
                t.start();
            }
        }
    </code></pre>
    
    <pre><output>
        no-arg method
    </output></pre>

<h6>Case 5 : Overriding of run() method</h6>
<p>If we are not overriding run() method then thread class run() method will be executed which has empty 
    implemntation. Hence we wont get any output</p>
    <pre><code>
        class MyThread extends Thread {
           
        }
        class ThreadDemo {
            public static void main(String[] args) {
                MyThread t = new MyThread();
                t.start();
            }
        }
    </code></pre>
    
    <pre><output>
        No output
    </output></pre>   

    <mark>It is highly recommended to override run() method o/w dont go for multithreading concept</mark>

<h6>6. Overriding of start() method</h6>
<p>If we override start() method then our start() method will be executed just like a normal method call and 
    new thread wont be created</p>
<pre><code>
    class MyThread extends Thread {
        public void start() {
            SOP("start-method");
        }
        public void run() {
            SOP("run-method");
        }
    }
    class ThreadDemo {
        public static void main(String[] args) {
            MyThread t = new MyThread();
            t.start();
            SOP("main-method");
        }
    }
</code></pre>

<pre><output>
    start method 
    main method

    (This output produced by only main thread)
</output></pre>

<mark>Note : It is not recommended to override start() method o/w dont go for multithreading concept</mark>
    
<h6>Case 7 : </h6>
<pre><code>
    public class MyThread extends Thread {
        public void start() {
            super.start();
            System.out.println("start-method");
        }
        public void run() {
            System.out.println("run-method");
        }
    }
    public class ThreadDemo {
        public static void main(String[] args) {
            MyThread t = new MyThread();
            t.start();
            System.out.println("main-method");
        }
    }
</code></pre>

<pre><output>
Output - 1 
start-method
main-method
run-method

Output - 2
start-method
run-method
main-method 

Output - 3 
run-method 
start-method
main-method
</output></pre>

<h6>Case 8 : Thread lifecycle</h6>
<img src="images/ss70.png" alt="ss12" width="400" height="400">

<h6>Case 9 : </h6>
<p>After starting a thread if we are trying to restart the same thread then we will et RE saying IllegalThreadStateException</p>
<pre><code>
    Thread t = new Thread(); 
    t.start();
        . 
        . 
    t.start();
</code></pre>

<pre><output>
    RE : IllegalThreadStateException
</output></pre>

<h6>2. Defining a thread by implementing Runnable(I)</h6>
<p>We can define a thread by implementing Runnable(I)</p>
<img src="images/ss71.png" alt="ss12" width="400" height="300">

<p>Runnable(I) presents in java.lang package and it contains only one method i.e public void run() method</p>

<pre><code>
    class MyRunnable implements Runnable {
        public void run() {
            for(int i = 0; i < 10 ; i++) {
                System.out.println("Child thread");
            }
        }
    }
    class ThreadDemo {
        public static void main(String[] args) {
            MyRunnable r = new MyRunnable(); 
            Thread t = new Thread(r); 
            t.start();
            for(int i = 0; i < 10 ; i++) {
                System.out.println("Main thread");
            }
        }
    }
</code></pre>
<img src="images/ss72.png" alt="ss12" width="400" height="300">
<img src="images/ss73.png" alt="ss12" width="400" height="300">

<p>We will get mixed output and we cant tell exact output</p>

<h6>Case study</h6>
<pre><code>
    MyRunnable r = new MyRunnable();
    Thread t1 = new Thread(); 
    Thread t2 = new Thread(r);
</code></pre>

<h6>Case 1 : </h6>
<pre><code>
    t1.start();
</code></pre>

<pre><output>
    A new thread will be created which is responsible for the exection of thread class run()
    method, which has empty implementation.
</output></pre>

<h6>Case 2 : </h6>
<pre><code>
    t1.run();
</code></pre>

<pre><output>
    No new thread will be created and thread class run() method will be executed just like
    a normal method call
</output></pre>

<h6>Case 3 : </h6>
<pre><code>
    t2.start();
</code></pre>

<pre><output>
    A new thread will be created which is responsible for the exection of MyRunnable class 
    run() method, 
</output></pre>
<h6>Case 4 : </h6>
<pre><code>
    t2.run();
</code></pre>

<pre><output>
    A new thread wont be created and MyRunnable run() method will be executed just like a
    normal method call.
</output></pre>

<h6>Case 5 : </h6>
<pre><code>
    r.start();
</code></pre>

<pre><output>
    We will get CE saying MyRunnable class doesnt have start() capability

    CE : cannot find symbol
    symbol : method start()
    location : class MyRunnable
</output></pre>

<h6>Case 6 : </h6>
<pre><code>
    r.run();
</code></pre>

<pre><output>
    No new thread will be created and MyRunnable run() method will be executed 
    like normal method call
</output></pre>

<div class="container">
    <p class="bg-warning text-white">Which approach is best to define a thread?</p>
    <p>Among two ways of defining a thread implements Runnable approach is recommended.
        </p>
    <p>In the first approach our class always extends Thread class, there is no chance of extending any 
        other class. Hence we are missing inheritance benefit.</p>
    <p>But in the second approach while implementing Runnable interface we can extend any other class 
        hence we wont miss any inheritance benefit</p>
    <p>Because of above reason implementing Runnable interface is recommended than extending Thread class</p>
</div> 

<h6>Thread class constructors</h6>
<pre><code>
    1. Thread t = new Thread();
    2. Thread t = new Thread(Runnable r);
    3. Thread t = new Thread(String name);
    4. Thread t = new Thread(Runnable r, String name);
    5. Thread t = new Thread(ThreadGroup g, String name);
    6. Thread t = new Thread(ThreadGroup g, Runnable r);
    7. Thread t = new Thread(ThreadGroup g, Runnable r, String name);
    8. Thread t = new Thread(ThreadGroup g, Runnable r, String name, long stacksize);
</code></pre>

<h6>Durga's approach to define a thread(not recommended to use)</h6>

<pre><code>
    class MyThread extends Thread {
        public void run() {
            SOP("Child thread");
        }
    }
    class ThreadDemo {
        public static void main(String[] args) {
            MyThread t = new MyThread();
            Thread t1 = new Thread(t);
            t1.start();
            SOP("Main thread");
        }
    }
</code></pre>

<pre><output>
    output -1 
    Child thread 
    Main thread 

    output -2  
    Main thread 
    Child thread
</output></pre>

    
        
    <h5>3. Getting & Setting name of thread</h5>
<p>Every thread in java has some name, it may be default name generated by JVM or customized name 
    provided by programmer</p>
<p>We can get and set name of a thread by using the following two methods of thread class</p>
<p>1. public final String getName()</p>
<p>2. public final void setName(String name)</p>

    <pre><code>
        class MyThread extends Thread {

        }
        class ThreadDemo {
            public static void main(String[] args) {
                System.out.println(Thread.currentThread().getName());
                MyThread t = new MyThread();
                System.out.println(t.getName());
                Thread.currentThread().setName("Rajnikant");
                System.out.println(Thread.currentThread().getName());
                System.out.println(10 / 0);
            }
        }
    </code></pre>
    <pre><output>
        main
        Thread-0
        Rajnikant
        main
Exception in thread "Rajnikant" java.lang.ArithmeticException: / by zero
	at com.cts.java.ThreadDemo.main
    </output></pre>

<mark>Note : We can get current excecuting thread object by using Thread.currentThread() method</mark>
<pre><code>
    class MyThread extends Thread {
        public void run() {
            System.out.println("run method executed by Thread : " + Thread.currentThread().getName());
        }
    }
    class ThreadDemo {
        public static void main(String[] args) {
            MyThread t = new MyThread();
            t.start();
            System.out.println("main method executed by Thread : " + 
            Thread.currentThread().getName());
        }
    }
</code></pre>
<pre><output>
    main method executed by Thread : main
    run method executed by Thread : Thread-0
</output></pre>

    <h5>4. Thread Priorities</h5>
    <p>Every thread in java has some priority. It may be default priority generated by JVM or customized priority 
        provided by programmer. The valid range of thread priorities is 1 to 10, where 1 is MIN_PRIORITY, 10 is MAX_PRIORITY</p>
    <p>Thread class defines the following constants to represent some standard priorities</p>
    <pre><code>
        Thread.MIN_PRIORITY - 1
        Thread.NORM_PRIORITY - 5 
        Thread.MAX_PRIORITY - 10
    </code></pre>
    <p>Thread scheduler will use priorities while allocating processor. The thread which is having highest priority will get the chance firt</p>
    <p>If two threads having same priority then we cant expect exact execution order. It depends on thread scheduler</p>
    <p>Thread class defines the following methods to get and set priority of a thread.</p>

    <pre><code>
        public final int getPriority();
        public final void setPriority(int p);
    </code></pre>
    <p>Allowed values range 1 to 10 o/w we will get RE : IllegalArgumentException</p>
    <pre><code>
        t.setPriority(7);       &#10004
        t.setPriority(17);      &#10060(RE: IllegalArgumentException)
    </code></pre>
    
<h6>Default priority</h6>
<p>The default priority only for the main thread is 5. But for all remaining threads the default priority will be inherited from parent 
    to child i.e whatever priority parent thread has the same priority will be there for the child thread
</p>
<pre><code>
    class MyThread extends Thread {
	
    }
    class ThreadDemo {
        public static void main(String[] args) {
            System.out.println("priority of main thread before setting priority" + Thread.currentThread().getPriority());
            Thread.currentThread().setPriority(7);  //line1
            //Thread.currentThread().setPriority(17); 
            System.out.println("priority of main thread after setting priority" + Thread.currentThread().getPriority());
            MyThread t = new MyThread();
            System.out.println("priority of child thread " + t.getPriority());
            
        }
    }
</code></pre>
<pre><output>
    priority of main thread before setting priority5
    priority of main thread after setting priority7
    priority of child thread 7
</output></pre>

<p>If we comment line1 then child thread priority will become 5</p>

<pre><code>
    class MyThread extends Thread {
        public void run() {
            for (int i = 0; i < 10; i++) {
                System.out.println("Child thread");
            }
        }
    }
    class ThreadDemo {
        public static void main(String[] args) {
            MyThread t = new MyThread();
            t.setPriority(10);  //line 1
            t.start();
            for (int i = 0; i < 10; i++) {
                System.out.println("Main thread");
            } 
        }
    }
</code></pre>
<p>If we are commenting line1 then both main and child threads have the same priority 5 and hence we cant 
    expect execution order and output. If we are not commenting line 1 then main thread has the priority 5 and 
    child thread has a priority 10 hence child thread will get the chance first followed by main thread. In ths case 
output is </p>

<pre><output>
    Child Thread 
    Child Thread 
        . 
        . 
        . 
    Main Thread 
    Main Thread 
        . 
        . 
        .
</output></pre>

<mark>Note : Some platforms wont provide support for thread priorities</mark>


    <h5>5. The methods to prevent Thread execution</h5>
    <p>We can prevent a thread execution by using the following methods</p>
    <p>1. yield()</p>
    <p>2. join()</p>
    <p>3. sleep()</p>   
    
    <h6>1. yield()</h6>
    <p>yield() method causes to pause current executing thread to give the chance for waiting threads or same priority, if there is 
        no waiting thread or all waiting threads have low priority then same thread can continue its excecution</p>
    
    <p>If multiple threads are waiting with the same priority then which waiting thread will get the chance, we cant expect , it depends on thread 
        scheduler</p>

    <p>The thread which is yielded, when it will get the chance once again, it depends on thread scheduler and we cant expect exactly</p>

    <pre><code>
        public static native void yield();
    </code></pre>

    <img src="images/ss74.png" alt="ss12" width="500" height="600">
    
    <pre><code>
        class MyThread extends Thread {
            public void run() {
                for (int i = 0; i < 10; i++) {
                    System.out.println("Child thread");
                    Thread.yield(); //line1
                }
            }
        }
        class ThreadYieldDemo {
            public static void main(String[] args) {
                MyThread t = new MyThread();
                t.start();
                for (int i = 0; i < 10; i++) {
                    System.out.println("Main thread");
                } 
            }
        }
    </code></pre>
    <p>In the above program if we are commenting line1, both threads will be executed simultaneously and 
        we cant expect which thread will complete first.
    </p>
    <p>If we are not commenting line1 then child thread will always call yield() method because of that 
        main thread will get a chance more number of time and the chance of completing main thread first is high</p>

    <pre><output>
Main thread
Main thread
Child thread
Main thread
Main thread
Child thread
Child thread
Main thread
Main thread
Main thread
Main thread
Main thread
Main thread
Child thread
Child thread
Child thread
Child thread
Child thread
Child thread
Child thread
    </output></pre>

<mark>Note : Some platforms wont provide proper support for yield() method</mark>
    
    <h6>2. join()</h6>
    <p>If a thread wants to wait until completing some other thread then we should go for join() method</p>
<p>For example if a thread t1 wants to wait until completing t2 then t1 has to call t2.join() </p>
<p>If t1 executes t2.join() then immediately t1 will be entered inti waiting state until t2 completes</p>
<p>Once t2 completes then t1 can complete its execution</p>
<img src="images/ss75.png" alt="ss12" width="400" height="400">
<p>Wedding cards printing thread(t2) has to wait until venue fixing thread(t1) completion. Hence t2 has to call t1.join().</p>
<p>Wedding cards distribution thread(t3) has to wait until wedding card printing thread(t2) completion. Hence t3 has to call t2.join()</p>

<pre><code>
    public final void join() throws InterruptedException
    public final void join(long ms) throws InterruptedException
    public final void join(long ms, int ns) throws InterruptedException
</code></pre>

<mark>Note : Every join() method throws InterruptedException which is checked exception hence compulsory we should handle that exception 
    either by using try catch or by throws keyword o/w we will get CE </mark>

    <img src="images/ss76.png" alt="ss12" width="600" height="600">

    <h6>Case 1 : </h6>
    <p>Waiting of main thread until completing child thread</p>
    <pre><code>
        class MyThread extends Thread {
            public void run() {
                for (int i = 0; i < 10; i++) {
                    System.out.println("Seetha thread");
                    try {
                        Thread.sleep(2000);
                    }
                    catch(InterruptedException e) {
                        
                    }
                }
            }
        }
        class ThreadJoinDemo {
            public static void main(String[] args) throws InterruptedException{
                MyThread t = new MyThread();
                t.start();
                t.join();       //line1
                for (int i = 0; i < 10; i++) {
                    System.out.println("Rama thread");
                } 
            }
        }
    </code></pre>

<p>If we comment line1 then both main and child threads will be executed simultaneously and we cant expect exact 
    output
</p>
<p>If we are not commenting line1 then main thread calls join() method on child thread object hence main thread will wait until completing 
    child thread. In this case output is</p>
    <pre><output>
        Seetha thread
        Seetha thread
        Seetha thread
        Seetha thread
        Seetha thread
        Seetha thread
        Seetha thread
        Seetha thread
        Seetha thread
        Seetha thread
        Rama thread
        Rama thread
        Rama thread
        Rama thread
        Rama thread
        Rama thread
        Rama thread
        Rama thread
        Rama thread
        Rama thread
            </output></pre>

<pre><code>
    class MyThread extends Thread {
        public void run() {
            for (int i = 0; i < 10; i++) {
                System.out.println("Seetha thread");
                try {
                    Thread.sleep(2000);
                }
                catch(InterruptedException e) {
                    
                }
            }
        }
    }
    class ThreadYieldDemo {
        public static void main(String[] args) throws InterruptedException{
            MyThread t = new MyThread();
            t.start();
            t.join(10000);
            for (int i = 0; i < 10; i++) {
                System.out.println("Rama thread");
            } 
        }
    }
</code></pre>
<pre><output>
Seetha thread
Seetha thread
Seetha thread
Seetha thread
Seetha thread
Rama thread
Rama thread
Rama thread
Rama thread
Rama thread
Rama thread
Rama thread
Rama thread
Rama thread
Rama thread
Seetha thread
Seetha thread
Seetha thread
Seetha thread
Seetha thread

</output></pre>

<h6>Case 2 : Waiting of child thread until completing main thread</h6>
<pre><code>
    class MyThread extends Thread {
	
        static Thread mainThread;
    
        public void run() {
            try {
                mainThread.join();
            } catch (InterruptedException e) {
    
            }
            for (int i = 0; i < 10; i++) {
                System.out.println("Seetha thread");
            }
        }
    }
    
    class ThreadYieldDemo {
        public static void main(String[] args) throws InterruptedException{
            MyThread.mainThread = Thread.currentThread();
            MyThread t = new MyThread();
            t.start();
            for (int i = 0; i < 10; i++) {
                System.out.println("Rama thread");
                Thread.sleep(2000);
            } 
        }
    }
</code></pre>
<p>In the above example child thread calls join() method on main thread object hence child thread 
    has to wait until completing main thread, hence in this case output is</p>
<pre><output>
Rama thread
Rama thread
Rama thread
Rama thread
Rama thread
Rama thread
Rama thread
Rama thread
Rama thread
Rama thread
Seetha thread
Seetha thread
Seetha thread
Seetha thread
Seetha thread
Seetha thread
Seetha thread
Seetha thread
Seetha thread
Seetha thread
</output></pre>

<h6>Case 3 : </h6>
<p>If main thread calls join() method on child thread object and child thread calls join() method on main thread 
    object then both threads will wait forever then the program will be stucked or paused(this is something like deadlock) </p>

    <pre><code>
        class MyThread extends Thread {
	
            static Thread mainThread;
        
            public void run() {
                try {
                    mainThread.join();
                } catch (InterruptedException e) {
        
                }
                for (int i = 0; i < 10; i++) {
                    System.out.println("Seetha thread");
                }
            }
        }
        
        class ThreadYieldDemo {
            public static void main(String[] args) throws InterruptedException{
                MyThread.mainThread = Thread.currentThread();
                MyThread t = new MyThread();
                t.start();
                t.join();
                for (int i = 0; i < 10; i++) {
                    System.out.println("Rama thread");
                    Thread.sleep(2000);
                } 
            }
        }
    </code></pre>
    
    <pre><output>
        Curson blinking only
    </output></pre>

<h6>Case 4: </h6>
<p>If a thread calls join() method on the same thread itself then the program will be stucked, 
    this is something like deadlock. In this case thread has to wait infinite amount of time
</p>

<pre><code>
    class Test {
        public static void main(String[] args) throws InterruptedException {
            
                Thread.currentThread().join();
            
        }
    }
</code></pre>

<pre><output>
    cursor blinking only
</output></pre>

    <h6>3. sleep()</h6>
<p>If a thread dont want to perform any operation for a particular amount of time then we should go for sleep method</p>
<pre><code>
    public static native void sleep(long ms) throws InterruptedException
    public static void sleep(long ms, int ns) throws InterruptedException
</code></pre>

<mark>Note : Every sleep method throws InterruptedException, which is checked exception hence whenever we are using sleep() method 
    compulsory we should handle interrupted exception either by try catch or by throws keyword otherwise we will get CE</mark>
    <img src="images/ss77.png" alt="ss12" width="600" height="600">

    <pre><code>
        public class SlideRotator {
            public static void main(String[] args) throws InterruptedException {
                for (int i = 1; i <= 10; i++) {
                    System.out.println("Slide-" + i);
                    Thread.sleep(5000);
                }
            }
        }
    </code></pre>
    <pre><output>
Slide-1
Slide-2
Slide-3
Slide-4
Slide-5
Slide-6
Slide-7
Slide-8
Slide-9
Slide-10
    </output></pre>
    
    <h6>How a thread can interrupt another thread?</h6>
    <p>A thread can interrupt a sleeping thread or waiting thread by using interrupt method of thread class.</p>
    <pre><code>
        public void interrupt();
    </code></pre>

    <pre><code>
        class MyThread extends Thread {
            public void run() {
                try {
                    for (int i = 0; i < 10; i++) {
                        System.out.println("I am lazy thread");
                        Thread.sleep(2000);
                    }
                } catch (InterruptedException e) {
                    System.out.println("I got interrupted");
                }
            }
        }
        
        public class ThreadSleepDemo {
            public static void main(String[] args) {
                MyThread t = new MyThread();
                t.start();
                // t.interrupt();   //line1
                System.out.println("End of main method");
            }
        }
    </code></pre>
    <p>If we comment line1 then main thread wont interrupt child thread. In this case child thread will execute 
        for loop 10 times</p>
    <pre><output>
End of main method
I am lazy thread
I am lazy thread
I am lazy thread
I am lazy thread
I am lazy thread
I am lazy thread
I am lazy thread
I am lazy thread
I am lazy thread
I am lazy thread

    </output></pre>
    
    
    <pre><code>
        class MyThread extends Thread {
            public void run() {
                try {
                    for (int i = 0; i < 10; i++) {
                        System.out.println("I am lazy thread");
                        Thread.sleep(2000);
                    }
                } catch (InterruptedException e) {
                    System.out.println("I got interrupted");
                }
            }
        }
        
        public class ThreadSleepDemo {
            public static void main(String[] args) {
                MyThread t = new MyThread();
                t.start();
                t.interrupt();      //line 1
                System.out.println("End of main method");
            }
        }
    </code></pre>
    <p>If we are not commenting line1 then main thread interrupts child thread. In this case output is </p>
    <pre><output>
End of main method
I am lazy thread
I got interrupted
    </output></pre>

    <mark>&#10040&#10040&#10040 Note : whenever we are calling interrupt method if the target thread not in sleeping state 
        or waiting state then there is no impact of interrupt call immediately. Interrupt call will be waited until target thread 
        entered into sleeping or waiting stae. If the target thread entered into sleeping or waiting state then immediately interrupt 
        call will interrupt the target thread. If the target thread never entered into sleeping or waiting state in its lifetime then 
    there is no impact of interrupt call. This is the only case where interrupt call will be wasted</mark>
    <pre><code>
        class MyThread extends Thread {
            public void run() {
                for (int i = 0; i < 10000; i++) {
                    System.out.println("I am lazy thread " + i);
                }
                System.out.println("I am entering into sleep state");
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    System.out.println("I got interrupted");
                }
            }
        }
        
        public class ThreadSleepDemo {
            public static void main(String[] args) {
                MyThread t = new MyThread();
                t.start();
                t.interrupt();
                System.out.println("End of main method");
            }
        }
    </code></pre>
    
    <pre><output>
I am lazy thread 1
        . 
        . 
        .
I am lazy thread 9998
I am lazy thread 9999
I am entering into sleep state
I got interrupted

    </output></pre>

    <p>In the above example interrupt call waited until child thread completes for loop 10000 times</p>
    
<h6>Comparison table of yield(), join() and sleep() method</h6>
<table class="table table-striped">
    <thead class="thead-dark">
         <tr>
            <th>Property</th>
            <th>yield()</th>
            <th>join()</th>
            <th>sleep()</th>
        </tr>
    </thead> 
    <tbody>
<tr>
    <td>purpose</td>
    <td>If a thread wants to pause its execution to give the chance for remaining threads of same priority 
        then we should go for yield method
    </td>
    <td>If a thread wants to wait until completing some other thread then we should go for join() method</td>
    <td>If a thread dont want to perform any operation for a particular amount of time then we should go for sleep() method</td>
</tr>  
<tr>
    <td>Is it overloaded?</td>
    <td>No</td>
    <td>Yes</td>
    <td>Yes</td>
</tr>  
<tr>
    <td>Is it final?</td>
    <td>No</td>
    <td>Yes</td>
    <td>No</td>
</tr>  
<tr>
    <td>Does it throws InterruptedException?</td>
    <td>No</td>
    <td>Yes</td>
    <td>Yes</td>
</tr>  
<tr>
    <td>Is it natve?</td>
    <td>Yes</td>
    <td>No</td>
    <td>sleep(long ms) - native<br>sleep(long ms, int ns) - non-native</td>
</tr>  
<tr>
    <td>Is it static?</td>
    <td>Yes</td>
    <td>No</td>
    <td>Yes</td>
</tr>  
    </tbody>
</table>

    <h5>6. Synchronization</h5>
    <img src="images/ss78.png" alt="ss12" width="400" height="300">
    <img src="images/ss79.png" alt="ss12" width="400" height="300">

    <p>synchronized is a modifier applicable only for methods and blocks but not for classes 
        and variables. If multiple threads are trying to operate simultaneously on the same java object then there may be a chance of data 
        inconsistency problem</p>
    <p>To overcome this problem we should go for synchronized keyword</p>
    <p>If a method or block declared as synchronized then at a time only one thread is allowed to execute 
        that method or block on the given object so that data inconsistency problem will be resolved</p>

    <p>The main advantage of synchronized keyword is we can resolve data inconsistency problems. But the main disadvantage of synchronized keyword is 
        it increases waiting time of threads and creates performance problems. Hence if there is no specific requirement then its not 
        recommended to use synchronized keyword</p>

    <p>Internally Synchronization concept is implemented by using lock. Every object in java has a unique lock, whenever we are using 
        synchronized keyword then only lock concept will come into the picture</p>

    <p>If a thread wants to execute synchronized method on the given object, first it has to get lock of that object. Once thread got the lock 
        then it is allowed to execute any synchronized method on that object. Once method execution completes automatically thread releases lock. 
    </p>
    <p>Acquiring and releasing lock internally takes care by JVM and programmer not responsible fo this activity</p>
    <p>While a thread executing synchronized method on the given object, The remaining threads are not allowed to execute any synchronized method simultaneously 
        on the same object but remaining threads are allowed to execute non-synchronized methods simultaneously</p>

        <pre><code>
            class X {
                synchronized m1();
                synchronized m2();
                m3();
            }
        </code></pre>

        <img src="images/ss80.png" alt="ss12" width="400" height="300">
    
    <p>Lock concept is implemented based on object but not based on method</p>
    <img src="images/ss81.png" alt="ss12" width="400" height="500">

    <pre><code>
        class X {
            synchronized Area {
                Wherever we are performing update operation
                (Add/remove/delete/replace) i.e where state of 
                object changing
            }
            non-synchronized {
                Wherever object state wont be changed like read()
                operation
            }
        }
    </code></pre>
    <pre><code>
        class ReservationSystem {
            <span style="color: red;">non-synchronized</span> checkAvailability {
                . 
                . (Just read operation)
                .
            } 
            <span style="color: red;">synchronized</span> bookTicket() {
                . 
                . (Update)
                .
            }
        }
    </code></pre>

    <pre><code>
        class Display {
            public synchronized void wish(String name) {
                for (int i = 0; i < 10; i++) {
                    System.out.print("Good Morning:");
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        System.out.println(name);
                    }
                    System.out.println(name);
                }
            }
        }
        
        class MyThread extends Thread {
            Display d;
            String name;
            public MyThread(Display d, String name) {
                this.d = d;
                this.name = name;
            }
            public void run() {
                d.wish(name);
            }
        }
        public class SynchronizedDemo {
            public static void main(String[] args) {
                Display d = new Display();
                MyThread t1 = new MyThread(d, "Dhoni");
                MyThread t2 = new MyThread(d, "Yuvraj");
                t1.start();
                t2.start();
            }
        }
        
    </code></pre>
<p>If we declare wish method as synchronized then at a time only one thread is allowed 
    to execute wish method on the given display object. Hence we will get regular output</p>
    <pre><output>
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
    </output></pre>

    <p>If we are not declaring wish method as synchronized then both threads will be executed simultaneously 
        and hence we will get irregular output</p>

<pre><output>
Good Morning:Good Morning:Dhoni
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Yuvraj
Good Morning:Dhoni
Good Morning:Yuvraj
Good Morning:Dhoni
Good Morning:Yuvraj
Good Morning:Dhoni
Good Morning:Yuvraj
Good Morning:Dhoni
Yuvraj
Good Morning:Good Morning:Dhoni
Good Morning:Yuvraj
Good Morning:Yuvraj
Dhoni
Good Morning:Good Morning:Dhoni
Yuvraj
</output></pre>
<h6>Casestudy</h6>
<pre><code>
    Display d1 = new Display();
    Display d2 = new Display();
    MyThread t1 = new MyThread(d1, "Dhoni");
    MyThread t2 = new MyThread(d2, "Yuvraj");
    t1.start();
    t2.start();
</code></pre>
<img src="images/ss82.png" alt="ss12" width="400" height="600">
<p>Even though wish method is synchronized we will get irregular output because threads 
    are operating on different java objects
</p>
<h6>Conclusion</h6>
<p>If multiple threads are operating on same java object then Synchronization is required. If multiple threads 
    are operating on multiple java objects then Synchronization is not required</p>
    
<h6>Class level lock</h6>
<p>Every class in java has a unique lock which is nothing but class level lock</p>
<p>If a thread wants to execute a static synchronized method then thread required class level lock.
    Once thread got class level lock then it is allowed to execute any static synchronized method 
    of that class. Once method execution completes automatically thread releases the lock
</p>

<p>While a thread executing static synchronized method, the remaining threads are not allowed to execute any static 
   synchronized method of that class simultaneously. But remaining threads are allowed to execute the following methods simultaneously</p>
   <p>1. Normal static methods</p>
   <p>2. synchronized instance methods</p>
   <p>3. Normal instance methods</p>

   <pre><code>
       class X {
           static synchronized m1()
           static synchronized m2() 
           static m3() 
           synchronized m4() 
           m5()
       }
    </code></pre>
    <img src="images/ss83.png" alt="ss12" width="500" height="600">

    <pre><code>
        class Display {
            public synchronized void displayn() {
                for (int i = 1; i <= 10; i++) {
                    System.out.print(i);
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        
                    }
                }
            }
            public synchronized void displayc() {
                for (int i = 65; i <= 75; i++) {
                    System.out.print((char)i);
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        
                    }
                }
            }
        }
        
        class MyThread1 extends Thread {
            Display d;
        
            public MyThread1(Display d) {
                this.d = d;
            }
        
            public void run() {
                d.displayn();
            }
        }
        
        class MyThread2 extends Thread {
            Display d;
        
            public MyThread2(Display d) {
                this.d = d;
            }
        
            public void run() {
                d.displayc();
            }
        }
        
        
        public class SynchronizedDemo {
            public static void main(String[] args) {
                Display d = new Display();
                MyThread1 t1 = new MyThread1(d);
                MyThread2 t2 = new MyThread2(d);
                t1.start();
                t2.start();
            }
        }
        
    </code></pre>
    
    <pre><output>
        ABCDEFGHIJK12345678910
            or 
        12345678910ABCDEFGHIJK
    </output></pre>
    <img src="images/ss84.png" alt="ss12" width="400" height="300">

    <h6>Synchronized block</h6>

    <p>We can declare synchronized block as follows</p>
    <p>1. To get lock of current object</p>
    <pre><code>
        synchronized(this) {
            - 
            - 
            -
        }
        If a thread got lock of current object then only it is allowed to 
        execute this area.
    </code></pre>

    <p>2. To get lock of particular object 'b'</p>
    <pre><code>
        synchronized(b) {
            - 
            - 
            -
        }
        If a thread got lock of particular object 'b' then only it is allowed
        to execute this area.
    </code></pre>

    <p>3. To get class level lock</p>
    <pre><code>
        synchronized(Display.class) {
            - 
            - 
            -
        }
        If a thread got class level lock of "Display" class, then only it is 
        allowed to execute this area.
    </code></pre>

    <pre><code>
        class Display {
            public void wish(String name) {
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	//1 lakh lines of code
                synchronized (this) {
        
                    for (int i = 0; i < 10; i++) {
                        System.out.print("Good Morning:");
                        try {
                            Thread.sleep(2000);
                        } catch (InterruptedException e) {
                            System.out.println(name);
                        }
                        System.out.println(name);
                    }
        
                }
            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	//1 lakh lines of code
            }
        }
        
        class MyThread extends Thread {
            Display d;
            String name;
            public MyThread(Display d, String name) {
                this.d = d;
                this.name = name;
            }
            public void run() {
                d.wish(name);
            }
        }
        public class SynchronizedDemo {
            public static void main(String[] args) {
                Display d = new Display();
                MyThread t1 = new MyThread(d, "Dhoni");
                MyThread t2 = new MyThread(d, "Yuvraj");
                t1.start();
                t2.start();
            }
        }
    </code></pre>
    
    <pre><output>
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj

    </output></pre>

    <pre><code>
        class Display {
            public void wish(String name) {
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	//1 lakh lines of code
                synchronized (Display.class) {
        
                    for (int i = 0; i < 10; i++) {
                        System.out.print("Good Morning:");
                        try {
                            Thread.sleep(2000);
                        } catch (InterruptedException e) {
                            System.out.println(name);
                        }
                        System.out.println(name);
                    }
        
                }
            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	//1 lakh lines of code
            }
        }
        
        class MyThread extends Thread {
            Display d;
            String name;
            public MyThread(Display d, String name) {
                this.d = d;
                this.name = name;
            }
            public void run() {
                d.wish(name);
            }
        }
        public class SynchronizedDemo {
            public static void main(String[] args) {
                Display d1 = new Display();
                Display d2 = new Display();
                MyThread t1 = new MyThread(d1, "Dhoni");
                MyThread t2 = new MyThread(d2, "Yuvraj");
                t1.start();
                t2.start();
            }
        }
        
    </code></pre>
    
    <pre><output>
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj

    </output></pre>

<mark>Lock concept applicable for object types and class types but not for primitives, hence 
    we cant pass primitive type as argument to synchronized block o/w we will get CE saying unexpected 
    type fount int required reference</mark>

    <pre><code>
        int x = 10;
        synchronized(x) {
            - 
            - 
            -
        }
    </code></pre>
    
    <pre><output>
        CE : error: unexpected type
        synchronized (x) {
        ^
    required: reference
    found:    int

    </output></pre>


    <h6>FAQs</h6>
    <p>1. What is synchronized keyword and where we can apply?</p>
    <p>synchronized is a modifier applicable for methods and blocks but not for class and variables</
    <p>2. Explain advantage of synchronized keyword?</p>
    <p>We can resolve data inconsistency problems</p>
    <p>3. Explain disadvantage of synchronized keyword?</p>
    <p>It increases waiting time of thread and creates performance problem</p>
    <p>4. What is race condition?</p>
    <p>If multiple threads are operating simultaneously on same java object then there may be a chance of data inconsistency
        problem. This is called race condition. We can overcome this problem by using synchronized keyword.
    </p>
    <p>5. What is Object lock and when it is required?</p>
    <p>Every object in java has a unique lock which is nothing but object lock. Whenever a thread wants to 
        execute instance synchronized method then that thread requires object lock</p> 
    <p>6. What is class level lock and when it is required?</p>
    <p>Every class in java has a unique lock which is nothing but class level lock. Whenever if a thread wants to 
        execute static synchronized method then that thread requires this lock</p>
    <p>7. What is the difference between class level lock and object lock?</p>
    <p>If a thread wants to execute instance synchronized method then that thread requires object lock and if a thread wants to 
        execute static synchronized method then that thread requires class level lock</p>
    <p>8. While a thread executing synchronized method on the given object. Is remaining threads allowed to execute 
        any other synchronized method simultaneously on the same object?</p>
    <p>No.</p>
    <p>9. What is synchronized block?</p>
    <p>10. How to declare synchronized block to get lock of current object?</p>
    <p>11. How to declare synchronized block to get class level lock?</p>
    <p>12. What is the advantage of synchronized block over synchronized method</p>
    <p>Performance by default will be improved and waiting time of the threads will be reduced</p>
    <p>13. Is a thread can acquire multiple locks simultaneously</p>
    <p>Yes ofcourse from different objects</p>

    <pre><code>
        class X {
            public synchronized void m1() {
                //here thread has lock of X object
                Y y = new Y();
                synchronized(y) {
                    //here thread has locks of X and Y objects
                    Z z = new Z();
                    synchronized(z) {
                        //here thread has locks of X, Y and Z
                    }
                }
            }
        }
    </code></pre>
    
   <p>14. What is synchronized statement?(Interview people created terminology)</p>
   <p>The statements present in synchronized method or synchronized blocks are called synchronized statements</p>

    <h5>7. InterThread Communication</h5>

    <p>Postman example</p>
    <p>Two threads can communicate with each other by using wait(), notify() and notifyAll() methods.</p>
    <p> The thread which is expecting updation is responsible to call wait() method then immediately the thread will enter into waiting state.</p>
    <p>The thread which is responsible to perform updation, after performing updation it is responsible to call notify() method 
        then waiting thread will get that notification and continue its execution with those update items</p>
    <p>wait(), notify() and notifyAll() methods present in object class but not in thread class because thread can call these methods on 
        any java object</p>
    <p>To call wait(), notify() or notifyAll() methods on any object, thread should be owner of that object i.e the thread should has lock of that object 
        i.e the thread should be inside synchronized area hence we can call wait() notify() and notifyAll() methods only from synchronized area o/w we will get 
    RE : saying IllegalMonitorStateException</p>

    <p>If a thread calls wait() method on any object it <span style="color : red;">immediately</span> releases the lock of <span style="color: red;">
        that particular object</span> and enter into waiting state</p>
    <p>If a thread calls notify() method on any object, it releases the lock of that object but <spna style="color: red;">may not immediately</spna>. Except wait() notify() and notifyAll() there 
        is no other method where thread releases the lock</p>

<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>Method</th>
            <th>Is thread releases lock?</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>yield()</td>
            <td>No</td>
        </tr>
        <tr>
            <td>join()</td>
            <td>No</td>
        </tr>
        <tr>
            <td>sleep()</td>
            <td>No</td>
        </tr>
        <tr>
            <td>wait()</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td>notify()</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td>notifyAll()</td>
            <td>Yes</td>
        </tr>  
    </tbody>
</table>


<div class="container">
    <p class="bg-warning text-white">Whic of the following is valid?</p>
    <p>1. If a thread calls wait method immediately it will enter into waiting state without 
        releasing any lock?</p>
    <p>Wrong</p>
    <p>2. If a thread calls wait() method it releases locko of that object but may not immediately</p>
    <p>Wrong. Because immediately release</p>
    <p>3. If a thread calls wait() method on any object it releases all locks acquired by that thread and 
        immediately enter into waiting state</p>
    <p>Wrong because it will release only that particular lockk not all</p>
    <p>4. If a thread calls wait() method on any object it immediately releases the lock of that particular object 
        and enter into waiting state</p>
    <p>Correct</p>
    <p>5. If a thread calls notify() method on any object it immediately releases the lock of that particular object</p>
    <p>Invalid</p>
    <p>6. If a thread calls notify() method on any object it releases the lock of that object but may not immediately</p>
    <p>Correct</p>
</div> 


<pre><code>
    public final void wait() throws InterruptedException
    public final native void wait(long ms) throws InterruptedException
    public final void wait(long ms, int ns) throws InterruptedException

    public final native void notify()
    public final native void notifyAll()
</code></pre>

<mark>Note : Every wait() method throws InterruptedException which is checked exception hence whenever we are using wait() method 
compulsory we should handle this InterruptedException either by try catch or by throws keyword o/w we will get CE</mark>
<br><br>
<img src="images/ss85.png" alt="ss12" width="600" height="600">

<pre><code>
    class ThreadB extends Thread {
        int total = 0;
    
        public void run() {
            synchronized (this) {
                System.out.println("Child thread starts calculation");
                for (int i = 1; i <= 100; i++) {
                    total = total + i;
                }
                System.out.println("Child thread giving notification");
                this.notify();
            }
    
        }
    }
    
    class ThreadA {
    
        public static void main(String[] args) throws IllegalMonitorStateException, InterruptedException {
            ThreadB b = new ThreadB();
            b.start();
            synchronized (b) {
                System.out.println("Main thread calling wait() method");
                b.wait();
                System.out.println("Main thread got notification");
                System.out.println(b.total);
            }
    
        }
    
    }
</code></pre>

<pre><output>
Main thread calling wait() method
Child thread starts calculation
Child thread giving notification
Main thread got notification
5050

</output></pre>

<h6>Producer consumer problem</h6>
<p>Producer thread is responsible to produce items to the queue and consumer thread is responsible to consume items 
    from the queue. If queue is empty then consumer thread will call wait method and entered into waiting state. After
    producing items to the queue producer thread is responsible to call notify() method then waiting consumer will get that 
    notification and continue its execution with updated items</p>

    <img src="images/ss86.png" alt="ss12" width="400" height="600">

    <h6>Difference between notify() and notifyAll()</h6>
    <p>We can use notify() method to give notification for only one waiting thread. If multiple threads are waiting then only one thread
        will be notified and the remaining threads have to wait for further notifications</p>
    <p>Which thread will be notified we cant expect, it depends on JVM</p>

  <p>We can use notifyAll() to give the notification for all waiting threads of a particular object. Even though multiple threads notified 
      but execution will be performed one by one because threads required lock and only one lock is available</p>

<mark>Note : On which object we are calling wait method thread required lock of that particular object. For example if we are calling wait() 
    method on s1 then we have to get lock of s1 object but not s2 object</mark>

    <pre><code>
        Stack s1 = new Stack();
        Stack s2 = new Stack();

        synchronized(s1) {
            - 
            - 
            - 
            s2.wait();  &#10060 //RE: IllegalMonitorStateException 
            s1.wait();  &#10004
            - 
            -
        }


    </code></pre>

    <h5>8. Deadlock</h5>
    <p>If two threads are waiting for each other forever such type of infinite waiting is called deadlock.</p>
    <p>synchronized keyword is the only reason for deadlock situation hence by using synchronized keyword we have to 
        take special care.
    </p>
    <p>There are no resolution techniques for deadlock but several prevention techniques are available.</p>
    <pre><code>
      

class A {
	public synchronized void d1(B b) {
		System.out.println("Thread 1 starts execution of d1() method");
		try {
			Thread.sleep(3000);
		} catch(InterruptedException e) {
			
		}
		System.out.println("Thread 1 trying to call B's last()");
		b.last();
	}

	public synchronized void last() {
		System.out.println("A class last() method");
	}
}

class B {
	public synchronized void d2(A a) {
		System.out.println("Thread 2 starts execution of d2() method");
		try {
			Thread.sleep(3000);
		} catch(InterruptedException e) {
			
		}
		System.out.println("Thread 2 trying to call A's last()");
		a.last();
	}

	public synchronized void last() {
		System.out.println("Inside B, this is last() method");
	}
}

public class Deadlock extends Thread { 
	A a = new A();
	B b = new B();

	public void m1() {
		this.start();
		a.d1(b);
	}

	public void run() {
		b.d2(a);
	}

	public static void main(String[] args) {
		Deadlock d = new Deadlock();
		d.m1();
	}
}

    </code></pre>
    
    <pre><output>
Thread 1 starts execution of d1() method
Thread 2 starts execution of d2() method
Thread 1 trying to call B's last()
Thread 2 trying to call A's last()

    </output></pre>

<p>In the above program if we remove atleast one synchronized keyword then the program wont 
    enter into deadlock hrnce synchronized keyword is the only reason for deadlock situation. 
    Due to this while usind synchronized keyword we have to take special care.
    <h6>Deadlock vs Starvation</h6>
    <p>Long waiting of a thread where waiting never ends is called deadlock</p>
    <p>Whereas long waiting of a thread where waiting ends at certain point is called starvation. 
        For example, low priority thread has to wait until completing all high priority threads. 
        It may be long waiting but ends at certain point, which is nothing but starvation.
    </p>
    
    
    <h5>9. Daemon Threads</h5>
    <p>The threads which are executing in the background are called daemon threads</p>
    <p>Example - Garbage Collector, Signal Dispatcher, Attach Listener etc</p>

    <p>The main objective of daemon threads is to provide support for non-daemon threads(main thread)</p>
    <p>For example if main thread runs with low memory then JVM runs garbage collector to destroy useless objects so that number 
        of bytes of free memory will be improved. With this free memory main thread can continue its execution</p>

    <p>Usually daemon threads having low priority but based on our requirement daemon threads can run with high priority
        also</p>
        
    <p>We can check daemon nature of a thread by using isDaemon() method of thread class</p>
    <pre><code>
        public boolean isDaemon()
    </code></pre>
    <p>We can change daemon nature of a thread by using setDaemon method</p>
    <pre><code>
        public void setDaemon(boolean b)
    </code></pre>

    <p>But changing daemon nature is possible before starting of a thread only. After starting a thread if we are trying to 
        change daemon nature then we will get RE : IllegalThreadStateException
    </p>

    <h6>Default nature of thread</h6>
    <p>By default main thread is always non-daemon and for all remaining threads daemon nature 
        will be inherited from parent to child i.e if the parent thread is daemon then automatically child 
        thread is also daemon and if the parent thread is non-daemon then automatically child thread is also non-daemon
    </p>
    
    <mark>Note : It is impossible to change daemon nature of main thread because it is already started by JVM at beginning.</mark>

    <pre><code>
        class Daemon extends Thread {

        }
        
        class Test {
            public static void main(String[] args) throws InterruptedException {
                System.out.println(Thread.currentThread().isDaemon());
                //Thread.currentThread().setDaemon(true);   //RE:IllegalThreadStateException
                Daemon d  = new Daemon();
                System.out.println(d.isDaemon());
                d.setDaemon(true);
                System.out.println(d.isDaemon());
            }
        }
    </code></pre>
    
    <pre><output>
false
false
true

    </output></pre>
<p>Whenever last daemon thread terminates automatically all daemon threads will be terminated irrespective 
    of their position</p>
    
    <pre><code>
        class MyThread1 extends Thread {
            public void run() {
                for (int i = 0; i < 10; i++) {
                    System.out.println("Child thread");
                    try {
                        Thread.sleep(2000);
                    } catch(InterruptedException e) {
                        
                    }
                }
            }
        }
        
        class Test {
            public static void main(String[] args) throws InterruptedException {
                MyThread1 t = new MyThread1();
                t.setDaemon(true);	//line1
                t.start();
                System.out.println("End of main thread");
            }
        }
    </code></pre>
    <p>If we are commenting line1 both main and child threads are non-daemon and hence both 
        the threads will be executed until their execution</p>
    <p>If we are not commenting line1 then main thread is non-daemon and child thread is daemon 
        hence whenever main thread terminates, automatically child thread will be terminated. In this case output 
    is</p>
    <pre><output>
End of main thread
Child thread
    or
End of main thread
    or 
Child thread
End of main thread
    </output></pre>

<h6>GREEN Thread</h6>
<p>Java multithreading concept is implemented by using the following two models</p>
<p>1. GREEN thread model</p>
<p>2. Native OS model</p>
<h6>GREEN thread model</h6>
<p>The thread which is managed completely by JVM without taking underlying OS support is called 
    GREEN thread</p>
<p>Very few operating systems like SUN Solaries provide support for GREEN thread model. Anyway GREEN thread 
    model is depricated and not recommended to use</p>
<h6>Native OS model</h6>
<p>The thread which is managed by the JVM with the help of underlying OS, is called Native OS model. All 
    windows based operating system provide support for native OS model</p>

<p>How to stop a thread?</p>
<p>We can stop a thread execution by using stop() method of thread class.</p>
<pre><code>
    public void stop()
</code></pre>
<p>If we call stop() method then immediately that thread will enter into dead state. Anyway stop() method is depricated 
    and not recommended to use</p>

<p>How to suspend() and resume() of a thread?</p>
<p>We can suspend a thread by using suspend method of thread class then immediately that thread will be entered into suspended 
    state. We can resume a suspended thread by using resume() method of thread class then suspended thread can continue its execution</p>
    <pre><code>
        public void suspend()
        public void resume()
    </code></pre>
    <p>Anyway these metods are depricated and not recommended to use</p>



    <h5>10. Multithreading enhancements</h5>
    <h6>ThreadGroup</h6>
    <p>Based on functionality we can group threads into a single unit which is nothing but thread group i.e a thread group contains a group of threads 

    </p>
<p>In addition to threads, ThreadGroup can also contain SubThreadGroups</p> 
<img src="images/ss87.png" alt="ss12" width="400" height="500">

<p>The main advantage of maintaining threads in the form of ThreadGroup is we can perform commom operations very easily</p>
<p>Every thread in java belongs to some group. Main thread belongs to main group.</p>
<p>Every thread group in java is the child group of system group either directly or indirectly. Hence 
    system group acts as root for all Thread groups in java</p>
<p>System group contains several system level threads like</p>

<pre><code>
1. Finalizer
2. Reference Handler
3. Signal Dispatcher
4. Attach Listener
    . 
    . 
    .
</code></pre>

<img src="images/ss88.png" alt="ss12" width="400" height="600">

<pre><code>
    class Test {
        public static void main(String[] args) throws InterruptedException {
            System.out.println(Thread.currentThread().getThreadGroup().getName());
            System.out.println(Thread.currentThread().getThreadGroup().getParent().getName());
        }
    }
</code></pre>
<pre><output>
    main 
    system
</output></pre>

<p>ThreadGroup is a java class present in java.lang package and it is the direct child class of object.</p>

<h6>Constructors</h6>
<pre><code>
    ThreadGroup g = new ThreadGroup(String groupName);
</code></pre>
<p>Creates a new thread group with the specified group name. The parent of this new group is the ThreadGroup of 
    currently executing thread
</p>
<p>Example</p>
<pre><code>
    ThreadGroup g = new ThreadGroup("First Group");
</code></pre>
<hr>
<pre><code>
    ThreadGroup g = new ThreadGroup(ThreadGroup parentGroup, String groupName);
</code></pre>
<p>Creates a new thread group with the specified group name. The parent of this new thread group is specified parent group</p>
<p>Example</p>
<pre><code>
    ThreadGroup g1 = new ThreadGroup(g, "SecondGroup");
</code></pre>

<pre><code>
    class Test {
        public static void main(String[] args) throws InterruptedException {
            ThreadGroup g1 = new ThreadGroup("First Group");
            System.out.println(g1.getParent().getName());
            ThreadGroup g2 = new ThreadGroup(g1, "Second Group");
            System.out.println(g2.getParent().getName());
        }
    }
</code></pre>

<pre><output>
    main
    First Group
</output></pre>

<img src="images/ss89.png" alt="ss12" width="400" height="500">

<h6>Important methods of ThreadGroup class</h6>
<pre><code>
    1. String getName()
    returns name of the thread group 

    2. int getMaxPriority()
    returns max priority of ThreadGroup

    3. void setMaxPriority(int p)
    to set maximum priority of ThreadGroup(the default max priority is 10)
    Threads in the ThreadGroup that already have higher priority wont be affected but 
    for newly added threads this max priority is applicable
    <pre><code>
        class Test {
            public static void main(String[] args) throws InterruptedException {
                ThreadGroup g1 = new ThreadGroup("tg");
                Thread t1 = new Thread(g1, "Thread1");
                Thread t2 = new Thread(g1, "Thread2");
                g1.setMaxPriority(3);
                Thread t3 = new Thread(g1, "Thread3");
                System.out.println(t1.getPriority());
                System.out.println(t2.getPriority());
                System.out.println(t3.getPriority());
            }
        }
    </code></pre>
    
    <pre><output>
        5 
        5 
        3
    </output></pre>

    4. ThreadGroup getParent()
    return parent group of current thread 

    5. void list() 
    It prints information about thread group to the console 

    6. int activeCount()
    returns number of active threads present in the thread group

    7. int activeGroupCount() 
    It returns number of active groups present in the current thread group 

    8. int enumerate(Thread[] t)
    To copy all active threads of this thread group into provided thread array
    In this case sub thread group threads also will be considered

    9. int enumerate(ThreadGroup[] g)
    To copy all active sub thread groups into ThreadGroup array 

    10. boolean isDaemon()
    To check Whether the ThreadGroup is daemon or not 

    11. void setDaemon(boolean b)

    12. void interrupt()
    To interrupt all waiting or sleeping threads present in the ThreadGroup 

    13. void destroy()
    To destroy ThreadGroup and its sub thread groups

    
</code></pre>

<pre><code>
package com.cts.java;
class MyThread extends Thread {
	public MyThread(ThreadGroup g, String name) {
		super(g, name);
	}

	public void run() {
		System.out.println("Child Thread");
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {

		}
	}
}

class ThreadGroupDemo {
	public static void main(String[] args) throws InterruptedException {
		ThreadGroup parentGroup = new ThreadGroup("Parent group");
		ThreadGroup childGroup = new ThreadGroup(parentGroup, "Child Group");
		MyThread t1 = new MyThread(parentGroup, "ChildThread1");
		MyThread t2 = new MyThread(parentGroup, "ChildThread2");
		t1.start();
		t2.start();
		Thread.sleep(1000);
		System.out.println("activeCount : " + parentGroup.activeCount());
		System.out.println("activeGroupCount : " + parentGroup.activeGroupCount());
		parentGroup.list();
		Thread.sleep(6000);
		System.out.println("activeCount : " + parentGroup.activeCount());
		System.out.println("activeGroupCount : " + parentGroup.activeGroupCount());
		parentGroup.list();
	}
}
</code></pre>

<pre><output>
Child Thread
Child Thread
activeCount : 2
activeGroupCount : 1
java.lang.ThreadGroup[name=Parent group,maxpri=10]
    Thread[ChildThread1,5,Parent group]
    Thread[ChildThread2,5,Parent group]
    java.lang.ThreadGroup[name=Child Group,maxpri=10]
activeCount : 0
activeGroupCount : 1
java.lang.ThreadGroup[name=Parent group,maxpri=10]
    java.lang.ThreadGroup[name=Child Group,maxpri=10]
</output></pre>
<img src="images/ss90.png" alt="ss12" width="400" height="500">

<div class="container">
    <p class="bg-warning text-white">WAP to display all active thread names belongs to system group and its child groups.</p>
    <pre><code>
        public class ThreadGroupDemo1 {

            public static void main(String[] args) {
                ThreadGroup system = Thread.currentThread().getThreadGroup().getParent();
                Thread[] t = new Thread[system.activeCount()];
                system.enumerate(t);
                for(Thread t1 : t) {
                    System.out.println(t1.getName() + "........" + t1.isDaemon());
                }
            }
        
        }
        
    </code></pre>
    
    <pre><output>
Reference Handler........true
Finalizer........true
Signal Dispatcher........true
Attach Listener........true
main........false
Common-Cleaner........true
    </output></pre>
        
</div> 


<h6>java.util.concurrent package</h6>
<p>The problems with traditional synchronized keyword</p>
<p>1. We are not having any flexibility to try for a lock without waiting</p>
<p>2. There is no way to specify maximum waiting for a thread to get lock so that 
    thread will wait until getting the lock which may creates performance problem, which may 
    cause deadlock
</p>
<p>3. If a thread releases lock then which waiting thread will get that lock. We are not having 
    any control on this</p>
<p>4. There is no API to list out all waiting threads for a lock</p>

<p>5. The synchronized keyword compulsory we have to use either at method level or within a method and 
    its not possible to use accross methods</p>
<p>To overcome these problems SUN people introduced java.util.current.locks in 1.5v</p>

<p>It also provides several enhancements to the programmer to provide more control on concurrency.</p>

<h6>Lock(I)</h6>
<p>Lock object is similar to implicit lock acquired by a thread to execute synchronized method or synchronized block</p>
<p>Lock implementations provides more extensive operations then traditional implicit locks</p>

<h6>Important methods of Lock(I)</h6>
<p>1. void lock()</p>
<p>We can use this method to acquire a lock. If the lock is already available then immediately current thread 
    will get that lock. If the lock is not already available then it will wait until getting the lock. It is exactly same 
    behavior of traditional synchronized keyword</p>

<p>2. boolean tryLock() 
<p>To acquire the lock without waiting. If the lock is available then the thread acquires that lock and returns true. If the lock 
    is not available then this method returns false and can continue its execution without waiting. In this case thread never be 
    entered into waiting state</p>


    <pre><code>
        if(l.tryLock()) {
            Perform safe operations
        }
        else {
            Perform alternative operations
        }
    </code></pre>
        
<p>3. boolean tryLock(long time, TimeUnit unit)</p>
<p>If the lock is available then the thread will get the lock and continue its execution. If the lock is not available then the thread will 
    wait until specified amout of time. Still if the lock is not available then thread can continue its execution</p>

<p>Time Unit - </p>
<p>Time unitis an enum present in java.util.concurrent package</p>

<pre><code>
    enum TimeUnit {
        NANOSECONDS;
        MICROSECONDS; 
        MILLISECONDS;
        SECONDS;
        MINUTES;
        HOURS;
        DAYS;
    }
</code></pre>

<pre><code>
    if(l.tryLock(1000, TimeUnit.MILLISECONDS))
</code></pre>

<p>4. void lockInterruptibly()</p>
<p>Acquires the lock if it is available and return immediately</p>
<p>If the lock is not available then it will wait. While waiting if the thread is interrupted then thread wont get the lock</p>

<p>5. void unlock()</p>
<p>To releases the lock</p>
<p>To call this method compulsory current thread should be owner of the lock o/w we will get RE : saying 
    IllegalMonitorStateException
</p>

<h6>ReentrantLock(c)</h6>  
<p>It is the implementation class of Lock(I) and it is the direct child class of Object</p>
<p>Reentrant means a thread can acquire same lock multiple times without any issue. Internally Reentrant lock increments 
    threads personal count whenever we call lock method and decrements count value whenever thread calls 
    unlock() method and lock will be released whenever count reaches zero</p>

    <pre><code>
        ReentrantLock l = new ReentrantLock();

        Initially count = 0;

        l.lock();       //hold_count = 1
        l.lock();       //hold_count = 2
        l.lock();       //hold_count = 3
        l.unlock();     //hold_count = 2
        l.unlock();     //hold_count = 1
        l.unlock();     //hold_count = 0
    </code></pre>
    

<h6>Constructors</h6>
<pre><code>
    ReentrantLock l = new ReentrantLock();
</code></pre>
<p>creates an instance of ReentrantLock</p>
<pre><code>
    ReentrantLock l = new ReentrantLock(boolean fairness);
</code></pre>
<p>creates ReentrantLock with the given fairness policy</p>
<p>If the fairness is true then longest waiting thread can get the lock if it is available 
    i.e it follows FCFS policy. If fairness is false then which waiting thread will get the chance we 
    cant expect.
</p>
<mark>Note : The default value for fairness is false</mark>

<div class="container">
    <p class="bg-warning text-white">Which of the following declarations are equal?</p>
    <pre><code>
        1. ReentrantLock l = new ReentrantLock();
        2. ReentrantLock l = new ReentrantLock(true);
        3. ReentrantLock l = new ReentrantLock(false);
        4. All of the above
    </code></pre>
    <pre><output>
        1st and 3rd are equal
    </output></pre>
        
</div> 

<h6>Important methods of ReentrantLock</h6>
<pre><code>
    void lock()
    boolean tryLock()
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException
    void lockInterruptibly() throws InterruptedException
    void unlock()
    
    int getHoldCount()
    - returns number of holds on this lock by current thread 

    boolean isHeldByCurrentThread()
    - returns true iff lock is hold by current thread 

    int getQueueLength()
    - returns number of threads waiting for the lock

    Collection getQueuedThreads()
    - It returns a collection of threads which are waiting to get the lock
    
    boolean hasQueuedThreads()
    - returns true if any thread waiting to get the lock
    
    boolean isLocked()
    - returns true if the lock is acquired by some thread
    
    boolean isFair()
    - returns true if the fairness policy is set with true value
    
    Thread getOwner()
    - returns the thread which acquires the lock
</code></pre>


<pre><code>
import java.util.concurrent.locks.*
class ReentrantLock {
    public static void main(String[] args) {
        ReentrantLock l = new ReentrantLock();
        l.lock();
        l.lock();
        System.out.println(l.isLocked());
        System.out.println(l.isHeldByCurrentThread());
        System.out.println(l.getQueueLength());
        l.unlock();
        System.out.println(l.getHoldCount());
        System.out.println(l.isLocked());
        l.unlock();
        System.out.println(l.isLocked());
        System.out.println(l.isFair());
    }
}
</code></pre>
<pre><output>
    true 
    true 
    0 
    1 
    true
    false 
    false
</output></pre>

<pre><code>
    import java.util.concurrent.locks.*;
    class Display {
        ReentrantLock l = new ReentrantLock();
        public void wish(String name) {
            l.lock();   //line 1
            for (int i = 0; i < 10; i++) {
                System.out.print("Good Morning:");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    System.out.println(name);
                }
                System.out.println(name);
            }
            l.unlock();     //line2
        }
    }
    
    class MyThread extends Thread {
        Display d;
        String name;
        public MyThread(Display d, String name) {
            this.d = d;
            this.name = name;
        }
        public void run() {
            d.wish(name);
        }
    }
    public class ReentrantLockDemo {
        public static void main(String[] args) {
            Display d = new Display();
            MyThread t1 = new MyThread(d, "Dhoni");
            MyThread t2 = new MyThread(d, "Yuvraj");
            MyThread t2 = new MyThread(d, "Kohli");
            t1.start();
            t2.start();
            t3.start();
        }
    }
}
</code></pre>
<pre><output>
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Yuvraj
Good Morning:Kohli
Good Morning:Kohli
Good Morning:Kohli
Good Morning:Kohli
Good Morning:Kohli
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni
Good Morning:Dhoni

</output></pre>


<p>If we comment line1 and line2 then the threads will be executed simultaneously and we will get irregular output</p>
<p>If we are not commenting line1 and line2 then the threads will be executed one by one and we will get regular output</p>

<h6>Demo program for tryLock() method</h6>
<pre><code>

import java.util.concurrent.locks.ReentrantLock;
class MyThread extends Thread {
	static ReentrantLock l = new ReentrantLock();
	public MyThread(String name) {
		super(name);
	}
  
    public void run() {
        if(l.tryLock()) {
        	System.out.println(Thread.currentThread().getName() + ""
        			+ " got lock and performing safe operations");
        	try {
        		Thread.sleep(2000);
        	} catch(InterruptedException e) {
        		l.unlock();
        	}
        } else {
        	System.out.println(Thread.currentThread().getName() + ""
        			+ " ...unable to get lock and hence performing alternative "
        			+ "operations");
        }
    }
}
public class ReentrantLockDemo {
    public static void main(String[] args) {
        MyThread t1 = new MyThread("First Thread");
        MyThread t2 = new MyThread("Second Thread");
        t1.start();
        t2.start();
    }
}
</code></pre>
<pre><output>
Second Thread got lock and performing safe operations
First Thread ...unable to get lock and hence performing alternative operations
        or 
First Thread got lock and performing safe operations
Second Thread ...unable to get lock and hence performing alternative operations        
</output></pre>

<pre><code>
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

class MyThread extends Thread {
	static ReentrantLock l = new ReentrantLock();

	public MyThread(String name) {
		super(name);
	}

	public void run() {
		do {
			try {

				if (l.tryLock(5000, TimeUnit.MILLISECONDS)) {
					System.out.println(Thread.currentThread().getName() + "" + " got lock");

					Thread.sleep(30000);

					l.unlock();
					System.out.println(Thread.currentThread().getName() + "" + " releases lock");
					break;

				} else {
					System.out.println(
							Thread.currentThread().getName() + "" + " ...unable to get lock and will try again");
				}
			} catch (Exception e) {
			}
		} while (true);
	}
}

public class ReentrantLockDemo {
	public static void main(String[] args) {
		MyThread t1 = new MyThread("First Thread");
		MyThread t2 = new MyThread("Second Thread");
		t1.start();
		t2.start();
	}
}
</code></pre>
<pre><output>
First Thread got lock
Second Thread ...unable to get lock and will try again
Second Thread ...unable to get lock and will try again
Second Thread ...unable to get lock and will try again
Second Thread ...unable to get lock and will try again
Second Thread ...unable to get lock and will try again
First Thread releases lock
Second Thread got lock
Second Thread releases lock

</output></pre>


<h6>Thread Pools(Executor framework)</h6>
<p>Creating a new thread for every job may create performance and memory problems, to overcome this 
    we should go for ThreadPool</p>
<p>ThreadPool is a pool of already created threads ready to do our job</p>
<p>Java 1.5v introduces ThreadPool framework to implement thread pools</p>
<p>ThreadPool framework is also known as Executor Framework</p>

<p>We can create a thread pool as follows</p>
<pre><code>
    ExecutorService service = Executors.newFixedThreadPool(3);
</code></pre>
<p>We can submit a runnable job by using a submit method</p>
<pre><code>
    service.submit(job);
</code></pre>
<p>We can shutdown Executor service by using shutdown method</p>
<pre><code>
    service.shutdown();
</code></pre>

<pre><code>
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

class PrintJob implements Runnable {
	String name;

	public PrintJob(String name) {
		this.name = name;
	}

	public void run() {
		System.out.println(name + "...Job started by Thread : " + Thread.currentThread().getName());
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {

		}
		System.out.println(name + "...Job completed by Thread : " + Thread.currentThread().getName());
	}
}

public class ExecutorDemo {

	public static void main(String[] args) {
		PrintJob[] jobs = { new PrintJob("Durga"), new PrintJob("Ravi"), new PrintJob("Shiva"), new PrintJob("Pavan"),
				new PrintJob("Suresh"), new PrintJob("Anil") };

		ExecutorService service = Executors.newFixedThreadPool(3);
		for (PrintJob job : jobs) {
			service.submit(job);
		}
		service.shutdown();
	}

}

</code></pre>

<pre><output>
    Shiva...Job started by Thread : pool-1-thread-3
    Durga...Job started by Thread : pool-1-thread-1
    Ravi...Job started by Thread : pool-1-thread-2
    Durga...Job completed by Thread : pool-1-thread-1
    Ravi...Job completed by Thread : pool-1-thread-2
    Shiva...Job completed by Thread : pool-1-thread-3
    Pavan...Job started by Thread : pool-1-thread-3
    Suresh...Job started by Thread : pool-1-thread-1
    Anil...Job started by Thread : pool-1-thread-2
    Pavan...Job completed by Thread : pool-1-thread-3
    Suresh...Job completed by Thread : pool-1-thread-1
    Anil...Job completed by Thread : pool-1-thread-2
</output></pre>

<p>In the above example 3 threads are responsible to execute 6 jobs so that a single thread can 
    be reused for multiple jobs.
</p>

<mark>Note : While developing Web servers and application servers we can use ThreadPool concept.</mark>

<h6>Callable and Future</h6>
<p>In the case of Runnable job thread wont return anything after completing the job</p>
<p>If a thread is required to return some result after execution then we should go for Callable</p>
<p>Callable interface contains only one method i.e call()</p>
<pre><code>
    public Object call() throws Exception
</code></pre>
<p>If we submit a Callable object to executor then after completing the job thread returns an object of the type Future 
    i.e Future object can be used to retrieve the result from Callable job.
</p>

<pre><code>
    import java.util.concurrent.Callable;
    import java.util.concurrent.ExecutionException;
    import java.util.concurrent.ExecutorService;
    import java.util.concurrent.Executors;
    import java.util.concurrent.Future;
    
    class MyCallable implements Callable {
    
        int num;
    
        public MyCallable(int num) {
            this.num = num;
        }
    
        @Override
        public Object call() throws Exception {
            System.out
                    .print(Thread.currentThread().getName() + " is responsible to find sum of first " + num + " numbers : ");
            int sum = 0;
            for (int i = 1; i <= num; i++) {
                sum = sum + i;
            }
            return sum;
        }
    
    }
    
    public class CallableFutureDemo {
    
        public static void main(String[] args) throws InterruptedException, ExecutionException {
            MyCallable[] jobs = { new MyCallable(10), new MyCallable(20), new MyCallable(30), new MyCallable(40),
                    new MyCallable(50), new MyCallable(100) };
            
            ExecutorService service = Executors.newFixedThreadPool(3);
            for(MyCallable job : jobs) {
                Future f = service.submit(job);
                System.out.println(f.get());
            }
            service.shutdown();
        }
    
    }
      
</code></pre>

<pre><output>
    pool-1-thread-1 is responsible to find sum of first 10 numbers : 55
    pool-1-thread-2 is responsible to find sum of first 20 numbers : 210
    pool-1-thread-3 is responsible to find sum of first 30 numbers : 465
    pool-1-thread-1 is responsible to find sum of first 40 numbers : 820
    pool-1-thread-2 is responsible to find sum of first 50 numbers : 1275
    pool-1-thread-3 is responsible to find sum of first 100 numbers : 5050    
</output></pre>

<h6>Differences between Runnable and Callable</h6>
<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>Runnable</th>
            <th>Callable</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>If a thread not required to return anything after completing the job then we should go for Runnable</td>
            <td>If a thread required to return something after completing the job then we should go for Callable</td>
        </tr>  
        <tr>
            <td>Runnable interface conatins only one method run()</td>
            <td>Callable interface contains only one method call()</td>
        </tr><tr>
            <td>Runnable job not required to return anything hence return type of run() method is void</td>
            <td>Callable job is required to return something and hence return type of call() method is Object</td>
        </tr><tr>
            <td>Within the run() method if there is any chance of raising checked exception compulsory we should handle 
                by using try catch because we cant use throws keyword for run() method
            </td>
            <td>Within call() method if there is any chance of raising checked exception we are not required to handle by using try catch 
                because call() method already throws exception
            </td>
        </tr><tr>
            <td>Runnable interface present in java.lang package</td>
            <td>Callable interface present in java.util.concurrent package</td>
        </tr>
        <tr>
            <td>Introduced in 1.0v</td>
            <td>Introduced in 1.5v</td>
        </tr>
    </tbody>
</table>

<h6>ThreadLocal</h6>
<p>ThreadLocal class provides thread local variables</p>
<p>ThreadLocal class maintains values per thread basis</p>
<p>Each ThreadLocal object maintains a separate value like userId, transactionId etc for each thread that accesses that object, 
    thread can access its local value, manipulate its value and even can remove its value</p>
<p>In every part of the code which is executed by the thread we can access its local variable</p>


<p>Example - Consider a servlet which invokes some business methods, we have a requirement to generate a unique transactionId for each and 
    every request and we have to pass this transactionId to the business methods. For this requirement we can use ThreadLocal to maintain a separate 
    transactionId for every request i.e for every thread</p>

<p>Note : </p>
<p>1. ThreadLocal class introduced in 1.2v and enhanced in 1.5v</p>
<p>2. ThreadLocal can be associated with Thread scope</p>
<p>3. Total code which is executed by the thread has access to the corressponding thread local variables</p>
<p>4. A thread can access its own local variables and cant access other threads local variables</p>
<p>5. Once the thread entered into dead state, all its local variables are by default eligible for garbage collection</p>  

<h6>Constructors</h6>
<pre><code>
    ThreadLocal threadLocal = new ThreadLocal();
</code></pre>
<p>creates a ThreadLocal variable</p>

<h6>Methods</h6>
<pre><code>
    1. Object get()
    - returns the value of ThreadLocal variable associated with current thread

    2. Object initialValue()
    - returns initial value of ThreadLocal variable associated with current thread 
    The default implementation of this method returns null. To customize our own initial value 
    we have to override this method

    3. void set(Object newValue)
    - to set a new value

    4. void remove()
    - to remove the value of ThreadLocal variable associated with current thread
    It is newly added method in 1.5v. After removal if we are trying to access it 
    will be reinitialized once again by invoking its initial value method.
</code></pre>

<pre><code>
    class ThreadLocal {
        public static void main(String[] args) {
            ThreadLocal threadLocal = new ThreadLocal();
            System.out.println(threadLocal.get());
            threadLocal.set("durga");
            System.out.println(threadLocal.get());
            threadLocal.remove();
            System.out.println(threadLocal.get());
        }
    }
</code></pre>
<pre><output>
    null
    durga 
    null
</output></pre>

<h6>Overriding of initialValueMethod()</h6>
<pre><code>
    class ThreadLocal {
        public static void main(String[] args) {
            ThreadLocal threadLocal = new ThreadLocal() 
            {
                public Object initialValue() {
                    return "abc";
                }
            };
            System.out.println(threadLocal.get());
            threadLocal.set("durga");
            System.out.println(threadLocal.get());
            threadLocal.remove();
            System.out.println(threadLocal.get);
        }
    }
</code></pre>
<pre><output>
    abc 
    durga 
    abc
</output></pre>

<pre><code>
    class CustomerThread extends Thread {
        static Integer custId = 0;
        private static ThreadLocal threadLocal = new ThreadLocal()
                {
                    protected Integer initialValue() {
                        return ++custId;
                    }
                };
                public CustomerThread(String name) {
                    super(name);
                }
                public void run() {
                    System.out.println(Thread.currentThread().getName() + " "
                            + "executing with Customer id : " + threadLocal.get());
                }
    }
    public class ThreadLocal {
    
        public static void main(String[] args) {
            CustomerThread c1 = new CustomerThread("CustomerThread - 1");
            CustomerThread c2 = new CustomerThread("CustomerThread - 2");
            CustomerThread c3 = new CustomerThread("CustomerThread - 3");
            CustomerThread c4 = new CustomerThread("CustomerThread - 4");
            c1.start();
            c2.start();
            c3.start();
            c4.start();
        }
    
    }
    
</code></pre>

<p>In the above program for every customer thread a separate customerId will be maintained by ThreadLocal object</p>

<h6>ThreadLocal vs Inheritance</h6>
<p>Parent threads ThreadLocal variable by default not available to the child thread. If we want 
    to make parent threads ThreadLocal variable value available to the child thread then we should go for inheritable ThreadLocal class</p>
    <p>By default child thread value is exactly same as parent threads value. But we can provide customized value for child thread by overriding 
        child value method.
</p>

<h6>Constructor</h6>
<pre><code>
    InheritableThreadLocal threadLocal = new InheritableThreadLocal();
</code></pre>

<h6>Methods</h6>
<p>InheritableThreadLocal is the child class of ThreadLocal and hence all methods present in ThreadLocal by default available to 
    InheritableThreadLocal. In addition to these methods it contains only one method - </p>
    <pre><code>
        public Object childValue(Object parentValue)
    </code></pre>
<pre><code>
    class ParentThread extends Thread {
        public static InheritableThreadLocal threadLocal = new InheritableThreadLocal() 
        {
            public Object childValue(Object p) {
                return "CC";
            }
        };
        public void run() {
            threadLocal.set("pp");
            System.out.println("Parent thread value - " + threadLocal.get());
            ChildThread childThread = new ChildThread();
            childThread.start();
        }
    }
    class ChildThread extends Thread {
        public void run() {
            System.out.println("Child Thread value - " + ParentThread.threadLocal.get());
        }
    }
    class ThreadLocalDemo {
        public static void main(String[] args) {
            ParentThread parentThread = new ParentThread();
            parentThread.start();
        }
    }
</code></pre>
    
<pre><output>
Parent Thread value--pp
Child Thread value--CC
</output></pre>

<p>In the above program if we replace InheritableThreadLocal with ThreadLocal and if we are not overriding 
    childValue() method then the output is -</p>
    <pre><output>
        Parent Thread value--pp
        Child Thread value--null
    </output></pre>

    <p>In the above program if we are maintaining InheritableThreadLocal and if we are not overriding childValue() method 
        then the output is - </p>
    <pre><output>
        Parent Thread value--pp
        Child Thread value--pp
</output></pre>



<h1>Inner classes</h1>
    <p>Sometimes we can declare a class inside another class such type of classes are called inner classes</p>
    <p>Inner classes concept introduced in 1.1v to fix GUI bugs as a part of event handling but becuase of powerful features 
        and benefits of inner classes slowly programmers started using in regular coding also</p>
    <p>Without existing one type of object if there is no chance of existing another type of object then we should go for inner classes</p>
    <p>Example 1 : University consists of several departments. Without existing university there is no chance of existing department hence 
        we have to declare department class inside university class</p>
        <pre><code>
            class University {

                class Department {

                }
            
            }
        </code></pre>
    <p>Example 2 : Without existing Car object there is no chance of existing Engine object hence we have to declare Engine class
        inside CAR class</p>
        <pre><code>
            class Car {

                class Engine {

                }

            }
        </code></pre>
    <p>Example 3 : Map is a group of key value pairs and each key value pair is called an entry. Without existing Map object there is no chance 
        of existing Entry object. Hence interface Entry is defined inside Map interface
    </p>

    <pre><code>
        interface Map {

            interface Entry {

            }

        }
    </code></pre>
    <br>
    <mark>Note : 1. Without existing outer class object there is no chance of existing inner class object
        <br>2. The relation between outer class and inner class is not Is-A relation and it is Has-A relationship(composition or aggregation)
    </mark>
    <br>

    <p>Based on position of declaration and behavior all inner classes are divided into 4 types</p>
    <p>1. Normal or regular Inner classes</p>
    <p>2. Method local Inner classes</p>
    <p>3. Annonymous Inner classes</p>
    <p>4. Static Nested classes</p>

    <h3>1. Normal or regular Inner classes</h3>
    <p>If we are declaring any named class directly inside a class without static modifier such type of inner class is called 
        normal or regular inner class</p>
        <pre><code>
            class Outer {

                class Inner {

                }

            }
        </code></pre>
    <p>Saved the program as Outer.java</p>

    <pre><output>
        javac Outer.java    //Outer.class and Outer$Inner.class generated
        java Outer
        Main method not found in class Outer, please define the main method as:
        public static void main(String[] args)
        java Outer$Inner 
        Main method not found in class Outer, please define the main method as:
        public static void main(String[] args)
    </output></pre> 

    <pre><code>
        class Outer {
            class Inner {

            }
            public static void main(String[] args) {
                SOP("Outer class main method");
            }
        }
    </code></pre>
    
    <pre><output>
        javac Outer.java    //Outer.class and Outer$Inner.class generated
        java Outer
        Outer class main method
        java Outer$Inner 
        RE : NoSuchMethodError : main
    </output></pre>

    <p>Inside Inner class we cant declare any static members hence we cant declare mai method and we cant 
        run inner class directly from command prompt</p>
    <pre><code>
        class Outer {
            class Inner {
                public static void main(String[] args) {
                            System.out.println("Inner class main method");
                }
            }
        }
    </code></pre>
    
    <pre><output>
        CE : Inner classes cannot have static declarations
    </output></pre>

    <h6>Case 1 : </h6>
    <p>Accessing inner class code from static area of outer class</p>
    <pre><code>
        class Outer {
            class Inner {
                public void m1() {
                            System.out.println("Inner class method");
                    }
                 }
            public static void main(String[] args) {
                Outer outer = new Outer();
                Outer.Inner inner = outer.new Inner();
                inner.m1();
            }
        }
    </code></pre>
    
    <pre><output>
        javac Outer.java 
        java Outer 
        Inner class method 
    </output></pre>

    <p>Another shortcut methods</p>
    <pre><code>
        class Outer {
            class Inner {
                public void m1() {
                            System.out.println("Inner class method");
                    }
                 }
            public static void main(String[] args) {
                Outer.Inner inner = new Outer().new Inner();
                inner.m1();
            }
        }
    </code></pre>
    <pre><code>
        class Outer {
            class Inner {
                public void m1() {
                            System.out.println("Inner class method");
                    }
                 }
            public static void main(String[] args) {
                
                new Outer().new Inner().m1();
                
            }
        }
    </code></pre>

<h6>Case 2 : </h6>
<p>Accessing Inner class code from instance area of outer class</p>
<pre><code>
    class Outer {
        class Inner {
            public void m1() {
                        System.out.println("Calling Inner class method from outer class instance area");
                }
             }
        public void m2() {
            Inner inner = new Inner();
            inner.m1();
        }
        public static void main(String[] args) {
            Outer outer = new Outer();
            outer.m2();
        }
    }
</code></pre>

<h6>Case 3 : </h6>
<p>Accessing Inner class code from outside of Outer class</p>
<pre><code>
    class Outer {
        class Inner {
            public void m1() {
                        System.out.println("Inner class method");
                }
             }
    }
    class Test {
        public static void main(String[] args) {
            Outer outer = new Outer();
            Outer.Inner inner = outer.new Inner();
            inner.m1();	
        }
    }
</code></pre>

<pre><output>
    javac Test.java 
    java Test 
    Inner class method
</output></pre>

<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>From static area of Outer class</th>
            <th>From outside of outer class</th>
            <th>From instance area of Outer class</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>
<pre><code>
    Outer outer = new Outer();
    Outer.Inner inner = outer.new Inner();
    inner.m1();
</code></pre>
            </td>
            <td>
<pre><code>
    Outer outer = new Outer();
    Outer.Inner inner = outer.new Inner();
    inner.m1();
</code></pre>
            </td>
            <td>
<pre><code>
    Inner inner = new Inner();
    inner.m1();
</code></pre>
            </td>
        </tr>  
    </tbody>
</table>

<p>From normal or regular Inner class we can access both static and non-static members of outer class directly</p>
<pre><code>
    class Outer {
        int x = 10;
        static int y = 20;
        class Inner {
            public void m1() {
                    System.out.println(x);
                    System.out.println(y);
            }
        }
    
        public static void main(String[] args) {
            new Outer().new Inner().m1();
        }
    }
</code></pre>

<pre><output>
    javac Outer.java 
    10 
    20
</output></pre>

<p>Within the Inner class this always refers current Inner class object. If we want to refer current Outer class object we have to 
    use outerclassname.this</p>
<pre><code>
public class Outer {

	int x = 10;

	class Inner {
		int x = 100;

		public void m1() {
			int x = 1000;
			System.out.println(x);
			System.out.println(this.x);
			System.out.println(Inner.this.x);
			System.out.println(Outer.this.x);
		}
	}

	public static void main(String[] args) {
		new Outer().new Inner().m1();
	}

}

</code></pre>

<pre><output>
1000
100
100
10  
</output></pre>

<p>The only applicable modifiers for outer classes are public, default, final, abstract, strictfp</p>
<p>But for Inner classes applicable modifiers are public, default, final, abstract, strictfp, private, protected, static</p>

<h6>Nesting of inner classes</h6>
<p>Inside inner class we can declare another inner class i.e nesting of inner classes is possible</p>
<pre><code>
    class A {
        class B {
            class C {
                public void m1() {
                    System.out.println("Innermost class method");
                }
            }
        }
    }
    public class Test {
    
        public static void main(String[] args) {
            A a = new A();
            A.B b = a.new B();
            A.B.C c = b.new C();
            c.m1();
        }
    
    }
    
</code></pre>

<pre><output>
    Innermost class method
</output></pre>

<p>Alternative</p>
<pre><code>
    class A {
        class B {
            class C {
                public void m1() {
                    System.out.println("Innermost class method");
                }
            }
        }
    }
    public class Test {
    
        public static void main(String[] args) {
            
            new A().new B().new C().m1();
        }
    
    }
    
</code></pre>

<h3>2. Method Local Inner classes</h3>
<p>Sometimes we can declare a class inside a method, such type of Inner classes are called Method 
    Local Inner classes</p>
<p>The main purpose of method local inner class is to define method specific repeatedly required functionality</p>
<p>Method local inner classes are best suitable to meet nested method requirements</p>
<p>We can access method local inner classes only within a method where we declare. Outside of the method we 
    cant access. Because of its less scope method local inner classes are most rarely used type of inner classes
</p>

<pre><code>
    package com.cts.java;

public class Test {
	
	public void m1() {
		class Inner {
			public void sum(int x, int y) {
				System.out.println("The sum : " + (x + y));
			}
		}
		Inner i = new Inner();
        i.sum(10, 20);
        ;;;;;;;;;;;;;;;;
        i.sum(100, 200);
        ;;;;;;;;;;;;;;;;
		i.sum(1000, 2000);
	}

	public static void main(String[] args) {
		Test t = new Test();
		t.m1();
	}

}

</code></pre>

<pre><output>
The sum : 30
The sum : 300
The sum : 3000

</output></pre>

<p>We can declare method local inner class inside both instance and static methods</p>

<p>If we declare inner class inside instance method then from that method local inner class we can access both 
    static and non-static members of outer class directly</p>

<p>If we declare inner class inside static method then we can access only static members of outer class directly
from that method local inner class</p>

<pre><code>
public class Test {
	
	int x = 10;
	static int y = 20;
	
	public void m1() {
		class Inner {
			public void m2() {
				System.out.println(x);
				System.out.println(y);
			}
		}
		Inner i = new Inner();
		i.m2();
	}

	public static void main(String[] args) {
		Test t = new Test();
		t.m1();
	}

}

</code></pre>

<pre><output>
    10 
    20
</output></pre>

<p>If we declare m1() method as static then we will get CE saying non-static variable x cannot be referenced 
    from a static context</p> 
<pre><code>
public class Test {
	
	int x = 10;
	static int y = 20;
	
	public static void m1() {
		class Inner {
			public void m2() {
				System.out.println(x);
				System.out.println(y);
			}
		}
		Inner i = new Inner();
		i.m2();
	}

	public static void main(String[] args) {
		Test t = new Test();
		t.m1();
	}

}
  
</code></pre>

<pre><output>
    CE :  non-static variable x cannot be referenced from a static context
</output></pre>

<mark>&#10040&#10040&#10040From metod local inner class we cant access local variables of 
    the method in which we declare inner class. If the local variable declared as final then we can access.</mark>
    <pre><code>
        public class Test {

            public void m1() {
                int x = 10;
                class Inner {
                    public void m2() {
                        System.out.println(x);
                    }
                }
                Inner i = new Inner();
                i.m2();
            }
        
            public static void main(String[] args) {
                Test t = new Test();
                t.m1();
            }
        
        }
        
    </code></pre>
    
    <pre><output>
        CE : local variable x is accessed from within inner class; needs to 
        be declared final
    </output></pre>

    <p>If we declare x as final then we wont get any CE</p>

    <div class="container">
        <p class="bg-warning text-white">Consider the following code</p>
        <pre><code>
            public class Test {
	
                int i = 10;
                static int j = 20;
            
                public void m1() {
                    int k = 30;
                    final int m = 40;
                    
                    class Inner {
                        public void m2() {
                            //Line 1
                        }
                    }
                    
                    Inner i = new Inner();
                    i.m2();
                    
                }
            
                public static void main(String[] args) {
                    Test t = new Test();
                    t.m1();
                }
            
            }
            
        </code></pre>
        <p>1. At line 1 which of the following variables we can access directly?</p>
        <p>1. i</p>
        <p>2. j</p>
        <p>3. k</p>
        <p>4. m</p>
        <pre><output>
            i j and k only
        </output></pre>
        <p>2. If we declare m1() method as static then at line 1 which variables we can access directly?</p>

        <pre><output>
            j and m only
        </output></pre>
        <p>3. If we declare m2() method as static then at line 1 which variables we can access directly?</p>
        

        <pre><output>
            We will get CE because we cant declare static members inside inner classes
        </output></pre>
        
        
    </div>
<p>The only applicable modifiers for method local inner classes are final abstract strictfp. If we are trying to apply 
    any other modifier then we will get CE</p>

<h3>3. Annonymous inner classes</h3>
<p>Sometimes we can declare inner class without name such type of inner classes are called Annonymous inner classes</p>
<p>The main purpose of Annonymous inner classes is just for instant use(one time usage)</p>
<p>Based on declaration and behavior there are 3 types of Annonymous inner classes</p>
<p>1. Annonymous inner class that extends a class</p>
<p>2. Annonymous inner class that implements an interface</p>
<p>3. Annonymous inner class that defined inside arguments</p>

<h6>1. Annonymous inner class that extends a class</h6>
<pre><code>
    package com.cts.java;
class PopCorn {
	public void taste() {
		System.out.println("salty");
	}
}
public class Test {
	
	public static void main(String[] args) {
		PopCorn p = new PopCorn() {
			public void taste() {
				System.out.println("spicy");
			}
		};
		p.taste();
		
		PopCorn p1 = new PopCorn();
		p1.taste();
		
		PopCorn p2 = new PopCorn() {
			public void taste() {
				System.out.println("sweet");
			}
		};
		p2.taste();
				
		System.out.println(p.getClass().getName());
		System.out.println(p1.getClass().getName());
		System.out.println(p2.getClass().getName());
		
	}

}

</code></pre>

<pre><output>
spicy
salty
sweet
com.cts.java.Test$1
com.cts.java.PopCorn
com.cts.java.Test$2

</output></pre>

<h6>Analysis</h6>
<p>PopCorn p = new PopCorn();</p>
<p>Just we are creating PopCorn object</p>

<p>PopCorn p = new PopCorn
    {

    };</p>
<p>1. We are declaring a class that extends PopCorn without name(Annonymous inner class)</p>
<p>2. For that child class we are creating an object with parent reference</p>

<p>PopCorn p = new PopCorn()
    {
        public void taste() {
            SOP("spicy");
        }
    }
</p>
<p>1. We are declaring a class that extends PopCorn without name(Annonymous inner class)</p>
<p>2. In that child class we are overriding taste() method</p>
<p>3. For that child class we are creating an object with parent reference</p>

<p>Defining a thread by extending thread class</p>
<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>Normal class approach</th>
            <th>Annonymous inner class approach</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>
<pre><code>
class MyThread extends Thread {
    public void run() {
        for(int i = 0; i < 10; i++) {
            System.out.println("Child Thread");
        }
    }
}
class ThreadDemo {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();
        for(int i = 0; i < 10; i++) {
            System.out.println("Main Thread");
        }
    }
}
</code></pre>
            </td>
            <td>
<pre><code>
class ThreadDemo {
    public static void main(String[] args) {
        Thread t = new Thread() {
            public void run() {
                for(int i = 0; i < 10; i++) {
                    System.out.println("Child Thread");
                }
            }
        };
        t.start();
        for(int i = 0; i < 10; i++) {
            System.out.println("Main Thread");
        }
    }
}
</code></pre>
            </td>
        </tr>  
    </tbody>
</table>

<h6>2. Annonymous inner class that implements an interface</h6>
<h6>Defining a thread by implementing Runnable interface</h6>

<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>Normal class approach</th>
            <th>Annonymous inner class approach</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>
<pre><code>
class MyRunnable implements Runnable {
    public void run() {
        for(int i = 0; i < 10; i++) {
            System.out.println("Child Thread");
        }
    }
}
class ThreadDemo {
    public static void main(String[] args) {
        MyRunnable r = new MyRunnable();
        Thread t = new Thread(r);
        t.start();
        for(int i = 0; i < 10; i++) {
            System.out.println("Main Thread");
        }
    }
}
</code></pre>
            </td>
            <td>
<pre><code>
class ThreadDemo {
    public static void main(String[] args) {
        Runnable r = new Runnable() {
            public void run() {
                for(int i = 0; i < 10; i++) {
                    System.out.println("Child Thread");
                }
            }
        };
        Thread t = new Thread(r);
        t.start();
        for(int i = 0; i < 10; i++) {
            System.out.println("Main Thread");
        }
    }
}  
</code></pre>
            </td>
        </tr>  
    </tbody>
</table>


<h6>3. Annonymous inner class that define inside arguments</h6>
<pre><code>
    public class ThreadDemo {
        public static void main(String[] args) {
            new Thread(new Runnable() {
    
                @Override
                public void run() {
                    for (int i = 0; i < 10; i++) {
                        System.out.println("Child Thread");
                    }
                }
            }).start();
    
            for (int i = 0; i < 10; i++) {
                System.out.println("Main Thread");
            }
        }
    }
    
</code></pre>

<h5>Difference between normal java class and Annonymous inner class</h5>
<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>Normal Java class</th>
            <th>Annonymous inner class</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>A normal java class can extend only one class at a time.</td>
            <td>Ofcourse Annonymous inner class can also extend only one class at a time</td>
        </tr>  
        <tr>
            <td>A normal java class can implement any number of interfaces simultaneously</td>
            <td>Annonymous inner class can implement only one interface at a time</td>
        </tr>  
        <tr>
            <td>A normal java class can extend a class and can implement any number of interfaces simultaneously</td>
            <td>Annonymous inner class can extend a class or can implement an interface but not both simultaneously</td>
        </tr>  
        <tr>
            <td>In normal java class we can write any number of constructors</td>
            <td>In Annonymous inner classes we cant write any constructor explicitly(because the name of the class and name of the 
                constructor must be same but Annonymous inner classes not having any name)</td>
        </tr> 
        <tr>
            <td>If the requirement is standard and required several times then we should go for normal top level class</td>
            <td>If the requirement is temporary and required only once(instant use) then we should go for Annonymous inner class</td>
        </tr>  
    </tbody>
</table>

<div class="container">
    <p class="bg-warning text-white">Where Annonymous inner classes are best suitable?</p>
    <p>We can use Annonymous inner classes frequently in GUI based applications to implement event handling</p>   
</div> 

<h3>Static nested classes</h3>
<p>Sometimes we can declare inner class with static modifier such type of inner classes are called static nested classes</p>
<p>In the case of normal or regular inner class without existing outer class object there is no chance of existing inner class object i.e 
    inner class object is strongly associated with outer class object</p>
<p>But in the case of static nested classes, without existing outer class object there may be a chance of existing nested class object hence 
    static nested class object is not strongly associated with outer class object</p>
    <pre><code>
        class Outer {
            static class Nested {
                public void m1() {
                    SOP("Static nested class method");
                }
            }
            public static void main(String[] args) {
                Nested n = new nested();
                n.m1();
            }
        }
    </code></pre> 
    <pre><output>
        Static nested class method
    </output></pre>

    <p>If we want to create nested class object from outside ofouter class then we can create as follows-</p>
    <pre><code>
        Outer.Nested n = new Outer.Nested();
    </code></pre>

    <p>In normal or regular inner classes we cant declare any static members but in static nested classes we can declare 
        static members including main method hence we can invoke static nested class directly from command prompt</p>
        <pre><code>
            class Test {
                static class Nested {
                    public static void main(String[] args) {
                        SOP("static nested class main method");
                    }
                }
                public static void main(String[] args) {
                    SOP("outer class main method");
                }
            }
        </code></pre>
        
        <pre><output>
            javac Test.java 
            java Test 
            outer class main method 
            java Test$Nested 
            static nested class main method
        </output></pre>
    
        <p>From normal or regular inner classes we can access both static and non static members of outer class directly but 
            from static nested classes we can access static members of outer class directly and we cant access non static 
            members</p>

            <pre><code>
                class Test {
                    int x = 10;
                    static int y = 20;
                    static class Nested {
                        public void m1() {
                            System.out.println(x);
                            System.out.println(y);
                        }
                    }
                }
            </code></pre>
            
            <pre><output>
                CE : non-static variable x cannot be referenced from a static context
            </output></pre>  
<h6>Differences between normal or regular inner class and static nested class</h6>
<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>Normal or regular inner class</th>
            <th>Static nested classes</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>Without existing outer class object there is no chance of existing inner class object 
                i.e inner class object is strongly associated with outer class object
            </td>
            <td>Without existing outer class object there may be a chance of existing nested class object
                 hence static nested class object is not strongly associated with outer class object</td>
        </tr>
        <tr>
            <td>In normal or regular inner classes we cant declare any static members</td>
            <td>In static nested classes we can declare static members</td>
        </tr>
        <tr>
            <td>In normal or regular inner class we cant declare main method and hence we cant invoke inner class directly 
                from command prompt
            </td>
            <td>In static nested classes we can declare main method and hence we can invoke nested class directly from 
                command prompt
            </td>
        </tr>
        <tr>
            <td>From normal or regular inner classes we can access both static and non static members of outer class directly</td>
            <td>From static nested classes we can access static members of outer class</td>
        </tr>

    </tbody>
</table>

<h5>Various combinations of nested classes and interfaces</h5>
<h6>Case 1 : Class inside a class</h6>
<p>Without existing one type of object if there is no chance of existing another type of object then we can declare a class inside a class</p>
<p>Example - University consists of several departments. Without existing university there is no chance of existing department hence 
    we have to declare department class inside university class</p>

    <pre><code>
        class University {

            class Department {

            }

        }
    </code></pre>
<h6>Case 2 : Interface inside a class</h6>
<p>Inside a class if we require multiple implementations of an interface and all these implementations 
    are related to a particular class then we can define interface insidea class</p>

    <pre><code>
        class CehicleTypes {
            interface Vehicle {
                public int getNoOfWheels();
            }
            class Bus implements Vehicle {
                public int getNoOfWheels() {
                    return 6;
                }
            }
            class Auto implements Vehicle {
                public int getNoOfWheels {
                    return 3;
                }
            }
        }
    </code></pre>

<h6>Case 3: Interface inside Interface</h6>
<p>We can declare interface inside interface</p>
<p>A Map is a group of key value pair and each key value pair is called an entry</p>
<p>Without existing Map object there is no chance of existing entry object. Hence interface entry is defined 
    inside Map Interface</p> 

    <pre><code>
        interface Map {
            interface Entry {

            }
        }
    </code></pre>

<p>Every interface present inside interface is always public and static whether we are declaring or not 
    hence we can implement inner interface directly without implementing outer interface.</p>
<p>Similarily whenever we are implementing outer interface we are not required to implement inner interface i.e 
    we can implement outer and inner interfaces independently</p>

    <pre><code>

interface Outer {
	public void m1();
	interface Inner {
		public void m2();
	}
}
class Test1 implements Outer {
	public void m1() {
		System.out.println("outer interface method implementation");
	}
}
class Test2 implements Outer.Inner {
	public void m2() {
		System.out.println("Inner interface method implementation");
	}

}
public class Test {
	
	public static void main(String[] args) {
		
		Test1 t1 = new Test1();
		t1.m1();
		
		Test2 t2 = new Test2();
		t2.m2();
		
	}

}

    </code></pre>

    <pre><output>
        outer interface method implementation
        Inner interface method implementation        
    </output></pre>

<h6>Class inside interface</h6>
<p>If functionality of a class is closely associated with interface then it is highly recommended 
    to declare class inside interface
</p>
<p>Example - </p>
<pre><code>
    interface EmailService {
        public void sendMail(EmailDetails e);
        class EmailDetails {
            String to_list();
            String cc_list();
            String subject;
            String body;
        }
    }
</code></pre>
<p>In the above example EmailDetails is required only for Email service and we are not using anywhere 
    else hence EmailDetails class is recommended to declare inside EmailService interface</p>

<p>We can also define a class inside interface to provide default implementation for that interface</p>

<pre><code>
    interface Vehicle {
        public int getNoOfWheels();
    
        class DefaultVehicle implements Vehicle {
            public int getNoOfWheels() {
                return 2;
            }
        }
    }
    
    class Bus implements Vehicle {
        @Override
        public int getNoOfWheels() {
            return 6;
        }
    }
    
    public class Test {
    
        public static void main(String[] args) {
            Vehicle.DefaultVehicle d = new Vehicle.DefaultVehicle();
            System.out.println(d.getNoOfWheels());
    
            Bus b = new Bus();
            System.out.println(b.getNoOfWheels());
        }
    }
    
</code></pre>
<pre><output>
    2
    6
</output></pre>
<p>In the above example DefaultVehicle is the default implementation of Vehicle interface 
    whereas Bus is customized implementation of Vehicle interface</p>

<mark>Note : The class which is declared inside interface is always public static whether we are 
    declaring or not hence we can create class object directly without having outer interface type object</mark>


</mark>

<h6>Conclusions</h6>

<p>1. Among classes and interfaces we can declare anything inside anything</p>
<pre><code>
1.  class A {
        class B {

        }
    }
2.  class A {
        interface B {

        }
    }
3.  interface A {
        interface B {

        }
    }
4.  interface A {
        class B {

        }
    }
</code></pre>

<pre><output>
    1. valid 
    2. valid
    3. valid 
    4. valid
</output></pre>
<p>2. The interface which is declared inside interface is always public and static whether we are 
    declaring or not</p>
<p>3. The class which is declared inside interface is always public and static whether we are 
    declaring or not</p>
<p>4. The interface which is declared inside a class is always static but need not be public</p>



<h1>java.lang package</h1>
    
    <h3>1. Introduction</h3>

    <p>For writing any java program whether it is simple or complex, the most commonly required classes and 
        interfaces are grouped into a separate package which is nothing but java.lang package</p>
        
    <p>We are not required to imoprt java.lang package explicitly because all classes and interfaces present in 
        lang package by default available to every java program</p>

    <h3>Object class(java.lang.Object)</h3>
    <p>The most commonly required methods for every java class(whether it is predefined class or customized class) 
are defined in a separate class which is nothing but Object class</p>
 <p>Every class in java is the child class of object either directly or indirectly so that object class methods by default available to 
     every java class. Hence Object class is considered as root of all java classes</p>

<mark>Note : If our class doesnt extend any other class then only our class is the direct child class of Object<br>
If our class extends any other class then our class is indirect child class of Object</mark>
<h6>Conclusion</h6>
<p>Either directlt or indirectly java wont provide support for multiple inheritance with respect to classes</p>

<p>Object class defines the following 11 methods</p>
<pre><code>
public String toString();
public native int hashCode();
public boolean equals(Object o);
protected native Object clone() throws CloneNotSupportedException;
protected void finalize() throws Throwable; 
public java.lang.Object();
public final Class getClass();
public final void wait() throws InterruptedException;
public final native void wait(long ms) throws InterruptedException;
public final void wait(long ms, int ns) throws InterruptedException;
public final native void notify();
public final native void notifyAll();
</code></pre>

<p>Note : Strictly speaking Object class contains 12 methods. The extra method is registerNatives()</p>

<pre><code>
    private static native void registerNatives()
</code></pre>
<p>This method internally required for Object class and not available to the child classes. Hence we are not required 
    to consider this method.
</p>

<h3>String class</h3>
<h6>toString()</h6>
<p>We can use toString() method to get String representation of an Object</p>
<pre><code>
    String s = obj.toString(); 
</code></pre>
<p>Whenever we are trying to print object reference internally toString() method will be called</p>
<pre><code>
    Student s = new Student();
    SOP(s);     //internally SOP(s.toString());
</code></pre>

 <p>If our class doesnt contain toString() method then Object class toString() method will be executed</p>
 <pre><code>
    public class Student {

        private String name; 
        private int rollno; 
        
        public Student(String name, int rollno) {
            this.name = name;
            this.rollno = rollno;
        }
    
        public static void main(String[] args) {
            Student s1 = new Student("Durga", 101);
            Student s2 = new Student("Ravi", 102);
            System.out.println(s1);
            System.out.println(s1.toString());
            System.out.println(s2);
        }
    
    }
    
</code></pre>

<pre><output>
Student@4617c264
Student@4617c264
Student@36baf30c
</output></pre>

<p>In the above example Object class toString() method got executed which is implemented 
    as follows</p>
    <pre><code>
        public String toString() {
            return getClass().getName() + "@" + Integer.toHexString(hashCode());
        }
    </code></pre>

    <pre><output>
        classname@hashcode_in_hexadecimalform</output>
    </output></pre>

    <p>We can override toString() to provide our own String representation</p>
    <p>For example - Whenever we are trying to print Student object reference to print his name and rollno we 
        have to override toString() method as follows</p>

<pre><code>
    @Override
	public String toString() {
		return "Student [name=" + name + ", rollno=" + rollno + "]";
	}
</code></pre>

<p>In all wrapper classes, in all collection classes String class, StringBuffer and StringBuilder classes 
    toString() method is overridden for meaningful String representation. Hence it is highly recommended to override 
    toString() method in our class also</p>

    <pre><code>
import java.util.ArrayList;
public class Test {
	
	public String toString() {
		return "test";
	}

	public static void main(String[] args) {
		String s = new String("durga");
		System.out.println(s);
		
		Integer I = new Integer(10);
		System.out.println(I);
		
		ArrayList<String> l = new ArrayList<String>();
		l.add("A");
		l.add("B");
		System.out.println(l);
		
		Test t = new Test();
		System.out.println(t);
	}

}
    </code></pre>
    
    <pre><output>
durga
10
[A, B]
test
    </output></pre>

<h6>hashCode()</h6>
<p>For every object a unique number generated by JVM which is nothing but hashCode.
    hashCode wont represent address of Object</p>
<p>JVM will use hashCode while saving Objects into hashing related data structures like 
    hash table, hashMap, hashSet etc</p>
<p>The main advantage of saving objects based on hashCode is search operation will become easy(the 
    most powerful search algorithm upto today is hashing)</p>

<p>If we are giving the chance to object class hashCode method it will generate hashCode based on 
    address of the object. It doesnt mean hashCode represents address of the object. Based 
    on our requirement we can override hashCode method in our class to generates our own hashCode</p>
    
<p>Overriding hashCode method is said to be proper iff for every object we have to generate 
    a unique number as hashCode</p>
    <pre><code>
        class Student {
            - 
            - 
            - 
            public int hashCode() {
                return 100;
            }
        }
    </code></pre>
<p>This is <span class="bg-danger text-white">improper way</span> of Overriding hashCode method because for all students objects we are generating 
    same number as hashCode</p>
    
<pre><code>
    class Student {
        - 
        - 
        - 
        public int hashCode() {
            return rollno;
        }
    }
</code></pre>

<p>This is <span class="bg-success text-white">proper way</span> of Overriding hashCode method because we are generating a different hashCode
    for every object</p> 

<h6>toString() vs hashCode()</h6>
<p>If we are giving the chance to object class toString() method it will internally calls hashCode method. If we 
    are overriding toString method then our toString method may not call hashCode method</p>
<pre><code>
    public class Test {
	
        int i;
        public Test(int i) {
            this.i = i;
        }
        public static void main(String[] args) {
            Test t1 = new Test(10);
            Test t2 = new Test(100);
            System.out.println(t1);
            System.out.println(t2);
        }
    
    }
    
</code></pre>

<pre><output>
Test@4617c264
Test@36baf30c
</output></pre>

<pre><code>
    public class Test {
	
        int i;
        public Test(int i) {
            this.i = i;
        }
        
        public static void main(String[] args) {
            Test t1 = new Test(10);
            Test t2 = new Test(100);
            System.out.println(t1);
            System.out.println(t2);
        }
    
        @Override
        public int hashCode() {
            return i;
        }
    }
    
</code></pre>

<pre><output>
Test@a
Test@64    
</output></pre>

<pre><code>
    public class Test {
	
        int i;
        public Test(int i) {
            this.i = i;
        }
        
        public static void main(String[] args) {
            Test t1 = new Test(10);
            Test t2 = new Test(100);
            System.out.println(t1);
            System.out.println(t2);
        }
    
        @Override
        public int hashCode() {
            return i;
        }
    
        @Override
        public String toString() {
            return i + "";
        }
    }
</code></pre>

<pre><output>
    10 
    100
</output></pre>

<h6>equals() method</h6>
<p>We can use equals() method to check equality of two objects</p>
<p>example - obj1.equals(obj2)</p>
<p>If our class doesnt contain equals() method then object class equals 
    method will be executed</p>
<pre><code>
    public class Student {

        private String name;
        private int rollno;
    
        public Student(String name, int rollno) {
            super();
            this.name = name;
            this.rollno = rollno;
        }
    
        public static void main(String[] args) {
            Student s1 = new Student("Durga", 101);
            Student s2 = new Student("Ravi", 102);
            Student s3 = new Student("Durga", 101);
            Student s4 = s1;
            System.out.println(s1.equals(s2));
            System.out.println(s1.equals(s3));
            System.out.println(s1.equals(s4));
        }
    }
</code></pre>

<pre><output>
    false 
    false 
    true
</output></pre>

<p>In the above example Object class equals() method got executed which is meant for 
    reference comparison(address comparison) i.e if two references pointing to the same object 
    then only .equals() method return true</p>

<p>Based on our requirement we can override equals() method for content comparison</p>
<p>While overriding equals() method for content comparison we have to take care about the following</p>
<p>1. What is the meaning of equality(whether we have to check only names or only rollnos or both)</p>
<p>2. If we are passing different types of object our equals() method should not raise any ClassCastException 
    i.e we have to handle ClassCastException to return false</p>
<p>3. If we are passing null argument then our equals() method should not rise NullPointerExcepton i.e we have to 
    handle NullPointerExcepton to return false</p>
<p>The following is the proper way of overriding equals() method for Student class content comparison</p>
<pre><code>
    public class Student {

        private String name;
        private int rollno;
    
        public Student(String name, int rollno) {
            super();
            this.name = name;
            this.rollno = rollno;
        }
    
        public static void main(String[] args) {
            Student s1 = new Student("Durga", 101);
            Student s2 = new Student("Ravi", 102);
            Student s3 = new Student("Durga", 101);
            Student s4 = s1;
            System.out.println(s1.equals(s2));
            System.out.println(s1.equals(s3));
            System.out.println(s1.equals(s4));
            System.out.println(s1.equals("durga"));
            System.out.println(s1.equals(null));
        }
    
        @Override
        public boolean equals(Object obj) {
            try {
                String name1 = this.name;
                int rollno1 = this.rollno;
                Student s = (Student)obj;
                String name2 = s.name;
                int rollno2 = s.rollno;
                if(name1.equals(name2) && rollno1 == rollno2) {
                    return true;
                }
                else {
                    return false;
                }
            } catch (ClassCastException e) {
                return false;
            } catch(NullPointerException e) {
                return false;
            }
            
        }
    }
</code></pre>

<pre><output>
    false
    true
    true
    false
    false    
</output></pre>
<h6>Simplified version of equals() method</h6>
<pre><code>
    public class Student {

        private String name;
        private int rollno;
    
        public Student(String name, int rollno) {
            super();
            this.name = name;
            this.rollno = rollno;
        }
    
        public static void main(String[] args) {
            Student s1 = new Student("Durga", 101);
            Student s2 = new Student("Ravi", 102);
            Student s3 = new Student("Durga", 101);
            Student s4 = s1;
            System.out.println(s1.equals(s2));
            System.out.println(s1.equals(s3));
            System.out.println(s1.equals(s4));
            System.out.println(s1.equals("durga"));
            System.out.println(s1.equals(null));
        }
    
        @Override
        public boolean equals(Object obj) {
            try {
    
                Student s = (Student) obj;
    
                if (name.equals(s.name) && rollno == s.rollno) {
                    return true;
                } else {
                    return false;
                }
            } catch (ClassCastException e) {
                return false;
            } catch (NullPointerException e) {
                return false;
            }
    
        }
    }
</code></pre>

<pre><output>
false
true
true
false
false
</output></pre>

<h6>More Simplified version of equals() method</h6>
<pre><code>
    public class Student {

        private String name;
        private int rollno;
    
        public Student(String name, int rollno) {
            super();
            this.name = name;
            this.rollno = rollno;
        }
    
        public static void main(String[] args) {
            Student s1 = new Student("Durga", 101);
            Student s2 = new Student("Ravi", 102);
            Student s3 = new Student("Durga", 101);
            Student s4 = s1;
            System.out.println(s1.equals(s2));
            System.out.println(s1.equals(s3));
            System.out.println(s1.equals(s4));
            System.out.println(s1.equals("durga"));
            System.out.println(s1.equals(null));
        }
    
        @Override
        public boolean equals(Object obj) {
            if (obj instanceof Student) {
    
                Student s = (Student) obj;
    
                if (name.equals(s.name) && rollno == s.rollno) {
                    return true;
                } else {
                    return false;
                }
            }
            return false;
    
        }
    }
</code></pre>

<pre><output>
false
true
true
false
false

</output></pre>

<mark>Note : To make above equals() method more efficient we have to write the following code
    at the beginning inside equals() method</mark>
    <pre><code>
        if(obj == this) {
            return true;
        }
    </code></pre>
<p>According to this if both references pointing to the same object then without performing any comparison 
     .equals() method returns true directly</p>
<hr>
 <table class="table table-striped">
    <tbody>
        <tr>
            <td>
<pre><code>
String s1 = new String("durga");
String s2 = new String("durga");
System.out.println(s1==s2);
System.out.println(s1.equals(s2));
</code></pre>

<pre><output>
    false 
    true
</output></pre>
            </td>
            <td>
<pre><code>
StringBuffer sb1 = new StringBuffer("durga");
StringBuffer sb2 = new StringBuffer("durga");
System.out.println(sb1 == sb2);
System.out.println(sb1.equals(sb2));
</code></pre>

<pre><output>
    false 
    false
</output></pre>
            </td>
        </tr> 
        <tr>
            <td>
                In String class .equals() method is overridden for content comparison 
                hence even though objects are different if content is same then .equals() 
                method returns true
            </td>
            <td>In StringBuffer .equals() is not overridden for content comparison hence if objects 
                are different .equals() method returns false even though the content is same
            </td>
        </tr>  
    </tbody>
</table>
   
<h6>getClass() method</h6>
<p>We can use getClass() method to get runtime class definition of an object</p>
<pre><code>
    public final Class getClass()
</code></pre>
<p>By using this Class class object we can access class level properties like fully qualified name of the class, 
    methods information, constructors information etc</p> 
<p>Example 1:</p>
    <pre><code>
public class Test {
	public static void main(String[] args) {
		int count = 0;
		Object object = new String("durga");
		Class c = object.getClass();	
		System.out.println("Fully qualified name of class : " + c.getName() + "=====================================>");
		Method[] declaredMethods = c.getDeclaredMethods();
		System.out.println("Methods information=================>");
		for(Method method : declaredMethods) {
			count++;
			System.out.println(method);
		}
		System.out.println("Numer of methods : " + count + "==============================>");
	}
}
    </code></pre>
    
    <pre><output>
        Fully qualified name of class : java.lang.String=====================================>
        Methods information=================>
        byte[] java.lang.String.value()
        public boolean java.lang.String.equals(java.lang.Object)
        public int java.lang.String.length()
        public java.lang.String java.lang.String.toString()
        public int java.lang.String.hashCode()
        public void java.lang.String.getChars(int,int,char[],int)
        public int java.lang.String.compareTo(java.lang.Object)
        public int java.lang.String.compareTo(java.lang.String)
        public int java.lang.String.indexOf(int,int)
        public int java.lang.String.indexOf(java.lang.String)
        public int java.lang.String.indexOf(java.lang.String,int)
        public int java.lang.String.indexOf(int)
        static int java.lang.String.indexOf(byte[],byte,int,java.lang.String,int)
        static void java.lang.String.checkIndex(int,int)
        public static java.lang.String java.lang.String.valueOf(char[])
        public static java.lang.String java.lang.String.valueOf(java.lang.Object)
        public static java.lang.String java.lang.String.valueOf(long)
        public static java.lang.String java.lang.String.valueOf(char[],int,int)
        public static java.lang.String java.lang.String.valueOf(int)
        public static java.lang.String java.lang.String.valueOf(char)
        public static java.lang.String java.lang.String.valueOf(double)
        public static java.lang.String java.lang.String.valueOf(float)
        public static java.lang.String java.lang.String.valueOf(boolean)
        byte java.lang.String.coder()
        private static java.lang.Void java.lang.String.rangeCheck(char[],int,int)
        static void java.lang.String.checkBoundsOffCount(int,int,int)
        boolean java.lang.String.isLatin1()
        public char java.lang.String.charAt(int)
        public int java.lang.String.codePointAt(int)
        public int java.lang.String.codePointBefore(int)
        public int java.lang.String.codePointCount(int,int)
        public int java.lang.String.offsetByCodePoints(int,int)
        static void java.lang.String.checkBoundsBeginEnd(int,int,int)
        public byte[] java.lang.String.getBytes(java.lang.String) throws java.io.UnsupportedEncodingException
        void java.lang.String.getBytes(byte[],int,byte)
        public byte[] java.lang.String.getBytes()
        public void java.lang.String.getBytes(int,int,byte[],int)
        public byte[] java.lang.String.getBytes(java.nio.charset.Charset)
        public boolean java.lang.String.contentEquals(java.lang.StringBuffer)
        public boolean java.lang.String.contentEquals(java.lang.CharSequence)
        private boolean java.lang.String.nonSyncContentEquals(java.lang.AbstractStringBuilder)
        public boolean java.lang.String.regionMatches(int,java.lang.String,int,int)
        public boolean java.lang.String.regionMatches(boolean,int,java.lang.String,int,int)
        public boolean java.lang.String.startsWith(java.lang.String,int)
        public boolean java.lang.String.startsWith(java.lang.String)
        public int java.lang.String.lastIndexOf(java.lang.String)
        public int java.lang.String.lastIndexOf(int)
        static int java.lang.String.lastIndexOf(byte[],byte,int,java.lang.String,int)
        public int java.lang.String.lastIndexOf(int,int)
        public int java.lang.String.lastIndexOf(java.lang.String,int)
        public java.lang.String java.lang.String.substring(int,int)
        public java.lang.String java.lang.String.substring(int)
        public boolean java.lang.String.isEmpty()
        public java.lang.String java.lang.String.replace(char,char)
        public java.lang.String java.lang.String.replace(java.lang.CharSequence,java.lang.CharSequence)
        public boolean java.lang.String.matches(java.lang.String)
        public java.lang.String java.lang.String.replaceFirst(java.lang.String,java.lang.String)
        public java.lang.String java.lang.String.replaceAll(java.lang.String,java.lang.String)
        public java.lang.String[] java.lang.String.split(java.lang.String,int)
        public java.lang.String[] java.lang.String.split(java.lang.String)
        public java.lang.String java.lang.String.toLowerCase()
        public java.lang.String java.lang.String.toLowerCase(java.util.Locale)
        public java.lang.String java.lang.String.toUpperCase()
        public java.lang.String java.lang.String.toUpperCase(java.util.Locale)
        public java.lang.String java.lang.String.trim()
        public java.lang.String java.lang.String.strip()
        public java.lang.String java.lang.String.stripLeading()
        public java.lang.String java.lang.String.stripTrailing()
        private int java.lang.String.indexOfNonWhitespace()
        public java.util.stream.Stream java.lang.String.lines()
        public java.lang.String java.lang.String.repeat(int)
        private int java.lang.String.lastIndexOfNonWhitespace()
        private static int java.lang.String.outdent(java.util.List)
        public boolean java.lang.String.isBlank()
        public char[] java.lang.String.toCharArray()
        public static java.lang.String java.lang.String.format(java.util.Locale,java.lang.String,java.lang.Object[])
        public static java.lang.String java.lang.String.format(java.lang.String,java.lang.Object[])
        public java.lang.String java.lang.String.resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup)
        public java.lang.Object java.lang.String.resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup) throws java.lang.ReflectiveOperationException
        public java.util.stream.IntStream java.lang.String.codePoints()
        public boolean java.lang.String.equalsIgnoreCase(java.lang.String)
        public int java.lang.String.compareToIgnoreCase(java.lang.String)
        public boolean java.lang.String.endsWith(java.lang.String)
        public java.lang.CharSequence java.lang.String.subSequence(int,int)
        public java.lang.String java.lang.String.concat(java.lang.String)
        public boolean java.lang.String.contains(java.lang.CharSequence)
        public static java.lang.String java.lang.String.join(java.lang.CharSequence,java.lang.CharSequence[])
        public static java.lang.String java.lang.String.join(java.lang.CharSequence,java.lang.Iterable)
        public java.lang.String java.lang.String.indent(int)
        public java.lang.String java.lang.String.stripIndent()
        public java.lang.String java.lang.String.translateEscapes()
        public java.util.stream.IntStream java.lang.String.chars()
        public java.lang.Object java.lang.String.transform(java.util.function.Function)
        public java.lang.String java.lang.String.formatted(java.lang.Object[])
        public static java.lang.String java.lang.String.copyValueOf(char[],int,int)
        public static java.lang.String java.lang.String.copyValueOf(char[])
        public native java.lang.String java.lang.String.intern()
        static void java.lang.String.checkOffset(int,int)
        static java.lang.String java.lang.String.valueOfCodePoint(int)
        public java.util.Optional java.lang.String.describeConstable()
        private static java.lang.String java.lang.String.lambda$stripIndent$3(int,java.lang.String)
        private static java.lang.String java.lang.String.lambda$indent$2(int,java.lang.String)
        private static java.lang.String java.lang.String.lambda$indent$1(java.lang.String)
        private static java.lang.String java.lang.String.lambda$indent$0(java.lang.String,java.lang.String)
        Numer of methods : 104==============================>
    </output></pre>

    <p>Example 2: </p>
    <p>To display database vendor specific connection interface implemented class name </p>
    <pre><code>
        Connection con = DriverManager.getConnection(.....);
        SOP(con.getClass().getName());
    </code></pre>

<mark>Note : After loading every .class file, JVM will create an object of the type java.lang.Class in the heap area. 
    Programmer can use this class object to get class level information<br>
    We can use getClass() method very frequently in reflections
</mark>

<h6>finalize() method</h6>
<p>Just before destroying an object garbage collector calls finalize method to perform cleanup activities. Once 
    finalize method completes automatically garbage collector destroys that object</p>
    
<h6>wait(), notify(), notifyAll()</h6>
<p>We can use these methods for interthread communication. The thread which is expecting updation, it is responsible to 
    call wait() method then immediately the thread will enter into waiting state. The thread which is responsible to perform updation 
    , after performing updation the thread can call notify() method. The waiting thread will get that notification and continue its 
    execution with those updates.
</p>

<h3>java.lang.String</h3>
<h6>Case 1 :</h6>
<table class="table table-striped">
    <tbody>
        <tr>
            <td>
<pre><code>
    String s = new String("durga");
    s.concat("software");
    SOP(s);
</code></pre>
<pre><output>
durga
</output></pre>
            </td>
            <td>
<pre><code>
    StringBuffer sb = new StringBuffer("durga");
    sb.append("software");
    SOP(sb);
</code></pre>

<pre><output>
    durgasoftware
</output></pre>
            </td>
        </tr>  
        <tr>
            <td>
                Once we create a String object we cant perform any changes in the existing object. 
                If we are trying to perform any change with those changes a new object will be created. 
                This non changeable behavior is nothing but immutability of String
            </td>
            <td>We can perform any change in the existing object. This changeable behavior is nothing but 
                mutability of StringBuffer object.
            </td>
        </tr> 
        <tr>
            <td><img src="images/ss91.png" alt="ss12" width="300" height="300"></td>
            <td><img src="images/ss92.png" alt="ss12" width="300" height="100"></td>
        </tr> 
    </tbody>
</table>

<h6>Case 2 :</h6>
<table class="table table-striped">
    <tbody>
        <tr>
            <td>
<pre><code>
String s1 = new String("durga");
String s2 = new String("durga");
System.out.println(s1==s2);
System.out.println(s1.equals(s2));
</code></pre>

<pre><output>
    false 
    true
</output></pre>
            </td>
            <td>
<pre><code>
StringBuffer sb1 = new StringBuffer("durga");
StringBuffer sb2 = new StringBuffer("durga");
System.out.println(sb1 == sb2);
System.out.println(sb1.equals(sb2));
</code></pre>

<pre><output>
    false 
    false
</output></pre>
            </td>
        </tr> 
        <tr>
            <td><img src="images/ss93.png" alt="ss12" width="400" height="200"></td>
            <td><img src="images/ss94.png" alt="ss12" width="400" height="200"></td>
        </tr> 
        <tr>
            <td>
                In String class .equals() method is overridden for content comparison 
                hence even though objects are different if content is same then .equals() 
                method returns true
            </td>
            <td>In StringBuffer .equals() is not overridden for content comparison hence objects 
                class .equals() method got executed which is meant for reference comparison(address comparison)
                due to this if objects are different .equals() method returns false even though 
                content is same.    
            </td>
        </tr>  
    </tbody>
</table>

<h6>Case 3 : </h6>
<table class="table table-striped"> 
    <tbody>
        <tr>
            <td>
<pre><code>
String s = new String("durga");
</code></pre>
            </td>
            <td>
<pre><code>
String s = "durga";
</code></pre>
            </td>
        </tr>  
        <tr>
            <td>In this case two objects will be created one in the heap area and 
                the other is in SCP(String constant pool) and s is always pointing to heap object.
            </td>
            <td>In this case only one object will be created in SCP and s is always pointing to that object.</td>
        </tr> 
        <tr>
            <td><img src="images/ss95.png" alt="ss12" width="400" height="300"></td>
            <td><img src="images/ss96.png" alt="ss12" width="400" height="300"></td>
        </tr> 
    </tbody>
</table>

<mark>Note 1 : Object creation in SCP is optional. First it will check is there any object already present 
    in SCP with required content. If object already present then existing object will be reused. If object not already 
    available then only a new object will be created. But this rule is applicable only for SCP but not for the heap.
<br>2. Garbage collector is not allowed to access SCP area hence even though object doesnt contain reference variable, 
it is not eligible for GC beacuse it is present in SCP area.<br>
3. All SCP objects will be destroyed automatically at the time of JVM shutdown</mark>

<br><br>
<p>Example 2 : </p>
<pre><code>
String s1 = new String("durga");
String s2 = new String("durga");
String s3 = "durga";
String s4 = "durga";
</code></pre>

<img src="images/ss97.png" alt="ss12" width="400" height="300">
<p>Whenever we are using new operator compulsory a new object will be created in the heap area hence there may be a chance of 
    existing two objects with same content in the heap area but not in SCP i.e duplicate objects are possible in the 
heap area but not in SCP.</p>

<pre><code>
    String s1 = new String("durga");
    s1.concat("software");
    String s2 = s1.concat("solutions");
    s1 = s1.concat("soft");
    SOP(s1);
    SOP(s2);
</code></pre>

<pre><output>
    durgasoft 
    durgasolutions
</output></pre>
<img src="images/ss98.png" alt="ss12" width="500" height="500">

<p>Note 1: For every String constant one object will be placed in SCP area.<br>
    2. Because of some runtime operation if an object is required to create that object will be placed 
    only in the heap area but not in SCP area</p>
    <pre><code>
        String s1 = new String("Spring");
        s1.concat("summer");
        String s2 = s1.concat("winter");
        s1 = s1.concat("fall");
        SOP(s1);
        SOP(s2);
    </code></pre>
    
    <pre><output>
        Springfall
        Springwinter
    </output></pre>
    <img src="images/ss99.png" alt="ss12" width="500" height="500">
<h6>Constructors of String class</h6>
<pre><code>
    1. String s = new String();
    - creates an empty String object.

    2. String s = new String(String literal);
    - creates a String object in heap for the given String literal

    3. String s = new String(StringBuffer sb);
    - creates an equivalent String object for the given StringBuffer

    4. String s = new String(char[] ch);
    - creates an equivalent String object for the given char array
    <pre><code>
        char[] ch = {'a', 'b', 'c', 'd'};
        String s = new String(ch);
        SOP(s);     //abcd
    </code></pre>

    5. String s = new String(byte[] b);
    - creates an equivalent String object for the given byte array
    <pre><code>
        byte[] b = {100, 101, 102, 103};
        String s = new String(b);
        SOP(s);     //defg
    </code></pre>
</code></pre>

<h6>Important methods of String class</h6>
<pre><code>
    1. public char charAt(int index);
    - returns the character locating at specifying index

    eg:

    String s = "durga";
    System.out.println(s.charAt(3));
    System.out.println(s.charAt(30));
</code></pre>

<pre><output>
    g 
    RE : StringIndexOutOfBoundsException
</output></pre>

<pre><code>
    2. public String concat(String s)
</code></pre>
<p>The overloaded + and += operators also meant for concatenation purpose only</p>
<pre><code>
    String s = "durga";
    s = s.concat("software");
    //s = s + "software";
    //s += "software";
    System.out.println(s;
</code></pre>
<pre><output>
    durgasoftware
</output></pre>

<pre><code>
    3. public boolean equals(Object o)
    - To perform content comparison where case is important.
    -This is overriding version of Object class equals() method
</code></pre>

<pre><code>
    4. public boolean equalsIgnoreCase(String s)
    - To perform content comparison where case is not important
</code></pre>

<pre><code>
    String s = "java";
    System.out.println(s.equals("JAVA"));
    System.out.println(s.equalsIgnoreCase("JAVA"));
</code></pre>

<pre><output>
    false 
    true
</output></pre>

<p>In general we can use equalsIgnoreCase method to validate user names where case is not important
    whereas we can use equals method to validate password where case is important</p>

    <pre><code>
        5. public String substring(int begin);
        - returns substring from begin index to end of the String 

        6. public String substring(int begin, int end);
        - returns substring from begin index to end-1 index

        String s = "abcdefg";
        System.out.println(s.substring(3));
        System.out.println(s.substring(2, 6));
    </code></pre>
    
<pre><output>
    defg 
    cdef
</output></pre>

<pre><code>
    7. public int length()
    - returns number of characters present in the String

    eg : 
    String s = "durga";
    System.out.println(s.length);   //CE : Cannot find symbol
                                    symbol : variable length 
                                    location : java.lang.String 
    System.out.println(s.length());
</code></pre>

<pre><output>
    5
</output></pre>

<pre><code>
    8. public String replace(char oldCh, char newCh)
    
    eg : 
    String s = "ababa";
    System.out.println(s.replace('a', 'b'));
</code></pre>

<pre><output>
    bbbbb
</output></pre>

<pre><code>
    9. public String toLowerCase();

    10. public String toUpperCase();

    11. public String trim();
    - to remove blank spaces present at beginning and end of the String 
    but not middle blank spaces

    12. public int indexOf(char ch);
    - returns index of first occurence of specified character

    13. public int lastIndexOf(char ch);
    
    eg : 
    String s = "ababa";
    System.out.println(s.indexOf('a'));
    System.out.println(s.lastIndexOf('a'));
</code></pre>

<pre><output>
    0 
    
</output></pre>

<mark>&#10040&#10040&#10040Note : Because of run time operation if there is a change in the content then with those 
    changes a new object will be created on the heap. If there is no change in the content then existing object will be 
    reused and new object wont be created. Whether the object present in heap or SCP the rule is same.
</mark>

<pre><code>
    String s1 = new String("durga");
    String s2 = s1.toUpperCase();
    String s3 = s1.toLowerCase();
    System.out.println(s1 == s2);
    System.out.println(s1 == s3);
</code></pre>

<pre><output>
    false 
    true
</output></pre>

<img src="images/ss100.png" alt="ss12" width="400" height="400">

<pre><code>
    String s1 = new String("durga");
    String s2 = s1.toUpperCase();
    String s3 = s1.toLowerCase();
    String s4 = s2.toLowerCase();
    String s5 = s4.toUpperCase();
</code></pre>

<img src="images/ss101.png" alt="ss12" width="400" height="500">
   
<pre><code>
    String s1 = "durga";
    String s2 = s1.toString();
    System.out.println(s1 == s2);
    String s3 = s1.toLowerCase();
    String s4 = s1.toUpperCase();
    String s5 = s4.toLowerCase();
</code></pre>


<pre><output>
    true
</output></pre>

<img src="images/ss102.png" alt="ss102" width="400" height="300">

<h6>Immutability</h6>
<p>Once we creates an object we cant perform any changes in that object, if we are trying 
    to perform any change and if there is a change in the content then with those changes a 
    new object will be created. If there is no change in the content then existing object will be 
reused. This behavior is nothing but immutability.</p>

<pre><code>
    String s1 = new String("durga");
    String s2 = s1.toUpperCase();
    String s3 = s1.toLowerCase();
</code></pre>

<img src="images/ss103.png" alt="ss12" width="400" height="300">

<p>We can create our own immutable class</p>
<pre><code>
    final public class Test {
	
        private int i;
        
        public Test(int i) {
            this.i = i;
        }
        
        public Test modify(int i) {
            if(this.i == i) {
                return this;
            } else {
                return (new Test(i));
            }
        }
        public static void main(String[] args) {
            Test t1 = new Test(10);
            Test t2 = t1.modify(100);
            Test t3 = t1.modify(10);
            System.out.println(t1 == t2);
            System.out.println(t1 == t3);
        }
    }
    
</code></pre>

<pre><output>
    false 
    true
</output></pre>

<img src="images/ss104.png" alt="ss12" width="400" height="300">

<p>Once we creates a test object we cant perform any change in the existing object. If we are 
    trying to perform any change and if there is a change in the content then with those changes a 
    new object will be created and if there is no change in the content then existing object will be reused.</p>

<h6>final vs immutability</h6>
 <p>final applicable for variables but not for objects whereas immutability applicable for objects but 
     not for variables</p>
<p>By declaring a reference variable as final we wont get any immutability nature. Even though reference variable 
    is final we can perform any type of change in the corresponding object but we cant perform reassignment for that 
    variable hence final and immutable both are different concepts</p>

    <pre><code>
        public class Test {

            public static void main(String[] args) {
                final StringBuffer sb = new StringBuffer("durga");
                sb.append("software");
                System.out.println(sb);         //durgasoftware
                sb = new StringBuffer("solutions");
            }
        }        
    </code></pre>
    
    <pre><output>
        CE : cannot assign a value to final variable sb
    </output></pre>
    <div class="container">
        <p class="bg-warning text-white">Which of the following are meaningful?</p>
        <p>1. final variable</p>
        <p>2. immutable variable</p>
        <p>3. final object </p>
        <p>4. immutable object</p>
        
<pre><output>
    meaningful
    not meaningful
    not meaningful
    meaningful
</output></pre>
    </div>


    <h3>StringBuffer class</h3>
    <h6>StringBuffer</h6>
    <p>If the content is fixed and wont change frequently then its recommended to go for String. If the content is 
      not fixed and keep on changing then it is not recommended to use String because for every change a new object 
      will be created which effects performance of the system. To handle this requirement we should go for String Buffer. 
      The main advantage of StringBuffer over String is all required changes will be performed in the existing object only</p>
      
    <h6>Constructors</h6>
    <pre><code>
        1. StringBuffer sb = new StringBuffer();
        - creates an empty StringBuffer object with default initial capacity 16
        Once StringBuffer reaches its max capacity a new StringBuffer object will be created 
        with 
        <span class="bg-primary text-white">new capacity = (current capacity + 1) * 2;</span>
        
        eg : 

        public class Test {

            public static void main(String[] args) {
                StringBuffer sb = new StringBuffer();
                System.out.println("Initial capacity : " + sb.capacity());
                sb.append("abcdefghijklmnop");
                System.out.println(sb.capacity());
                sb.append("q");
                System.out.println(sb.capacity());
            }
        }
        
        Initial capacity : 16
        16
        34

        2. StringBuffer sb = new StringBuffer(int initialcapacity);
        -creates an empty StringBuffer object with specified initial capacity

        3. StringBuffer sb = new StringBuffer(String s);
        - creates an equivalent StringBuffer for the given String with 
        <span class="bg-primary text-white">capacity = s.length() + 16</span>

        eg. 
        StringBuffer sb = new StringBuffer("durga");
        SOP(sb.capacity());

        21


    </code></pre>
    

<h6>Important methods of StringBuffer</h6>
<pre><code>
    1. public int length();
    2. public int capacity();
    3. public char charAt(int index);

    eg : 
    StringBuffer sb = new StringBuffer("durga");
    System.out.println(sb.charAt(3));
    System.out.println(sb.charAt(30));

    g 
    RE : StringIndexOutOfBoundsException

    4. public void setCharAt(int index, char ch);
    - To replace the character located at specified index with provided character

    5. public StringBuffer append(String s)
    6. public StringBuffer append(int i)
    7. public StringBuffer append(long l)
    8. public StringBuffer append(char ch)
    9. public StringBuffer append(boolean b)
    
    eg : 
    public class Test {

        public static void main(String[] args) {
            StringBuffer sb = new StringBuffer();
            sb.append("PI value is : ");
            sb.append(3.14);
            sb.append("It is exaclty : ");
            sb.append(true);
            System.out.println(sb);
        }
    }

    PI value is : 3.14It is exaclty : true

    10. public StringBuffer insert(int index, String s);
    11. public StringBuffer insert(int index, int i);
    12. public StringBuffer insert(int index, double d);
    13. public StringBuffer insert(int index, char ch);
    14. public StringBuffer insert(int index, boolean b);

    public class Test {

        public static void main(String[] args) {
            StringBuffer sb = new StringBuffer("abcdefgh");
            sb.insert(2, "xyz");
            System.out.println(sb);
        }
    }

    abxyzcdefgh

    15. public StringBuffer delete(int begin, int end);
    - to delete characters located from begin index to end - 1 index 
    
    16. public StringBuffer deleteCharAt(int index)
    - To delete the character located at specified index

    17. public StringBuffer reverse();
    public class Test {

        public static void main(String[] args) {
            StringBuffer sb = new StringBuffer("durga");
            sb.reverse();
            System.out.println(sb);
        }
    }

    agrud
    
    18. public void setLength(int length);

    eg : 
    public class Test {

        public static void main(String[] args) {
            StringBuffer sb = new StringBuffer("aishwaryaabhi");
            sb.setLength(9);
            System.out.println(sb);
        }
    }

    aishwarya

    19. public void ensureCapacity(int capacity);
    - to increase capacity on fly based on our requirement

    eg : 
    StringBuffer sb = new StringBuffer();
    System.out.println(sb.capacity());
    sb.ensureCapacity(1000);
    System.out.println(sb.capacity());

    16
    1000

    20. public void trimToSize();
    - to deallocate extra allocated free memory

    public class Test {

        public static void main(String[] args) {
            StringBuffer sb = new StringBuffer(1000);
            System.out.println(sb.capacity());
            sb.append("abc");
            sb.trimToSize();
            System.out.println(sb.capacity());
        }
    }

    1000
    3

    
</code></pre>
  
 


    <h3>StringBuilder class</h3>
    <p>Every method present in StringBuffer is synchronized and hence only one thread is allowed 
        to operate on StringBuffer object at a time which may creates performance probelm. To 
        handle this requirement SUN people introduced StringBuilder concept in 1.5v </p>
    <p>StringBuilder is exaclty same as StringBuilder except the following differences</p>
    <table class="table table-striped">
        <thead class="thead-dark">
            <tr>
                <th>StringBuffer</th>
                <th>StringBuilder</th>
            </tr>
        </thead> 
        <tbody>
            <tr>
                <td>Every method present in StringBuffer is synchronized</td>
                <td>Every method present in StringBuilder is non synchronized</td>
            </tr>  
            <tr>
                <td>At a time only one thread is allowed to operate on StringBuffer object 
                    and hence StringBuffer object is thread safe
                </td>
                <td>At a time multiple threads are allowed to operate on StringBuilder object and hence 
                    StringBuilder is not thread safe
                </td>
            </tr> 
            <tr>
                <td>Threads are required to wait to operate on StringBuffer object and hence relatively 
                    performance is low.
                </td>
                <td>Threads are not required to wait to operate on StringBuilder object and hence relatively 
                    performance is high.
                </td>
            </tr> 
            <tr>
                <td>Introduced in 1.0v</td>
                <td>Introduced in 1.5v</td>
            </tr> 
        </tbody>
    </table>

    <mark>Note : Except above differences everything is same in StringBuffer and StringBuilder(including methods and constructors)</mark>
  
    <table class="table table-striped">
        <thead class="thead-dark">
            <tr>
                <th>String</th>
                <th>StringBuffer</th>
                <th>StringBuilder</th>
            </tr>
        </thead> 
        <tbody>
            <tr>
                <td>If the content is fixed and wont change frequently then we should go for String</td>
                <td>If the content is not fixed and keep on changing but thread safety required then we should 
                    go for StringBuffer
                </td>
                <td>If the content is not fixed, keep on changing but thread safety is not required then we should 
                    go for StringBuilder
                </td>
            </tr> 
            
        </tbody>
    </table>

    <h6>Method Chaining</h6>
    <p>For most of the methods in String, StringBuffer and StringBuilder, return types are same type hence after applying 
        a method on the result we can call another method which forms method Chaining</p>
    <p>sb.m1().m2().m3().m4()......</p>
    <p>In method chaining method calls will be executed from left to right</p>
    <pre><code>
        public class Test {

            public static void main(String[] args) {
                StringBuffer sb = new StringBuffer();
                sb.append("durga").append("software").append("solutions").insert(5, "srikanth")
                .delete(13, 21).append("SRNagar").reverse();
                System.out.println(sb);
            }
        }
        
    </code></pre> 

    
<pre><output>
    ragaNRSsnoituloshtnakirsagrud
</output></pre>


    <h3>Wrapper class</h3>
    <p>The main objectives of wrapper classes are </p>
    <p>1. To wrap primitive into object form so that we can handle primitives also just like objects.</p>
    <p>2. To define several utility methods which are required for primitives.</p>

    <h6>Constructors</h6>
    <p>Almost all wrapper classes contains two constructors one can take corresponding primitive as argument and 
        the other can take String as argument</p>
        <pre><code>
            eg 1:
            Integer I = new Integer(10);
            Integer I = new Integer("10");

            eg 2:
            Double D = new Double(10.5);
            Double D = new Double("10.5");
        </code></pre>
        <p>If the String argument not representing a number then we will get RE saying NumberFormatException</p>
        <pre><code>
            Integer I = new Integer("ten");

            RE: NumberFormatException
        </code></pre>
        <p>Float class contains 3 constructors with float, double and String arguments</p>
        <pre><code>
            Float f = new Float(10.5f);
            Float f = new Float("10.5f");
            Float f = new Float(10.5);
            Float f = new Float("10.5");
        </code></pre>
<p>Character class contains only one constructor which can take char arguments</p>
<pre><code>
    Character ch = new Character('a');  &#10004 
    Character ch = new Character("a");  &#10006
</code></pre>
<p>Boolean class conatins two constructor, one can take primitive as argument and the other can take String argument. If 
    we pass boolean primitive as argument the only allowed values are true or false where case is important and content 
    is also important.
</p>
<pre><code>
    Boolean B = new Boolean(true);
    Boolean B = new Boolean(false);
    Boolean B = new Boolean(True);
    Boolean B = new Boolean(durga);
</code></pre>


<pre><output>
    valid 
    valid 
    invalid 
    invalid
</output></pre>

<p>If we are passing String type as argument then case and content both are not important if the content is case insensitive String
    of true then it is treated as true. O/w it is treated as false</p>

    <pre><code>
        public class Test {
            public static void main(String[] args) {
                Boolean B1 = new Boolean("true");
                Boolean B2 = new Boolean("True");
                Boolean B3 = new Boolean("TRUE");
                Boolean B4 = new Boolean("malaika");
                Boolean B5 = new Boolean("mallika");
                Boolean B6 = new Boolean("jareen");
                System.out.println(B1);
                System.out.println(B2);
                System.out.println(B3);
                System.out.println(B4);
                System.out.println(B5);
                System.out.println(B6);
            }
        }
    </code></pre>
    
    <pre><output>
true
true
true
false
false
false

    </output></pre>    
    <pre><code>
        public class Test {
            public static void main(String[] args) {
                Boolean X = new Boolean("yes");
                Boolean Y = new Boolean("no");
                
                System.out.println(X);
                System.out.println(Y);
                System.out.println(X.equals(Y));
            }
        }
        
    </code></pre>
    
    <pre><output>
        false
        false
        true

    </output></pre>

    <h6>Summary Table</h6>

    <table class="table table-striped">
        <thead class="thead-dark">
            <tr>
                <th>Wrapper class</th>
                <th>Corresponding constructor arguments</th>
            </tr>
        </thead> 
        <tbody>
            <tr>
                <td>Byte</td>
                <td>byte or String</td>
            </tr>
            <tr>
                <td>Short</td>
                <td>short or String</td>
            </tr>
            <tr>
                <td>Integer</td>
                <td>int or String</td>
            </tr>
            <tr>
                <td>Long</td>
                <td>long or String</td>
            </tr>
            <tr class="bg-danger text-white">
                <td>Float</td>
                <td>float or String or double</td>
            </tr>
            <tr>
                <td>Double</td>
                <td>double or String</td>
            </tr>
            <tr class="bg-danger text-white">
                <td>Character</td>
                <td>char</td>
            </tr>
            <tr class="bg-primary text-white">
                <td>Boolean</td>
                <td>boolean or String</td>
            </tr>  
        </tbody>
    </table>

    <mark>Note : In all Wrapper classes toString() method is overridden to return content directly.

    <br>In all Wrapper classes .equals() method is overridden for content comparison.</mark>

    <h6>Utility methods</h6>
    <p>1. valueOf()</p>
    <p>2. xxxValue()</p>
    <p>3. parseXXX()</p>
    <p>4. toString()</p>

    <h6>1. valueOf()</h6>
    <p>We can use valueOf() methods to create Wrapper object for the given primitive or String</p>
    <p>Form 1: </p>
    <p>Every Wrapper class except Character class contains a static valueOf() method to create Wrapper object 
        for the given String</p>
    <pre><code>
        public String wrapper valueOf(String s)

        eg : 
        Integer I = Integer.valueOf("10");
        Double D = Double.valueOf("10.5");
        Boolean B = Boolean.valueOf("durga");
    </code></pre>

    <p>Form 2 : </p>
    <p>Every integral type Wrapper class Byte, Short, Integer, Long contains the following valueOf method to create 
        Wrapper object for the given specified radix String</p>
        <pre><code>
            public static wrapper valueOf(String s, int radix);
            - The allowed range of radix is : 2 to 36

            Integer I = Integer.valueOf("100", 2);
            System.out.println(I);

            Integer I = Integer.valueOf("101", 4);
            System.out.println(I);

            4 
            17
        </code></pre>
        <pre><code>
        Integer I = Integer.valueOf("1111");
        SOP(I);

        1111

        Integer I = Integer.valueOf("1111", 2);
        SOP(I);

        15
    </code></pre>

    <p>Form 3:</p>
    <p>Every class including Character class contains static valueOf() method to create Wrapper Object for the given 
        primitive.
    </p>

    <pre><code>
        public static wrapper valueOf(primitive p);

        eg: 
        Integer I = Integer.valueOf(10);
        Character ch = Character.valueOf('a');
        Boolean b = Boolean.valueOf(true);
    </code></pre>
    <img src="images/ss105.png" alt="ss12" width="400" height="300">

    <h6>2. xxxValue()</h6>
    <p>We can use xxxValue() methods to get primitive for the given Wrapper object</p>
    <p>Every number type Wrapper class(Byte Short Integer Long Float Double) contains the following six methods 
        to get primitives for the given Wrapper object</p>
        <pre><code>
            public byte byteValue()
            public short shortValue()
            public int intValue()
            public long longValue()
            public float floatValue()
            public double doubleValue()
        </code></pre>

        <pre><code>
            eg : 
            Integer I = new Integer(130);
            System.out.println(I.byteValue());
            System.out.println(I.shortValue());
            System.out.println(I.intValue());
            System.out.println(I.longValue());
            System.out.println(I.floatValue());
            System.out.println(I.doubleValue());
        </code></pre>
        
<pre><output>
    -126
    130
    130
    130
    130.0
    130.0
</output></pre>

<h6>charValue()</h6>
<p>Character class contains charValue() method to get char primitive for the given character object</p>
<pre><code>
    public char charValue()

    eg:
    Character ch = new Character('a');
    char c = ch.charValue();
    System.out.println(c);

    a
</code></pre> 
<h6>booleanValue() method</h6>
<p>Boolean class contains booleanValue() method to get boolean primitive for the 
    given boolean object</p>
    <pre><code>
        public boolean booleanValue();

        Boolean B = Boolean.valueOf("durga");
        boolean b = B.booleanValue();
        System.out.println(b);

        false
    </code></pre>  

    <mark>Note : In total 38(6 * 6 + 1 + 1) xxxValue() methods are possible</mark>
    <br><img src="images/ss106.png" alt="ss12" width="400" height="200">

    <h6>parseXxx()</h6>
    <img src="images/ss107.png" alt="ss12" width="400" height="200">
    <p>We can use parseXXX() methods to convert String to primitive</p>
    <p>Form 1:</p>
    <p>Every Wrapper class except Character class contains the following parseXxx method to find 
        primitive for the given String object
    </p>
    <pre><code>
        public static primitive parseXxx(String s);

        eg : 
        int i = Integer.parseInt("10");
        double d = Double.parseDouble("10.5");
        boolean b = Boolean.parseBoolean("true");
    </code></pre>

    <p>Form 2:</p>
    <p>Every integral type Wrapper class(Byte, Short, Integer, Long) contains the following parseXXX() method 
        to convert specified radix String to primitive</p>

        <pre><code>
            public static primitive parseXxx(String s, int radix);
            - The allowed range of radix is : 2 to 36

            eg: 

            int i = Integer.parseInt("1111", 2);
            System.out.println(i);
        </code></pre>

        
        <pre><output>
        15
        </output></pre>

        

    <h6>toString() method</h6>
    <p>We can use toString() method to convert Wrapper object or primitive to String</p>
    <p>Form 1:</p>
    <p>Every Wrapper class contains the following toString() method to convert Wrapper object to String type</p>

    <pre><code>
        public String toString()
        - It is the overriding version of Object class toString() method
        - Whenever we are trying to print Wrapper object reference internally this toString() 
        method will be called.

        Integer I = new Integer(10);
        String s = I.toString();
        System.out.println(s);
        System.out.println(I);  //I.toString()

        10
        10
    </code></pre>

    <p>Form 2 :</p>
    <p>Every Wrapper class including Character class contains the following static toString() method 
        to convert primitive to String.
    </p>

    <pre><code>
        public static String toString(primitive p)

        eg:

        String s = Integer.toString(10);
        String s = Boolean.toString(true);
        String s = Character.toString('a');
    </code></pre>

    <p>Form 3:</p>
    <p>Integer and Long classes contains the following toString() method to convert primitive to specified radix String</p>
    <pre><code>
        public static String toString(primitive p, int radix);
        - The allowed range of radix : 2 to 36

        String s = Integer.toString(15, 2);
        System.out.println(s);

    </code></pre>
    
<pre><output>
        1111
</output></pre>

    <p>Form 4 : toXxxString()</p>
    <p>Integer and Long classes contains the following toXxx String methods</p>
    <pre><code>
        public static String toBinaryString(primitive p)
        public static String toOctalString(primitive p)
        public static String toHexString(primitive p)

        eg:
        String s = Integer.toBinaryString(10);
        System.out.println(s);
        String s = Integer.toOctalString(10);
        System.out.println(s);
        String s = Integer.toHexString(10);
        System.out.println(s);
    </code></pre>

    <pre><output>
        1010
        12
        a
    </output></pre>

    <img src="images/ss108.png" alt="ss12" width="400" height="200">

    <h6>Dancing between String, Wrapper object and primitive</h6>
    <img src="images/ss109.png" alt="ss12" width="400" height="600">

    <h6>Partial hierarchy of java.lang package</h6>
    <img src="images/ss110.png" alt="ss12" width="800" height="500">
    <h6>Conclusions</h6>
    <p>The wrapper classes which are not child class of Number are Boolean and Character</p>
    <p>The wrapper classes which are not direct child class of Object are Byte Short Integer Long Float Double</p>
    <p>String, StringBuffer, StringBuilder and all wrapper classes are final classes</p>
    <p>In addition to String objects all wrapper class objects also immutable</p>
    <p>Sometimes void class is also considered as wrapper class</p>
    <p>It is the final class and direct child class of Object. It doesnt contain any methods and it contains only one variable
        Void.TYPE
    </p>
    <p>In general we can use Void class in reflections to check whether the method return type is void or not</p>
    <pre><code>
        if(getMethod(m1).getReturnType() == Void.TYPE) {
            - 
            - 
            -
        }
    </code></pre>
    <p>Void is the class representation of void keyword in java</p>


    <h3>Autoboxing & Autounboxing</h3>
    <h6>Autoboxing : </h6>
    <p>Automatic conversion of primitive to wrapper object by compiler is called Autoboxing</p>
    <pre><code>
        Integer I = 10; //Compiler converts int to Integer automatically by Autoboxing
    </code></pre>

    <p>After compilation the above line will become </p>
    <pre><code>
        Integer I = Integer.valueOf(10);
    </code></pre>

    <p>i.e internally Autoboxing concept is implemented by using valueOf() methods</p>

    <h6>Autounboxing : </h6>
    <p>Automatic conversion of Wrapper object to primitive by compiler is called Autounboxing</p>
    <pre><code>
        Integer I = new Integer(10);
        int i = I;  //compiler converts Integer to int automatically by Autounboxing
    </code></pre>

    <p>After compilation the above line will become</p>
    <pre><code>
        int i = I.intValue();
    </code></pre> 
    
    <p>i.e internally Autounboxing concept is implemented by using xxxValue() methods</p>
    <img src="images/ss111.png" alt="ss12" width="400" height="400">

    <pre><code>
        public class Test {
            static Integer I = 10;	//Autoboxing
            public static void main(String[] args) {
                int i = I;	//AutoUnboxing
                m1(i);
            }
        
            private static void m1(Integer k) {	//Autoboxing
                int m = k;	//Autounboxing
                System.out.println(m);
            }
        }
        
    </code></pre>

    <pre><output>
        10
    </output></pre>

    <p>The above example is valid in 1.5v but invalid in 1.4v</p>

    <mark>Note : Just because of Autoboxing and Autounboxing we can use primitives and Wrapper objects interchangeably 
        from 1.5v onwards</mark>
    

<table class="table table-striped">
    <tbody>
        <tr>
            <td>
<pre><code>
class Test {
    static Integer I = 0;
    public static void main(String[] args) {
        int m = I;
        SOP(m);
    }
}


    0
</code></pre>
            </td>
            <td>
<pre><code>
class Test {
    static Integer I;
    public static void main(String[] args) {
        int m = I;      //int m = I.intValue();
        SOP(m);
    }
}


RE : NullPointerException
</code></pre>
            </td>
        </tr>  
    </tbody>
</table>

<mark>Note: On null reference if we are trying to perform AutoUnboxing then we will get RE saying 
    NullPointerException</mark>

    <pre><code>
        Integer X = 10;
        Integer Y = X;
        X++;
        SOP(X);
        SOP(Y);
        SOP(X == Y);


        11
        10
        false
    </code></pre>

<p>All wrapper class objects are immutable i.e once we creates wrapper class object, we cant perform any changes in that object. 
    If we are trying to perform any changes with those changes a new object will be created</p>
    <img src="images/ss112.png" alt="ss12" width="400" height="400">
    <pre><code>
        1.  Integer X = new Integer(10);
            Integer Y = new Integer(10);
            System.out.println(X == Y);

        2.  Integer X = new Integer(10);
            Integer Y = 10;
            System.out.println(X == Y); 

        3.  Integer X = 10;
            Integer Y = 10;
            System.out.println(X == Y);

        4.  Integer X = 100;
            Integer Y = 100;
            System.out.println(X == Y);

        5.  Integer X = 1000;
            Integer Y = 1000;
            System.out.println(X == Y);
    </code></pre>

    <pre><output>
        false
        false
        true 
        true 
        false
    </output></pre>

    <h6>Conclusion</h6>
    <p>Inernally to provide support for Autoboxing a buffer of Wrapper objects will be created at the time 
        of Wrapper class loading. By Autoboxing if an object is required to create, first JVM will check whether 
        this object already present in the buffer or not. If it is already present in the buffer then existing buffer object
        will be used. If it is not already available in the buffer then JVM will create a new Object</p>

    
<img src="images/ss113.png" alt="ss12" width="500" height="200">
<p>But buffer concept is available only in the following ranges - </p>
<pre><code>
    Byte        -       Always 
    Short       -       -128 to 127
    Integer     -       -128 to 127
    Long        -       -128 to 127 
    Character   -          0 to 127
    Boolean     -        Always
</code></pre>

<p>Except this range in all remaining cases a new object will be created.</p>

<pre><code>
    1.  Integer X = 127;
        Integer Y = 127;
        SOP(X == Y);

    2.  Integer X = 128;
        Integer Y = 128;
        SOP(X == Y);

    3.  Boolean X = false;
        Boolean Y = false;
        SOP(X == Y);

    4.  Double X = 10.0;
        Double Y = 10.0;
        SOP(X == y);
</code></pre>
<pre><output>
    true 
    false
    true 
    false
</output></pre>

<p>Internally Autoboxing concept is implemented by using valueOf() methods hence buffer concept is applicable
    for valueOf() methods also</p>

    <pre><code>
        1.  Integer X = new Integer(10);
            Integer Y = new Integer(10);
            SOP(X == Y);
        
        2.  Integer X = 10;
            Integer Y = 10;
            SOP(X == Y);
        
        3.  Integer X = Integer.valueOf(10);
            Integer Y = Integer.valueOf(10);
            SOP(X == Y);

        4.  Integer X = 10;
            Integer Y = Integer.valueOf(10);
            SOP(X == Y);
    </code></pre>

    <pre><output>
        false 
        true 
        true 
        true
    </output></pre>

    <h6>Overloading with respect to Autoboxing, widening and Var-arg methods</h6>

    <h6>Case 1 : Autoboxing vs Widening</h6>
    <pre><code>
        class Test {
            public static void m1(Integer I) {
                SOP("Autoboxing");
            }
            public static void m1(long l) {
                SOP("Widening");
            }
            public static void main(String[] args) {
                int x = 10;
                m1(x);
            }
        }
    </code></pre>
    
    <pre><output>
        Widening
    </output></pre>

    <p>Widening dominates Autoboxing</p>

    <h6>Case 2 : Widening vs var-arg method</h6>
    <pre><code>
        class Test {
            public static void m1(int... x) {
                SOP("var-arg method");
            }
            public static void m1(long l) {
                SOP("Widening");
            }
            public static void main(String[] args) {
                int x = 10;
                m1(x);
            }
        }
    </code></pre>
    
    <pre><output>
        Widening
    </output></pre>

<p>Widening dominates var-arg methods</p>

<h6>Case 3 : Autoboxing vs var-arg</h6>
<pre><code>
    class Test {
        public static void m1(int... x) {
            SOP("var-arg method");
        }
        public static void m1(Integer I) {
            SOP("Autoboxing");
        }
        public static void main(String[] args) {
            int x = 10;
            m1(x);
        }
    }
</code></pre>

<pre><output>
    Autoboxing
</output></pre>

<p>Autoboxing dominates var-arg methods. In general var-arg method will get least priority i.e 
    if no other method matched then only var-arg method will get the chance. It is exaclty same as 
    default case inside switch.
</p>

<mark>&#10040&#10040&#10040While resolving overloaded methods compiler will always gives the precedence in 
    the following order</mark>
    <p>1. Widening</p>
    <p>2. Autoboxing</p>
    <p>3. var-arg methods</p>

<h6>Case 4 : </h6>
<pre><code>
    class Test {
        public static void m1(Long l) {
            SOP("Long");
        }
        public static void main(String[] args) {
            int x = 10;
            m1(x);
        }
    }
</code></pre>
<pre><output>
    CE : m1(java.lang.Long) in Test cannot be applied to (int)
</output></pre>


<img src="images/ss114.png" alt="ss12" width="700" height="400">

<p>Widening followed by Autoboxing is not allowed in java whereas Autoboxing followed by 
    Widening(A - W) is allowed</p>

    <pre><code>
        class Test {
            public static void main(String[] args) {
                Long l = 10;
            }
        }
    </code></pre>
    <pre><output>
        CE : incompatible types: int cannot be converted to Long
    </output></pre>

    <pre><code>
        class Test {
            public static void main(String[] args) {
                long l = 10;
            }
        }
    </code></pre>
    <pre><output>
        valid
    </output></pre>

    <pre><code>
        class Test {
            public static void m1(Object o) {
                SOP("Object version");
            }
            public static void main(String[] args) {
                int x = 10;
                m1(x);
            }
        }
    </code></pre>
    <pre><output>
        Object version
    </output></pre>

    
<img src="images/ss115.png" alt="ss12" width="600" height="200">

<pre><code>
    Object o = 10;
    Number n = 10;
</code></pre>

<pre><output>
    valid 
    valid
</output></pre>

<div class="container">
    <p class="bg-warning text-white">Which of the following assignments are legal?</p>
    <pre><code>
        1. int i = 10;
        2. Integer I = 10;
        3. int i = 10L;
        4. Long l = 10L;
        5. Long l = 10;
        6. long l = 10;
        7. Object o = 10;
        8. double d = 10;
        9. Double d = 10;
        10. Number n = 10;
    </code></pre>
    
    <pre><output>
        1. valid 

        2. valid
        - Autoboxing

        3. invalid
        - CE : possible loss of precision found long required int 

        4. valid
        -Autoboxing

        5. invalid
        -CE : incompatible types : found int required long

        6. valid
        - Widening

        7. valid
        - Autoboxing followed by Widening 

        8. valid 
        - Widening 

        9. invalid
        - CE : incompatible types : found int required double 

        10. valid
        - Autoboxing followed by Widening
    </output></pre>
</div> 

<h5>Relation between == operator and .equals() method</h5>
<p>1. If two objects are equal by == operator then these objects are always equal by .equals() method 
    i.e<br> if r1 == r2 is true then r1.equals(r2) is always true</p> 

<p>2. If two objects are not equal by == operator then we cant conclude anything about .equals() method. It may 
    returns true or false i.e<br>If r1 == r2 is false then r1.equals(r2) may returns true or false and we 
    cant expect exaclty
</p>
<p>3. If two objects are equal by .equals() method then we cant conclude anything about == operator. It may 
    returns true or false i.e<br> if r1.equals(r2) is true then r1 == r2 may returns true or false
</p>

<p>4. If two objects are not equal by .equals() method then these objects are always not equal by == operator i.e<br>
if r1.equals(r2) is false then r1 == r2 is always false</p>

<h5>Differences between == operator and .equals() method</h5>
<p>To use == operator compulsory there should be some relation between argument types 
    (either parent to child or child to parent or same type) o/w we will get CE saying incomparable types</p>
<p>If there is no relation between argument types then .equals() method wont rise any CE or RE simply it returns false</p>

<pre><code>
    public class Test {
        public static void main(String[] args) {
            String s1 = new String("durga");
            String s2 = new String("durga");
            StringBuffer sb1 = new StringBuffer("durga");
            StringBuffer sb2 = new StringBuffer("durga");
            System.out.println(s1 == s2);
            System.out.println(s1.equals(s2));
            System.out.println(sb1 == sb2);
            System.out.println(sb1.equals(sb2));
            System.out.println(s1.equals(sb1));
        }
    }
</code></pre>

<pre><output>
    false
    true
    false
    false
    false
</output></pre>

<pre><code>
    public class Test {	
        public static void main(String[] args) {
            String s1 = new String("durga");
            String s2 = new String("durga");
            StringBuffer sb1 = new StringBuffer("durga");
            StringBuffer sb2 = new StringBuffer("durga");
            System.out.println(s1 == sb1);
        }
    }
    
</code></pre>

<pre><output>
    CE : incomparable types: String and StringBuffer
</output></pre>

<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>== operator</th>
            <th>.equals() method</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>It is an operator in java applicable for both primitives and object types.</td>
            <td>It is a method applicable only for object types but not primitives</td>
        </tr> 
        <tr>
            <td>In the case of object references == operator meant for reference comparison(address comparison)</td>
            <td>By default .equals() method present in Object class also meant for reference comparison</td>
        </tr> 
        <tr>
            <td>We cant override == operator for content comparison.</td>
            <td>We can override .equals() method for content comparison</td>
        </tr> 
        <tr>
            <td>To use == operator compulsory there should be some relation between argument types
                (either parent to child or child to parent or same type) o/w we will get CE saying incomparable types
            </td>
            <td>If there is no relation between argument types then .equals() method wont rise any CE or RE and simply returns false</td>
        </tr> 

    </tbody>
</table>
<h6>Answer in one line : </h6>
<p>In general we can use == operator for reference comparison and .equals() method for content comparison
</p>


<mark>Note : For any object reference r, <br>
    r == null or r.equals(null) always return false</mark>
    <pre><code>
        Thread t = new Thread();
        SOP(t == null);
        SOP(t.equals(null));
    </code></pre>
    
    <pre><output>
        false
        false
    </output></pre>

<p>Hashing related data structures follow the following fundamental rule</p>
<p>- Two equivalent objects should be placed in a same bucket but all objects present in the same bucket 
    need not be equal</p>

<h5>Contract between .equals() method and hashCode() method</h5>
<p>If two objects are equal by .equals() method then there hashCodes must be equal i.e two equivalent objects 
    should have same hash code i.e<br>if r1.equals(r2) is true then r1.hashCode() == r2.hashCode() is always true
</p>

<p>Object class .equals() method and hashCode() method follows above contract hence whenever we are overriding .equals()
    method then compulsory we should override hashCode() method to satisfy above contract(i.e two equivalent objects should 
    have same hash code)
</p>

<p>If two objects are not equal by .equals() method then there is no restriction on hash codes, may be equal or may not be equal</p>

<p>If hash codes of two objects are equal then we cant conclude anything about .equals() method, it may return true or false</p>

<p>If hash codes of two objects are not equal then these objects are always not equal by .equals() method</p>

<mark>&#10040&#10040&#10040Note : To satisfy contract between equals() and hashCode() methods whenever we are overriding .equals() method 
    compulsory we have to override hashCode() method o/w we wont get any CE or RE but its not a good programming practice</mark> 

<p>In String class .equals() method is overridden for content comparison and hence hashCode() method is also overridden to generate hashCode based 
    on content</p>

    <pre><code>
        public class Test {	
            public static void main(String[] args) {
                String s1 = new String("durga");
                String s2 = new String("durga");
                System.out.println(s1.equals(s2));
                System.out.println(s1.hashCode());
                System.out.println(s2.hashCode());
            }
        }
        
    </code></pre>
    
    <pre><output>
        true
        95950491
        95950491
    </output></pre>

<p>In StringBuilder .equals() method is not overridden for content comparison and hence hashCode() method is also not overridden</p>
<pre><code>
    	
	public static void main(String[] args) {
		StringBuffer sb1 = new StringBuffer("durga");
		StringBuffer sb2 = new StringBuffer("durga");
		
		System.out.println(sb1.equals(sb2));
		System.out.println(sb1.hashCode());
		System.out.println(sb2.hashCode());
	}
}

</code></pre>

<pre><output>
    false
    1175962212
    918221580
</output></pre>

<div class="container">
    <p class="bg-warning text-white">Consider the following Person class : </p>

    <pre><code>
        class Person {
            public boolean equals(Object obj) {
                if (obj instanceof Person) {
                    Person p = (Person) obj;
                    if (name.equals(p.name) && age == p.age) {
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }
            }
        }
    </code></pre>

    <p>Which of the following hashCode() methods are appropriate for Person class?</p>
    <pre><code>
        1. public int hashCode() {
            return 100;
        }

        2. public int hashCode() {
            return age + ssno;
        }

        3. public int hashCode() {
            return name.hashCode() + age;
        }
        4. No restrictions



        Only 3rd is valid hashCode() method
    </code></pre>
<mark>Note : Based on which parameters we override .equals() method, it is highly recommended to use 
    same parameters while overriding hashCode() method also</mark>

</div>
<br>
<mark>Note : In all collection classes, in all wrapper classes and in String class .equals() method is overridden for content comparison
    hence it is highly recommended to override equals() method in our class also for content comparison
</mark>

<h3>Clone() method</h3>
<p>The process of creating exaclty duplicate object is called Cloning</p>
<p>The main purpose of cloning is to maintain backup copy and to preserve state of an object</p>
<p>We can perform cloning by using clone() method of Object class</p>
<pre><code>
    protected native Object clone() throws CloneNotSupportedException
</code></pre>
<pre><code>
    public class Test {
        int i = 10;
        int j = 20;
        public static void main(String[] args) {
            Test t1 = new Test();
            Test t2 = t1.clone();
            t2.i = 888;
            t2.j = 999;
            System.out.println(t1.i + "..." + t1.j);
        }
    }
</code></pre>

<pre><output>
    CE : incompatible types: Object cannot be converted to Test
</output></pre>

<pre><code>
    public class Test {
        int i = 10;
        int j = 20;
        public static void main(String[] args) {
            Test t1 = new Test();
            Test t2 = <span style="color: red;">(Test)</span>t1.clone();
            t2.i = 888;
            t2.j = 999;
            System.out.println(t1.i + "..." + t1.j);
        }
    }
</code></pre>

<pre><output>
    CE :  unreported exception CloneNotSupportedException; 
    must be caught or declared to be thrown
</output></pre>

<pre><code>
    public class Test {
        int i = 10;
        int j = 20;
        public static void main(String[] args) <span style="color: red;">throws CloneNotSupportedException</span> {
            Test t1 = new Test();
            Test t2 = <span style="color: red;">(Test)</span>t1.clone();
            t2.i = 888;
            t2.j = 999;
            System.out.println(t1.i + "..." + t1.j);
        }
    }
</code></pre>

<pre><output>
    RE : Exception in thread "main" java.lang.CloneNotSupportedException: Test
</output></pre>

<pre><code>
    public class Test <span style="color: red;">implements Cloneable</span> {
        int i = 10;
        int j = 20;
        public static void main(String[] args) <span style="color: red;">throws CloneNotSupportedException</span> {
            Test t1 = new Test();
            Test t2 = <span style="color: red;">(Test)</span>t1.clone();
            t2.i = 888;
            t2.j = 999;
            System.out.println(t1.i + "..." + t1.j);
        }
    }
</code></pre>

<pre><output>
    10...20
</output></pre>
<p>We can perform cloning only for Cloneable objects. An object is said to be Cloneable iff the corresponding 
    class implements Cloneable interface</p>
<p>Cloneable interface present in java.lang package and it doesnt contain any methods. It is 
    a marker interface</p>
<p>If we are trying to perform cloning for non Cloneable objects then we will get RE saying CloneNotSupportedException</p>

<h6>Shallow cloning vs Deep cloning</h6>
<img src="images/ss116.png" alt="ss12" width="400" height="400">
<img src="images/ss117.png" alt="ss12" width="400" height="400">

<h6>Shallow Cloning</h6>
<p>The process of creating bitwise copy of an object is called Shallow Cloning.</p>
<p>If the main object contains primitive variables then exaclty duplicate copies will be created in the cloned object</p>
<p>If the main object contains any reference variable then corresponding object wont be created just duplicate reference variable
    will be created pointing to old contained object</p>

<p>Object class clone() method meant for Shallow Cloning</p>

<pre><code>
    class Cat {
        int j;
    
        Cat(int j) {
            this.j = j;
        }
    }
    
    class Dog implements Cloneable {
        Cat c;
        int i;
    
        Dog(Cat c, int i) {
            this.c = c;
            this.i = i;
        }
    
        public Object clone() throws CloneNotSupportedException {
            return super.clone();
        }
    }
    
    public class ShallowCloning {
    
        public static void main(String[] args) throws CloneNotSupportedException {
            Cat c = new Cat(20);
            Dog d1 = new Dog(c, 10);
            System.out.println(d1.i + "..." + d1.c.j);
            Dog d2 = (Dog) d1.clone();
            d2.i = 888;
            d2.c.j = 999;
            System.out.println(d1.i + "..." + d1.c.j);
        }
    }
    
</code></pre>

<pre><output>
    10...20
    10...999

</output></pre>
<img src="images/ss118.png" alt="ss12" width="400" height="500">
<p>In Shallow Cloning by using cloned object reference if we perform any change to the contained object then 
    those changes will be reflected to the main object</p>
<p>To overcome this problem we should go for deep cloning</p>


<h6>Deep cloning</h6>
<p>The process of creating exactly duplicate independent copy including contained object is called deep cloning.</p>
<p>In deep cloning if the main object contain any primitive variables then in the cloned object duplicate copies will be created.</p>
<p>If the main object contains any reference variable then the corresponding content objects also will be created in the cloned copy</p>
<p>By default object class clone method meant for shallow cloning but we can implement deep cloning explicitly by overriding
    clone method in our class</p>

    <pre><code>
        class Cat {
            int j;
        
            Cat(int j) {
                this.j = j;
            }
        }
        
        class Dog implements Cloneable {
            Cat c;
            int i;
        
            Dog(Cat c, int i) {
                this.c = c;
                this.i = i;
            }
        
            public Object clone() throws CloneNotSupportedException {
                Cat c1 = new Cat(c.j);
                Dog d = new Dog(c1, i);
                return d;
            }
        }
        
        public class DeepCloning {
        
            public static void main(String[] args) throws CloneNotSupportedException {
                Cat c = new Cat(20);
                Dog d1 = new Dog(c, 10);
                System.out.println(d1.i + "..." + d1.c.j);
                Dog d2 = (Dog) d1.clone();
                d2.i = 888;
                d2.c.j = 999;
                System.out.println(d1.i + "..." + d1.c.j);
            }
        }
        
    </code></pre>
    
    <pre><output>
        10...20
        10...20
    </output></pre>
    <img src="images/ss119.png" alt="ss12" width="400" height="500">

    <p>By using cloned object reference if we perform any change to the contained object then those changes 
        wont be reflected to the main object.</p>

    <div class="container">
        <p class="bg-warning text-white">Which cloning is best?</p>
        <p>If object contains only primitive variables then shallow cloning is the best choice. If object contains reference 
            variables then deep cloning is the best choice</p>

    </div>
    <pre><code>
        public class Test {
	
            public static void main(String[] args) {
                String s1 = new String("you cannot change me!");
                String s2 = new String("you cannot change me!");
                System.out.println(s1 == s2);
                String s3 = "you cannot change me!";
                System.out.println(s1 == s3);
                String s4 = "you cannot change me!";
                System.out.println(s3 == s4);
                String s5 = "you cannot " +  "change me!";      //line1
                System.out.println(s3 == s5);
                String s6 = "you cannot ";
                String s7 = s6 + "change me!";      //line2
                System.out.println(s3 == s7);
                final String s8 = "you cannot ";
                String s9 = s8 + "change me!";      //line3
                System.out.println(s3 == s9);
                System.out.println(s6 == s8);
            }
        }
    </code></pre>
    
    <pre><output>
        false
        false
        true
        true
        false
        true
        true    
    </output></pre>

    <p>Line 1 : This operation will be performed at compile time only because both arguments are compile time constants.</p>
    <p>Line 2 : This operation will be performed at runtime only because atleast one argument is normal variable</p>
    <p>Line 3 : This operation will be performed at compile time only because both arguments are compile time constants</p>



    <img src="images/ss120.png" alt="ss12" width="600" height="600">

<h6>Interning of String Objects</h6>
<p>By using heap object reference if we want to get corresponding SCP object reference then we should go for intern() method.</p>

<pre><code>
    public class Test {
        public static void main(String[] args) {
            String s1 = new String("durga");
            String s2 = s1.intern();
            System.out.println(s1 == s2);
            String s3 = "durga";
            System.out.println(s2 == s3);
        }
    }
</code></pre>

<pre><output>
    false
    true
</output></pre>
<img src="images/ss121.png" alt="ss12" width="400" height="300">

<p>If the corresponding SCP object is not available then intern() method itself will create the corresponding 
    SCP object</p>

    <pre><code>
        public class Test {
	
            public static void main(String[] args) {
                String s1 = new String("durga");
                String s2 = s1.concat("software");
                String s3 = s2.intern();
                System.out.println(s2 == s3);
                String s4 = "durgasoftware";
                System.out.println(s3 == s4);
            }
        }
    </code></pre>
    
    <pre><output>
        false 
        true
    </output></pre>

    <img src="images/ss122.png" alt="ss12" width="400" height="400">

    <h6>Importance of String constant pool(SCP)</h6>
    <p>Example For voter id card detailss</p>
    <p>In our program if a String object is repeatedly required then it is not recommended 
        to create separate object for every requirement because it creates performance and memory problems</p>
        <p>Instead of creating a separate object for every requirement we have to create only one object and we can 
            reuse the same object for every requirement so that performance and memory utilization will be improved</p>
    <p>This thing is possible because of SCP hence the main advantages of SCP are memory utilization and performance 
        will be improved</p> 
    
    <p>The main problem with SCP is, as several references pointing to the same object, by using one reference if we are trying to change the 
        content then remaining references will be affected. To overcome this problem SUN people implemented String object 
        as immutable i.e once we creates a String object we cant perform any changes in the existing object. If we are trying to 
        perform any changes with those changes a new object will be created</p>
    <p>Hence SCP is the only reason for immutability of String objects</p>

    <h6>FAQs</h6>
    <p>1. What is the differences between String and StringBuffer?</p>
    <p> - String objects are immutable and StringBuffer objects are mutable.</p>
    
    <p>2. Explain about Immutability and mutability with an example.</p>
        - 
    
    <p>3. What is the difference between 
        <pre><code>
            String s = new String("durga");
            and
            String s = "durga";
        </code></pre>          
    </p>
    <p>4. Other than immutability and mutability is any other difference between String and StringBuffer?</p>
    <p>   - In String .equals() method meant for content comparison and StringBuffer .equals() method meant for reference comparison</p>

    <p>5. What is SCP?</p>
    <p> - It is a specially designed memory area for String objects.</p>

    <p>6. What is the advantage of SCP?</p>
<p> - Memory utilization and performance will be improved.</p>

    <p>7. What is the disadvantage of SCP?</p>
    <p>SCP is the only reason for immutability of String objects</p>

    <p>8. Why SCP like concept is available only for String but not for StringBuffer?</p>
    <p>String is the most commonly used object and hence SUN people provides specisl memory management for String objects.
        But StringBuffer is not commonly used object and hence special memory management is not required for StringBuffer</p>

    <p>9. Why String objects are immutable where as StringBuffer objects are mutable?
    <p> - In the case of String because of SCP a single object can be referenced by multiple references. By using one reference if we are allowed to 
        change the content in the existing object then remaining references will be affected. To overcome this problem SUN people implemented 
        String objects as immutable. According to this once we creates a String object we cant perform any changes in the existing object if we are trying 
        to perform any changes with those changes a new object will be created. But in StringBuffer there is no concept 
    like SCP hence for every requirement a separate object will be created. By using one references if we are trying to change the content then there is no effect on 
remaining references hence Immutability concept not required for the StringBuffer.</p>

    
        

    <p>10. In addition to String objects any other objects are immutable in java?</p>
    <p> - Yes. In addition to String objects all wrapper class objects also immutable in java</p>
    
    <p>11. Is it possible to create our own immutable class?</p>
    <p> - Yes. 
    
        <p>12. How to create our own immutable class. Explain with an example?</p>
    
        <p>13. Immutable means non-changable where as final meams also non-changable. Then waht is the difference 
            between final and mutable.</p>
            <h1>File I/O</h1>
            <h3>1. File</h3>
            <pre><code>
                File f = new File("abc.txt");
            </code></pre>
            <p>This line wont create any physical file. First it will check is there any physical file named with abc.txt 
                is available or not. If it is available then f simply refers that file. If it is not available then we are just creating 
                java file objects to represent name abc.txt
            </p>
            <pre><code>
                public class Test {
            
                    public static void main(String[] args) throws IOException {
                        File f = new File("df.txt");
                        System.out.println(f.exists());
                        f.createNewFile();      //physical file created here
                        System.out.println(f.exists());
                        f.exists();
                    }
                }        
            </code></pre>
            <pre><output>
                1st run--------------
                false 
                true 
        
                2nd run--------------
                true 
                true
            </output></pre>
        
            <img src="images/ss123.png" alt="ss12" width="400" height="300">
        
            <p>We can use java file object to represent directory also</p>
            <pre><code>
                public class Test {
            
                    public static void main(String[] args) throws IOException {
                        File f = new File("durga13");
                        System.out.println(f.exists());
                        f.mkdir();
                        System.out.println(f.exists());
                        f.exists();
                    }
                }
            </code></pre>
            <pre><output>
                1st run--------------
                false 
                true 
        
                2nd run--------------
                true 
                true
            </output></pre>
        
            <img src="images/ss124.png" alt="ss12" width="300" height="200">
        <br>
            <mark>Note : In UNIX everything is treated as a file. Java File I/O concept is implemented 
                based on UNIX operating system hence Java file object can be used to represent both files 
                and directories.</mark>
        <br><br>    
        <h6>File class constructors</h6>
        <pre><code>
            1. File f = new File(String name);
            - creates a java file object to represent name of the file or directory 
            in current working directory.
        
            2. File f = new File(String subdirname, String name);
            - creates a java file object to represent name of the file or directory 
            present in specified subdirectory.
        
            3. File f = new File(File subdir, String name);
        </code></pre>
        
        <div class="container">
            <p class="bg-warning text-white">Write code to create a file named with abc.txt in current working directory.</p>
            <pre><code>
                File f = new File("abc.txt");
                f.createNewFile();
            </code></pre>
            <p class="bg-warning text-white">Write code to create directory named with durga123 in current working directory
                and create a file named with demo.txt in that directory.</p>
            <pre><code>
                File f = new File("durga123");
                f.mkdir();
                File f1 = new File("durga123", "demo.txt");
                //File f1 = new File(f, "demo.txt");
                f1.createNewFile();
            </code></pre>
            <img src="images/ss125.png" alt="ss12" width="400" height="300">
            <p class="bg-warning text-white">Write code to create a file named with abc.txt in E:xyz folder.
                Assume that E: xyz folder is already available in our system
            </p>
            <pre><code>
                File f = new File("E://xyz", "abc.txt");
                f.createNewFile();
            </code></pre>
        
        </div> 
        
        <h6>Important methods present in file class</h6>
        <pre><code>
            1. boolean exists();
            - returns true if the specified file or directory available 
        
            2. boolean createNewFile();
            - First this method will check whethet the specified file is already 
            available or not. If it is already available then this method returns 
            false without creating any physical file. If the file is not already available
            then this method will creates a new file and returns true.
        
            3. boolean mkdir();
        
            4. boolean isFile();
            - return true if the specified file object pointing to physical file</code>
        
            5. boolean isDirectory();
        
            6. String[] list()
            - this method returns the names of all files and subdirectories present
            in specified directory.
        
            7. long length()
            - returns number of characters present in the specified file 
        
            8. boolean delete()
            - to delete specified file or directory
        </code></pre>
        
        <p class="bg-warning text-white">Write a program to display the names of all files and 
            directories present in E://xyz.</p>
            <pre><code>
        import java.io.File;
        import java.io.IOException;
        
        public class Test {
        
            public static void main(String[] args) throws IOException {
                int count = 0;
                File f = new File("E://xyz");
        
                String[] list = f.list();
        
                for (String s : list) {
                    count++;
                    System.out.println(s);
                }
                System.out.println("The total number : " + count);
            }
        }
        
            </code></pre>
            <pre><output>
                abc.txt
                def.txt
                dir1
                dir2
                ghi.txt
                jkl.txt
                The total number : 6
            </output></pre>
        
            <pre><code>
        import java.io.File;
        import java.io.IOException;
        public class Test {
            public static void main(String[] args) throws IOException {
                int count = 0;
                File dir = new File("E://", "xyz");
                dir.mkdir();
                File f1 = new File("E://xyz", "abc.txt");
                File f2 = new File("E://xyz", "def.txt");
                File f3 = new File("E://xyz", "ghi.txt");
                File f4 = new File("E://xyz", "jkl.txt");
                f1.createNewFile();
                f2.createNewFile();
                f3.createNewFile();
                f4.createNewFile();
                File f5 = new File("E://xyz", "dir1");
                File f6 = new File("E://xyz", "dir2");
                f5.mkdir();
                f6.mkdir();
                String[] list = dir.list();
        
                for (String file : list) {
                    count++;
                    System.out.println(file);
                }
                System.out.println("The total number : " + count);
            }
        }
                
            </code></pre>
            <pre><output>
                abc.txt
                def.txt
                dir1
                dir2
                ghi.txt
                jkl.txt
                The total number : 6
            </output></pre>
            <p class="bg-warning text-white">To display only file names.</p>
            <pre><code>
            import java.io.File;
            import java.io.IOException;
            public class Test {
        
            public static void main(String[] args) throws IOException {
                int count = 0;
                File f = new File("E://xyz");
        
                String[] list = f.list();
        
                for (String s : list) {
                    File f1 = new File(f, s);
                    if (f1.isFile()) {
                        count++;
                        System.out.println(s);
                    }
                }
                System.out.println("The total number : " + count);
            }
        }
        
            </code></pre>
            <pre><output>
                abc.txt
                def.txt
                ghi.txt
                jkl.txt
                The total number : 4
            </output></pre>
        
            <p class="bg-warning text-white">To display only directory names.</p>
            <pre><code>
                import java.io.File;
                import java.io.IOException;
                public class Test {
        
                    public static void main(String[] args) throws IOException {
                        int count = 0;
                        File f = new File("E://xyz");
                
                        String[] list = f.list();
                
                        for (String s : list) {
                            File f1 = new File(f, s);
                            if (f1.isDirectory()) {
                                count++;
                                System.out.println(s);
                            }
                        }
                        System.out.println("The total number : " + count);
                    }
                }
            </code></pre>
            <pre><output>
                dir1
                dir2
                The total number : 2
            </output></pre>
        
        
            <h3>2. FileWriter</h3>
            <p>We can use FileWriter to write character data to the file.</p>
        
            <h6>Constructors</h6>
            <pre><code>
                1. FileWriter fw = new FileWriter(String fname);
                2. FileWriter fw = new FileWriter(File f);
            
                - The above FileWriters meant for overriding of existing data. Instead 
                of overriding if we want append operation then we have to create FileWriter 
                by using the following constructors.
        
                3. FileWriter fw = new FileWriter(String fname, boolean append);
                4. FileWriter fw = new FileWriter(File f, boolean append);
                
            </code></pre>
        
            <mark>Note : If the specified file is not already available then all the above constructors 
                will create that file.</mark><br><br>
        
                <h6>Methods</h6>
            <pre><code>
                1. write(int ch)
                    - To write a single character
        
                2. write(char[] ch)
                    - To write an array of characters
        
                3. write(String s)
                    - To write String to the file
        
                4. flush()  //rice example
                    - To give the guarantee that total data including last character
                    will be written to the file 
                    
                5. close() 
                    - To close the writer
            </code></pre>
        
            <pre><code>
        import java.io.FileWriter;
        import java.io.IOException;
        
        public class FileWriterDemo {
        
            public static void main(String[] args) throws IOException {
                FileWriter fw = new FileWriter("abc.txt");
                fw.write(100);
                fw.write("urga\nSoftwareSolutions");
                fw.write('\n');
                char[] ch1 = {'a', 'b', 'c'};
                fw.write(ch1);
                fw.write('\n');
                fw.flush();
                fw.close();
            }
        }
        
            </code></pre>
            
            <pre><output>
                In abc.txt file -----------------
                durga
                SoftwareSolutions
                abc
            </output></pre>
        
            <p>In the above program FileWriter can perform overriding of existing data. 
                Instead of overriding if we want append operation then we have to create 
                FileWriter object as follows</p>
        
                <pre><code>
                    public class FileWriterDemo {
        
                        public static void main(String[] args) throws IOException {
                            FileWriter fw = new FileWriter("abc.txt", true);
                            fw.write(100);
                            fw.write("urga\nSoftwareSolutions");
                            fw.write('\n');
                            char[] ch1 = {'a', 'b', 'c'};
                            fw.write(ch1);
                            fw.write('\n');
                            fw.flush();
                            fw.close();
                        }
                    }
                </code></pre>
                
                <pre><output>
        After running multiple times------------
        durga
        SoftwareSolutions
        abc
        durga
        SoftwareSolutions
        abc
        durga
        SoftwareSolutions
        abc
        durga
        SoftwareSolutions
        abc
        durga
        SoftwareSolutions
        abc
        durga
        SoftwareSolutions
        abc
        durga
        SoftwareSolutions
        abc
                </output></pre>
        <mark>Note : The main problem with FileWriter is we have to insert line separator 
            manually which is varied from system to system. It is difficulty to the programmer.
            We can solve this problem using BufferedWriter and PrintWriter classes</mark>
            <br><br>
        
            <h3>3. FileReader</h3>
        <p>We can use FileReader to read character data from the file.</p>
        <h6>Constructors</h6>
        <pre><code>
            1. FileReader fr = new FileReader(String fname);
            2. FileReader fr = new FileReader(File f);
        </code></pre>
        
        <h6>Methods</h6>
        <pre><code>
            1. int read()
                - It attempts to read next character from the file and returns its 
                unicode value. If the next character not available then this method 
                returns -1. As this method returns unicode value(int value), at the time 
                of printing we have to perform typecasting 
            
        </code></pre>
        
        <pre><code>
        import java.io.FileReader;
        import java.io.IOException;
        
        public class FileReaderDemo {
        
            public static void main(String[] args) throws IOException {
                FileReader fr = new FileReader("abc.txt");
                int i = fr.read();
                while(i != -1) {
                    System.out.print((char)i);
                    i = fr.read();
                }
            }
        }
        
        </code></pre>
        
        <pre><output>
            durga
            SoftwareSolutions
            abc
        </output></pre>
        
        <pre><code>
            2. int read(char[] ch)
                - It attempts to read enough characters from the file into char array
                and returns number of characters copied from the file.
        </code></pre>
        
        <pre><code>
        import java.io.File;
        import java.io.FileReader;
        import java.io.IOException;
        
        public class FileWriterDemo {
        
            public static void main(String[] args) throws IOException {
                File f = new File("abc.txt");
                char[] ch = new char[(int)f.length()];
                FileReader fr = new FileReader(f);
                fr.read(ch);
                for(char ch1 : ch) {
                    System.out.print(ch1);
                }
            }
        }
        </code></pre>
        
        <pre><output>
            durga
            SoftwareSolutions
            abc
        </output></pre>
        
        <pre><code>
            3. void close()
        </code></pre>
        <mark>Note : By using FileReader we can read data character by character which is not convenient
            to the programmer.
        </mark>
        <br><br>
        
        <p style="color: darkblue;"> Usage of FileWriter and FileReader is not recommended because while writing
        data by FileWriter we have to insert line separator(\n) manually which is varied from system to system 
        which is difficult to the programmer. By using FileReader we can read data character by character, which is 
        not convenient to the programmer. <br>
        To overcome these problems we should go for BufferedWriter and BufferedReader.</p>
        
        
        
        <h3>4. BufferedWriter</h3>
        <p>We can use BufferedWriter to write character data to the file</p>
        <h6>Constructors</h6>
        <pre><code>
            1. BufferedWriter bw = new BufferedWriter(Writer w);
            2. BufferedWriter bw = new BufferedWriter(Writer w, int buffersize);
        </code></pre>
        
        <mark>Note : BufferedWriter cant communicate directly with the file. It can communicate via 
            some Writer object.
        </mark><br><br>
        
        <div class="container">
            <p class="bg-warning text-white">Which of the following are valid?</p>
            <pre><code>
        1. BufferedWriter bw = new BufferedWriter("abc.txt");
        2. BufferedWriter bw = new BufferedWriter(new File("abc.txt"));
        3. BufferedWriter bw = new BufferedWriter(new FileWriter("abc.txt"));
        4. BufferedWriter bw = new BufferedWriter(new BufferedWriter(new FileWriter("abc.txt")));
            </code></pre>
            <pre><output>
                invalid
                invalid
                valid 
                valid
            </output></pre>
        </div> 
        
        <h6>Methods</h6>
        <pre><code>
            1. write(int ch)
            2. write(char[] ch)
            3. write(String s)
            4. flush()
            5. close()
            6. newLine()
                - To insert a line separator
        </code></pre>
        
        <div class="container">
            <p class="bg-warning text-white">When compared with FileWriter which of the following capability available 
                extra in method form in BufferedWriter?</p>
        
                <pre><code>
                    1. writing data to the file
                    2. close the file 
                    3. flushing the file 
                    4. inserting a new line character
                </code></pre>
                <pre><output>
                    Inserting a new line character&#10004
                </output></pre>
        </div> 
        
        <pre><code>
            import java.io.BufferedWriter;
            import java.io.FileWriter;
            import java.io.IOException;
            
            public class BufferedWriterDemo {
            
                public static void main(String[] args) throws IOException {
                    FileWriter fw = new FileWriter("abc.txt");
                    BufferedWriter bw = new BufferedWriter(fw);
                    bw.write(100);
                    bw.newLine();
                    char[] ch1 = {'a', 'b', 'c', 'd'};
                    bw.write(ch1);
                    bw.newLine();
                    bw.write("durga");
                    bw.newLine();
                    bw.write("Software solutions");
                    bw.flush();
                    bw.close();
                }
            }
        </code></pre>
        
        <pre><output>
            d
            abcd
            durga
            Software solutions
        </output></pre>
        
        <mark>Note : Whenever we are closing BufferedWriter automatically internal FileWriter will 
            be closed and we are not required to close explicitly.</mark>
        <br><br>
        
        <table class="table table-striped">
            <tbody>
                <tr>
                    <td>bw.close();</td>
                    <td>fw.close();</td>
                    <td>bw.close()<br>fw.close()</td>
                </tr> 
                <tr>
                    <td>&#10004</td>
                    <td>&#10060</td>
                    <td>&#10060</td>
                </tr>  
            </tbody>
        </table>
        
        
            <h3>5. BufferedReader</h3>
            <p>We can use BufferedReader to read character data from the file. The main advantage 
                of BufferedReader when compared with FileReader is we can read data line by line in addition 
                to character by character.
            </p>
        
        <h6>Constructors</h6>
        <pre><code>
            1. BufferedReader br = new BufferedReader(Reader r);
            2. BufferedReader br = new BufferedReader(Reader r, int buffersize);
        </code></pre>
        <p>BufferedReader cant communicate directly with the file and it can communicate via some Reader object. 
        
        </p>
        <h6>Method</h6>
        <pre><code>
            1. int read();
            2. int read(char[] ch);
            3. void close();
            4. String readLine();
                - It attempts to read next line from the file and returns it.
                If the next line not available then this method returns null.
        </code></pre>
        
        <pre><code>
            import java.io.BufferedReader;
            import java.io.FileReader;
            import java.io.IOException;
            
            public class BufferedReaderDemo {
                public static void main(String[] args) throws IOException {
                    FileReader fr = new FileReader("abc.txt");
                    BufferedReader br = new BufferedReader(fr);
                    String line = br.readLine();
                    while(line != null) {
                        System.out.println(line);
                        line = br.readLine();
                    }
                    br.close();
                }
            }
            
        </code></pre>
        
        <pre><output>
            d
            abcd
            durga
            Software solutions    
        </output></pre>
        
        <mark>Note : Whenever we are closing BufferedReader automatically underlying FileReader 
            will be closed and we are not required to close explicitly</mark><br><br>
        <mark>Note : The most enhanced reader to read character data from the file is BufferedReader.</mark>
        
        <h3>6. PrintWriter</h3>
        <p>It is the most enhanced writer to write character data to the file. The main advantage of PrintWriter 
            over FileWriter and BufferedWriter is we can write any type of primitive data directly to the file</p>
        
        <h6>Constructors</h6>
        <pre><code>
            1. PrintWriter pw = new PrintWriter(String fname);
            2. PrintWriter pw = new PrintWriter(File f);
            3. PrintWriter pw = new PrintWriter(Writer w);
        </code></pre>
        <mark>Note : PrintWriter can communicate directly with the file and can communicate via some 
            writer object also</mark><br><br>
        <h6>Methods</h6>
        <pre><code>
            1. write(int ch)
            2. write(char[] ch)
            3. write(String s)
            4. flush()
            5. close()
        
            6. print(char ch)
            7. print(int i)
            8. print(double d)
            9. print(boolean b)
            10. print(String s)
        
            11. println(char ch)
            12. println(int i)
            13. println(double d)
            14. println(boolean b)
            15. println(String s)
        </code></pre>
        
        <pre><code>
            import java.io.IOException;
            import java.io.PrintWriter;
            
            public class PrintWriterDemo {
            
                public static void main(String[] args) throws IOException {
                    FileWriter fw = new FileWriter("abc.txt");
                    PrintWriter out = new PrintWriter(fw);
                    out.write(100);
                    out.println(100);
                    out.println(true);
                    out.println('c');
                    out.println("durga");
                    out.flush();
                    out.close();
                }
            
            }
            
        </code></pre>
        
        <pre><output>
            d100
            true
            c
            durga    
        </output></pre>
        
        <div class="container">
            <p class="bg-warning text-white">What is the difference between write(100) & print(100)?</p>
            <p>In the case of write(100) the corresponding character d will be added to the file but in the case 
                of print(100) the int value 100 will be added to the file directly.
        </div> 
        
        <mark>Note : The most enhanced writer to write character data to the file is PrintWriter whereas the most 
            enhanced reader to read character data from the file is BufferedReader</mark>
        
        <br><br>
        
        <mark>Note : In general we can use Readers and Writers to handle character data(text data) whereas we can use 
            Streams to handle binary data(like images, pdf, video files, audio files....). We can use OutputStream to write 
            binary data to the file, InputStream to read binary data from the file</mark> 
        
        <br><br>
        
        <img src="images/ss126.png" alt="ss12" width="700" height="500">
        
        <div class="container">
            <p class="bg-warning text-white">Write a program to merge data from two files into a third file.</p>
            <pre><code>
                import java.io.BufferedReader;
                import java.io.FileReader;
                import java.io.IOException;
                import java.io.PrintWriter;
                
                public class FileMerger {
                
                    public static void main(String[] args) throws IOException {
                        PrintWriter pw = new PrintWriter("file3.txt");
                        BufferedReader br = new BufferedReader(new FileReader("file1.txt"));
                        String line = br.readLine();
                        while (line != null) {
                            pw.println(line);
                            line = br.readLine();
                        }
                        br = new BufferedReader(new FileReader("file2.txt"));
                        line = br.readLine();
                        while (line != null) {
                            pw.println(line);
                            line = br.readLine();
                        }
                        pw.flush();
                        br.close();
                        pw.close();
                    }
                
                }
            </code></pre>
            
            <pre><output>
                file1.txt--------------------------
                AAA 
                BBB 
                CCC 
        
                file2.txt-------------------------- 
                111
                222
                333
        
                file3.txt--------------------------- 
                AAA
                BBB
                CCC
                111
                222
                333        
            </output></pre>   
        </div> 
        
        <div class="container">
            <p class="bg-warning text-white">WAP to perform file merge operation where merging
                should be done line by line alternatively.
            </p>
            <pre><code>
                import java.io.BufferedReader;
                import java.io.FileReader;
                import java.io.IOException;
                import java.io.PrintWriter;
                
                public class FileMerger {
                
                    public static void main(String[] args) throws IOException {
                        PrintWriter pw = new PrintWriter("file3.txt");
                        BufferedReader br1 = new BufferedReader(new FileReader("file1.txt"));
                        BufferedReader br2 = new BufferedReader(new FileReader("file2.txt"));
                        String line1 = br1.readLine();
                        String line2 = br2.readLine();
                        while (line1 != null || line2 != null) {
                            if (line1 != null) {
                                pw.println(line1);
                                line1 = br1.readLine();
                            }
                            if (line2 != null) {
                                pw.println(line2);
                                line2 = br2.readLine();
                            }
                        }
                        
                        pw.flush();
                        br1.close();
                        br2.close();
                    }
                
                }
            </code></pre>
            
            <pre><output>
                file1.txt--------------------------
                AAA 
                BBB 
                CCC 
        
                file2.txt-------------------------- 
                111
                222
                333
                444
                555
                
                file3.txt-------------------------
                AAA
                111
                BBB
                222
                CCC
                333
                444
                555  
            </output></pre>
        </div> 
        <div class="fluid-container">
            <p class="bg-warning text-white">WAP to perform file extraction operation.</p>
            
            <pre><code>
                import java.io.BufferedReader;
                import java.io.FileReader;
                import java.io.IOException;
                import java.io.PrintWriter;
                
                public class FileExtractor {
                
                    public static void main(String[] args) throws IOException {
                        PrintWriter pw = new PrintWriter("output.txt");
                        BufferedReader br1 = new BufferedReader(new FileReader("input.txt"));
                        String line = br1.readLine();
                        while(line != null) {
                            boolean available = false;
                            BufferedReader br2 = new BufferedReader(new FileReader("delete.txt"));
                            String target = br2.readLine();
                            while(target != null) {
                                if(line.equals(target)) {
                                    available = true;
                                    break;
                                }
                                target = br2.readLine();
                            }
                            if(available == false) {
                                pw.println(line);
                            }
                            line = br1.readLine();
                        } 
                        pw.flush();
                    }
                }
            </code></pre>
            <img src="images/ss127.png" alt="ss12" width="400" height="600">
        </div> 
        
        <div class="fluid-container">
            <p class="bg-warning text-white">Write a java program to remove duplicates from the given input file.</p>
            <pre><code>
                import java.io.BufferedReader;
                import java.io.FileReader;
                import java.io.IOException;
                import java.io.PrintWriter;
                
                public class FileExtractor {
                
                    public static void main(String[] args) throws IOException {
                        PrintWriter pw = new PrintWriter("output.txt");
                        BufferedReader br1 = new BufferedReader(new FileReader("input.txt"));
                        String line = br1.readLine();
                        while(line != null) {
                            boolean available = false;
                            BufferedReader br2 = new BufferedReader(new FileReader("output.txt"));
                            String target = br2.readLine();
                            while(target != null) {
                                if(line.equals(target)) {
                                    available = true;
                                    break;
                                }
                                target = br2.readLine();
                            }
                            if(available == false) {
                                pw.println(line);
                                pw.flush();
                            }
                            line = br1.readLine();
                        } 
                        pw.flush();
                    }
                }
            </code></pre>
            <img src="images/ss128.png" alt="ss12" width="400" height="600">
        </div>
        <h1>Serialization</h1>
        <h3>1. Introduction</h3>
        <h6>Serialization</h6>
        <p>The process of writing state of an object to a file is called Serialization. But strictly 
            speaking it is the process of converting an object from java supported form into either 
            file supported form or network supported form.
        </p>
        <p>By using FileOutputStream and ObjectOutputStream classes we can implement Serialization.</p>
        <img src="images/ss129.png" alt="ss12" width="400" height="400">
    
        <h6>Deserialization</h6>
        <p>The process of reading state of an object from the file is called Deserialization. But strictly 
            speaking it is the process of converting an object from either file supported form or network 
            supported form into java supported form.
        </p>
        <p>By using FileInputStream and ObjectInputStream classes we can implement Deserialization</p>
        <img src="images/ss130.png" alt="ss12" width="400" height="400">
    
        <pre><code>
            import java.io.FileInputStream;
            import java.io.FileOutputStream;
            import java.io.IOException;
            import java.io.ObjectInputStream;
            import java.io.ObjectOutputStream;
            import java.io.Serializable;
            
            class Dog <span style="color: red;">implements Serializable</span> {
                int i = 10;
                int j = 20;
            }
            
            public class SerializeDemo {
            
                public static void main(String[] args) <span style="color: red;">throws IOException, ClassNotFoundException</span> {
                    Dog d1 = new Dog();
    
                    <span style="color: red;">//Serialization</span>
                    FileOutputStream fileOutputStream = new FileOutputStream("abc.ser");
                    ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
                    objectOutputStream.writeObject(d1);
            
                    <span style="color: red;">//Deserialization</span>
                    FileInputStream fileInputStream = new FileInputStream("abc.ser");
                    ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
                    Dog d2 = (Dog) objectInputStream.readObject();
            
                    System.out.println(d2.i + "......" + d2.j);
            
                }
            
            }
        </code></pre>
        
        <pre><output>
            10......20
        </output></pre>
        <img src="images/ss131.png" alt="ss12" width="400" height="400">
        <p>We can serialize only Serializable objects. An object is said to be Serializable iff the corresponding class implements 
            Serializable interface.</p>
            <p> Serializable interface present in java.io package and it doesnt contain any methods. It is a marker interface</p>
            <p>If we are trying to serialize a non Serializable object then we will get RE: saying NotSerializableException</p>
    
        <h6>transient keyword</h6>
    <p>transient modifier applicable only for variables but not for methods and classes.</p>
    <p>At the time of Serialization if we dont want to save the value of a particular variable to meet security constraints then 
        we should declare that variable as transient.
    </p>
    <p>While performing Serialization JVM ignores original value of transient variable and save default value to the file</p>
    <p class="bg-primary text-white">Hence transient means not to serialize.</p>
    <pre><code>
        import java.io.FileInputStream;
        import java.io.FileOutputStream;
        import java.io.IOException;
        import java.io.ObjectInputStream;
        import java.io.ObjectOutputStream;
        import java.io.Serializable;
        
        class Dog implements Serializable {
            int i = 10;
            transient int j = 20;
        }
        
        public class SerializeDemo {
        
            public static void main(String[] args) throws IOException, ClassNotFoundException {
                Dog d1 = new Dog();
                FileOutputStream fileOutputStream = new FileOutputStream("alpha.txt");
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
                objectOutputStream.writeObject(d1);
        
                FileInputStream fileInputStream = new FileInputStream("alpha.txt");
                ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
                Dog d2 = (Dog) objectInputStream.readObject();
        
                System.out.println(d2.i + "......" + d2.j);
        
            }
        
        }
        
    </code></pre>
    
    <pre><output>
        10......0
    </output></pre>
    
    <h6>transient vs static</h6>
    <p>static variable is not part of object state and hence it wont participate in Serialization due to this 
        declaring static variable as transient there is no use</p>
    
    <h6>final vs transient</h6>
    <p>final variables will be participated in Serialization directly by the value hence declaring a final 
        variable as transient there is no impact.</p>
    
        <table class="table table-striped">
            <thead class="thead-dark">
                <tr>
                    <th>declaration</th>
                    <th>output</th>
                </tr>
            </thead> 
            <tbody>
                <tr>
                    <td>
                        <pre><code>
    int i = 10;
    int j = 20;
                        </code></pre>
    
                    </td>
                    <td> 10...20</td>
                </tr> 
                <tr>
                    <td>
                        <pre><code>
    transient int i = 10;
    int j = 20;
                        </code></pre>
    
                    </td>
                    <td> 0...20</td>
                </tr>  
                <tr>
                    <td>
                        <pre><code>
    transient static int i = 10;
    transient int j = 20;
                        </code></pre>
    
                    </td>
                    <td> 10...0</td>
                </tr> 
                <tr>
                    <td>
                        <pre><code>
    transient int i = 10;
    transient final int j = 20;
                        </code></pre>
    
                    </td>
                    <td> 0...20</td>
                </tr> 
                <tr>
                    <td>
                        <pre><code>
    transient static int i = 10;
    transient final int j = 20;
                        </code></pre>
    
                    </td>
                    <td> 10...20</td>
                </tr> 
            </tbody>
        </table>
    
        <mark>Note : We can serialize any number of objects to the file but in which order we serialized in the 
            same order only we have to deserialize i.e order of objects is important in Serialization.
        </mark>
    
        <pre><code>
            import java.io.FileInputStream;
            import java.io.FileOutputStream;
            import java.io.IOException;
            import java.io.ObjectInputStream;
            import java.io.ObjectOutputStream;
            import java.io.Serializable;
            
            class Dog implements Serializable {
                int i = 10;
                int j = 20;
            }
            
            class Cat implements Serializable {
                int p = 30;
                int q = 40;
            }
            
            class Rat implements Serializable {
                int r = 50;
                int s = 60;
            }
            
            public class SerializeDemo {
            
                public static void main(String[] args) throws IOException, ClassNotFoundException {
                    Dog d1 = new Dog();
                    Cat c1 = new Cat(); 
                    Rat r1 = new Rat();
                    
                    FileOutputStream fileOutputStream = new FileOutputStream("alpha.txt");
                    ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
                    objectOutputStream.writeObject(d1);
                    objectOutputStream.writeObject(c1);
                    objectOutputStream.writeObject(r1);
            
                    FileInputStream fileInputStream = new FileInputStream("alpha.txt");
                    ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
                    Dog d2 = (Dog)objectInputStream.readObject();
                    Cat c2 = (Cat)objectInputStream.readObject();
                    Rat r2 = (Rat)objectInputStream.readObject();
            
                }
            }
            
        </code></pre>
    
        <p>If we dont know order of objects in Serialization</p>
        <pre><code>
            FileInputStream fileInputStream = new FileInputStream("alpha.txt");
            ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
            Object o = objectInputStream.readObject();
    
            if (o instanceof Dog) {
                Dog d2 = (Dog) o;
                //perform Dog specific functionality
            } else if (o instanceof Cat) {
                Cat c2 = (Cat) o;
                //perform Cat specific functionality
            } else if (o instanceof Rat) {
                Rat r2 = (Rat) o;
                //perform Rat specific functionality
                
                
            }
        </code></pre>
    
        <h3>2. Objects graphs in Serialization</h3>
        <p>Whenever we are serializing an object, the set of all objects which are reachable from that object 
            will be serialized automatically. This group of object is nothing but object graph.</p>
        <p> In object graph every object should be Serializable if atleast one object is not Serializable then we will 
            get RE saying NotSerializableException</p>
        
            <pre><code>
                import java.io.FileInputStream;
                import java.io.FileOutputStream;
                import java.io.IOException;
                import java.io.ObjectInputStream;
                import java.io.ObjectOutputStream;
                import java.io.Serializable;
                
                class Dog implements Serializable {
                    Cat c = new Cat();
                }
                
                class Cat implements Serializable {
                    Rat r = new Rat();
                }
                
                class Rat implements Serializable {
                    int j = 20;
                }
                
                public class ObjectGraphDemo {
                    public static void main(String[] args) throws IOException, ClassNotFoundException {
                        Dog d1 = new Dog();
                        FileOutputStream fileOutputStream = new FileOutputStream("alpha.txt");
                        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
                        objectOutputStream.writeObject(d1);
                        
                        FileInputStream fileInputStream = new FileInputStream("alpha.txt");
                        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
                        Dog d2 = (Dog)objectInputStream.readObject();
                        
                        System.out.println(d2.c.r.j);
                    }
                
                }
                
            </code></pre>
            
            <pre><output>
                20
            </output></pre>
    
    <p>In the above program Whenever we are serializing Dog object automatically Cat and Rat objects got serialized.
        because these are part of object graph of Dog</p>
    <p>Among Dog Cat and Rat objects if atleast one object is not Serializable then we will get RE saying 
        NotSerializableException.</p>
    
        <img src="images/ss132.png" alt="ss12" width="400" height="600">
    
        <h3>3. Customized Serialization</h3>
        <p>1. During default Serialization there may be a chance of loss of information beacuse of transient 
            keyword</p>
    <pre><code>
    import java.io.FileInputStream;
    import java.io.FileNotFoundException;
    import java.io.FileOutputStream;
    import java.io.IOException;
    import java.io.ObjectInputStream;
    import java.io.ObjectOutputStream;
    import java.io.Serializable;
    
    class Account implements Serializable {
        String username = "durga";
        transient String pwd = "anushka";
    }
    
    public class CustSerializeDemo {
    
        public static void main(String[] args) throws IOException, ClassNotFoundException {
            Account a1 = new Account();
            System.out.println(a1.username + "......" + a1.pwd);
            FileOutputStream fileOutputStream = new FileOutputStream("abc.ser");
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
            objectOutputStream.writeObject(a1);
    
            FileInputStream fileInputStream = new FileInputStream("abc.ser");
            ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
            Account a2 = (Account) objectInputStream.readObject();
            
            System.out.println(a2.username + "....." + a2.pwd);
        }
    
    }
    </code></pre>
    
    <pre><output>
        durga......anushka
        durga.....null
    </output></pre>
    <img src="images/ss133.png" alt="ss12" width="500" height="500">
    
    <p>In the above example before Serialization Account object can provide proper username and password but 
        after Deserialization Account object can provide only username but not password. This is due to declaring
        password variable as transient.</p>
    <p>Hence during default Serialization there may be a chance of loss of information because of transient 
        keyword. To recover this loss of information we should go for Customized Serialization</p>
    
    <p>We can implement Customized Serialization by using the following two methods</p>
    <pre><code>
        1. private void writeObject(ObjectOutputStream objectOutputStream) throws Exception 
        
    </code></pre>
    
    <p>This method will be executed automatically at the time of Serialization. Hence at the time of Serialization 
        if we want to perform any activity we have to define that in this method only.</p>
        <pre><code>
    
            2. private void readObject(ObjectInputStream objectInputStream) throws Exception;
        </code></pre>
        <p>This method will be executed automatically at the time of deserialization. Hence at the time of deserialization 
            if we want to perform any activity we have to define that in this method only.</p>
    
    <mak>Note : The above methods are call back methods because these are executed automatically by the JVM</mak>
    <p>While performing which object Serialization we have to do extra work, in the corresponding class we have to define above methods</p>
    <p>For example - While performing Account object Serialization if we require to do extra work, in the Account class we have 
        to define above methods.</p>
    
    <pre><code>
        import java.io.FileInputStream;
        import java.io.FileOutputStream;
        import java.io.IOException;
        import java.io.ObjectInputStream;
        import java.io.ObjectOutputStream;
        import java.io.Serializable;
        
        class Account implements Serializable {
            String username = "durga";
            transient String password = "anushka";
        
            private void writeObject(ObjectOutputStream objectOutputStream) throws IOException {
                <span style="color: red;">objectOutputStream.defaultWriteObject();</span>
                String encryptedPassword = "123" + password;
                objectOutputStream.writeObject(encryptedPassword);
            }
        
            private void readObject(ObjectInputStream objectInputStream) throws ClassNotFoundException, IOException {
                <span style="color: red;">objectInputStream.defaultReadObject();</span>
                String encryptedPassword = (String) objectInputStream.readObject();
                password = encryptedPassword.substring(3);
            }
        }
        
        public class CustSerializeDemo {
        
            public static void main(String[] args) throws IOException, ClassNotFoundException {
                Account a1 = new Account();
                System.out.println(a1.username + "......" + a1.password);
                FileOutputStream fileOutputStream = new FileOutputStream("abc.ser");
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
                objectOutputStream.writeObject(a1);
        
                FileInputStream fileInputStream = new FileInputStream("abc.ser");
                ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
                Account a2 = (Account) objectInputStream.readObject();
                System.out.println(a2.username + "....." + a2.password);
            }
        
        }
    </code></pre>
    
    <pre><output>
        durga......anushka
        durga.....anushka
    </output></pre>
    
    <img src="images/ss134.png" alt="ss12" width="700" height="600">
    
    <p>In the above program before Serialization and after Serialization Account object can provide 
        proper username and password</p>
    <mark>Note : Programmer can not call private methods directly from outside of the class but JVM can call 
        private methods directly from outside of the class.
    </mark><br><br>
    
    <pre><code>
        import java.io.FileInputStream;
        import java.io.FileOutputStream;
        import java.io.IOException;
        import java.io.ObjectInputStream;
        import java.io.ObjectOutputStream;
        import java.io.Serializable;
        
        class Account implements Serializable {
            String username = "durga";
            transient String password = "anushka";
            transient int pin = 1234;
        
            private void writeObject(ObjectOutputStream objectOutputStream) throws IOException {
                objectOutputStream.defaultWriteObject();
                String encryptedPassword = "123" + password;
                int encryptedPin = 4444 + pin;
                objectOutputStream.writeObject(encryptedPassword);
                objectOutputStream.writeInt(encryptedPin);
            }
        
            private void readObject(ObjectInputStream objectInputStream) throws ClassNotFoundException, IOException {
                objectInputStream.defaultReadObject();
                String encryptedPassword = (String) objectInputStream.readObject();
                password = encryptedPassword.substring(3);
                int encryptedPin = objectInputStream.readInt();
                pin = encryptedPin - 4444;
            }
        }
        
        public class CustSerializeDemo {
        
            public static void main(String[] args) throws IOException, ClassNotFoundException {
                Account a1 = new Account();
                System.out.println(a1.username + "......" + a1.password + "......" + a1.pin);
                FileOutputStream fileOutputStream = new FileOutputStream("abc.ser");
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
                objectOutputStream.writeObject(a1);
        
                FileInputStream fileInputStream = new FileInputStream("abc.ser");
                ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
                Account a2 = (Account) objectInputStream.readObject();
                System.out.println(a2.username + "....." + a2.password + "......" + a2.pin);
            }
        
        }
    </code></pre>
    
    <pre><output>
        durga......anushka......1234
        durga.....anushka......1234
    </output></pre>
    
    <img src="images/ss135.png" alt="ss12" width="700" height="600">
    
        <h3>4. Serialization with respect to inheritance</h3>
        <h6>Case 1 : </h6>
        <p>Even though child class doesnt implement Serializable we can serialize child class object 
            if parent class implements Serializable interface i.e Serializable nature is inheriting from parent to child 
            hence if parent is Serializable then by default every child is Serializable</p>
    <pre><code>
        import java.io.FileInputStream;
        import java.io.FileOutputStream;
        import java.io.IOException;
        import java.io.ObjectInputStream;
        import java.io.ObjectOutputStream;
        import java.io.Serializable;
        
        class Animal implements Serializable {
            int i = 10;
        }
        
        class Dog extends Animal {
            int j = 20;
        }
        
        public class SerializeDemo {
        
            public static void main(String[] args) throws IOException, ClassNotFoundException {
                Dog d1 = new Dog();
                System.out.println(d1.i + "......" + d1.j);
                FileOutputStream fileOutputStream = new FileOutputStream("abc.ser");
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
                objectOutputStream.writeObject(d1);
        
                FileInputStream fileInputStream = new FileInputStream("abc.ser");
                ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
                Dog d2 = (Dog) objectInputStream.readObject();
                System.out.println(d1.i + "......" + d1.j);
            }
        
        }
        
    </code></pre>
    
    <pre><output>
        10......20
        10......20    
    </output></pre>
    
    <img src="images/ss136.png" alt="ss12" width="400" height="400">
    
    <p>In the above example even though Dog class doesnt implement Serializable, we can serialize Dog object 
        becuase its parent Animal class implements Serializable</p>
    
    <mark>Note : Object class doesnt implement Serializable interface.</mark>
    <br><br>
    
    <p>1. Even though parent class doesnt implement Serializable, we can serialize child class object if child class 
        implements Serializable interface i.e to serialize child class object parent class need not 
        be Serializable.</p>
    <p>2. At the time of Serialization JVM will check is any variable inheriting from non Serializable parent or not.
        If any variable inheriting from non Serializable parent then JVM ignores original value and 
        save default value to the file.</p>
    <p>3. At the time of deserialization JVM will check is any parent class non Serializable or not. If any parent class 
        is non Serializable then JVM will execute instance control flow in every non Serializable parent and share 
        its instance variable to the current object.
    </p>
    <p>4. While executing instance control flow of non Serializable parent JVM will always call no argument constructor hence 
        every non Serializable class should compulsory contain no argument constructor. It may be default 
        constructor generated by compiler or Customized constructor explicitly provided by Programmer o/w we will 
    get RE saying <span style="color: red;">InvalidClassException</span></p>
    
    <pre><code>
        import java.io.FileInputStream;
        import java.io.FileOutputStream;
        import java.io.IOException;
        import java.io.ObjectInputStream;
        import java.io.ObjectOutputStream;
        import java.io.Serializable;
        
        class Animal {
            int i = 10;
            public Animal() {
                System.out.println("Animal constructor called");
            }
        }
        
        class Dog extends Animal implements Serializable{
            int j = 20;
            public Dog() {
                System.out.println("Dog constructor called");
            }
        }
        
        public class SerializeDemo {
        
            public static void main(String[] args) throws IOException, ClassNotFoundException {
                Dog d1 = new Dog();
                d1.i = 888;
                d1.j = 999;
                
                FileOutputStream fileOutputStream = new FileOutputStream("abc.ser");
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
                objectOutputStream.writeObject(d1);
        
                System.out.println("Deserialization started");
                FileInputStream fileInputStream = new FileInputStream("abc.ser");
                ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
                Dog d2 = (Dog) objectInputStream.readObject();
                System.out.println(d2.i + "......" + d2.j);
            }
        }
        
    </code></pre>
    
    <pre><output>
        Animal constructor called
        Dog constructor called
        Deserialization started
        Animal constructor called
        10......999     
    </output></pre>
    <img src="images/ss137.png" alt="ss12" width="500" height="500">
    
    <h6>Case 2 : </h6>
    <pre><code>
        import java.io.FileInputStream;
        import java.io.FileOutputStream;
        import java.io.IOException;
        import java.io.ObjectInputStream;
        import java.io.ObjectOutputStream;
        import java.io.Serializable;
        
        class Animal {
            int i = 10;
            <span style="color: red;">public Animal(int i) {
                System.out.println("Animal constructor called");
            }</span>
        }
        
        class Dog extends Animal implements Serializable{
            int j = 20;
            public Dog() {
                super(10);
                System.out.println("Dog constructor called");
            }
        }
        
        public class SerializeDemo {
        
            public static void main(String[] args) throws IOException, ClassNotFoundException {
                Dog d1 = new Dog();
                d1.i = 888;
                d1.j = 999;
                
                FileOutputStream fileOutputStream = new FileOutputStream("abc.ser");
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
                objectOutputStream.writeObject(d1);
        
                System.out.println("Deserialization started");
                FileInputStream fileInputStream = new FileInputStream("abc.ser");
                ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
                Dog d2 = (Dog) objectInputStream.readObject();
                System.out.println(d2.i + "......" + d2.j);
            }
        }
        
    </code></pre>
    
    <pre><output>
        Animal constructor called
        Dog constructor called
        Deserialization started
        Exception in thread "main" java.io.InvalidClassException: Dog; no valid constructor
    </output></pre>
    
    
        <h3>5. Externalization</h3>
    <p>In Serialization everything takes care by JVM and Programmer doesnt have any control. In Serialization 
        its always possible to save total object to the file and it is not possible to save part of the object 
        which may creates performance problems.</p>
    <p>To overcome this problem we should go for Externalization</p>
    <p>The main advantage of Externalization over Serialization is everything takes care by Programmer and 
        JVM doesnt have any control. Based on our requirement we can save either total object or part 
        of the object, which improves performance of the system.</p>
    
    <p>To provde externizable ability for any java object compulsory the corresponding class should implement 
        externizable interface.</p> 
    <p>Externalizable interface defines two methods</p>
    <pre><code>
        1. writeExternal() 
        2. readExternal()
    </code></pre>
    
    <p>Externizable is the child interface of Serializable interface</p>
    <img src="images/ss138.png" alt="ss12" width="400" height="300">
    
    <pre><code>
        1. public void writeExternal(ObjectOutput out) throws IOException
    </code></pre>
    
    <p>1. This method will be executed automatically at the time of Serialization.</p>
    <p>2. Within this method we have to write code to save required variables to the file</p>
       
    <pre><code>
        2. public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
    </code></pre>
    
    <p>This method will be executed automatically at the time of deserialization. Within 
        this method we have to write code to read required variables from the file and assign to 
        current object.
    </p>
    
    <p>But strictly speaking at the time of deserialization JVM will create a separate new object by executing 
        public no argument constructor. On that object JVM will call readExternal method.</p>
    
    <p>Hence every Externalizable implemented class should compulsory contain public no argument constructor o/w 
        we will get RE saying InvalidClassException</p>
    
    
    <pre><code>
        import java.io.Externalizable;
        import java.io.FileInputStream;
        import java.io.FileOutputStream;
        import java.io.IOException;
        import java.io.ObjectInput;
        import java.io.ObjectInputStream;
        import java.io.ObjectOutput;
        import java.io.ObjectOutputStream;
        
        public class ExternalizableDemo implements Externalizable {
        
            String s;
            int i;
            int j;
        
            public ExternalizableDemo() {
                System.out.println("public no-arg constructor");
            }
        
            public ExternalizableDemo(String s, int i, int j) {
                this.s = s;
                this.i = i;
                this.j = j;
            }
        
            @Override
            public void writeExternal(ObjectOutput out) throws IOException {
                out.writeObject(s);
                out.writeInt(i);
            }
        
            @Override
            public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
                s = (String) in.readObject();
                i = in.readInt();
            }
        
            public static void main(String[] args) throws IOException, ClassNotFoundException {
                ExternalizableDemo t1 = new ExternalizableDemo("durga", 10, 20);
        
                FileOutputStream fileOutputStream = new FileOutputStream("abc.ser");
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
                objectOutputStream.writeObject(t1);
        
                FileInputStream fileInputStream = new FileInputStream("abc.ser");
                ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
                ExternalizableDemo t2 = (ExternalizableDemo) objectInputStream.readObject();
                System.out.println(t2.s + "......" + t2.i + "....." +  t2.j);
            }
        
        }
    </code></pre>
    
    <pre><output>
        public no-arg constructor
        durga......10.....0    
    </output></pre>
    <img src="images/ss139.png" alt="ss12" width="400" height="500">
    
    <p>If the class implements Serializable then total object will be saved to the file. In this case 
        output is
    </p>
    <pre><code>
        durga......10.....20
    </code></pre>
    
    <p>If the class implements Externalizable then only required variable will be saved to the file. In this case 
        output is
    </p>
    <pre><code>
        durga......10.....0
    </code></pre>
    
    <mark>Note : In Serialization transient keyword will play role but in Externalization transient keyword wont 
        play any role ofcourse transient keyword not required in Externalization</mark>
    <br><br>
    
    <h6>Differences between Serialization and Externalization</h6>
    <table class="table table-striped">
        <thead class="thead-dark">
            <tr>
                <th>Serialization</th>
                <th>Externalization</th>
            </tr>
        </thead> 
        <tbody>
            <tr>
                <td>It is meant for default Serialization</td>
                <td>It is meant for Customized Serialization</td>
            </tr> 
            <tr>
                <td>Here everything takes care by JVM and Programmer doesnt have any control</td>
                <td>Here everything takes care by Programmer and JVM doesnt have any control</td>
            </tr> 
            <tr>
                <td>In this case its always possible to save total object to the file and it is not 
                    possible to save part of the object
                </td>
                <td>Based on our requirement we can save either total object or part of the object.</td>
            </tr> 
            <tr>
                <td>Relatively performance is low</td>
                <td>Relatively performance is high</td>
            </tr> 
            <tr>
                <td>It is the best choice if we want to save total object to the file</td>
                <td>It is the best choice if we want to save part of the object to the file</td>
            </tr> 
            <tr>
                <td>Serializable interface doesnt conatin any methods and it is a marker interface</td>
                <td>Externalizable interface contains two methods writeExternal and readExternal and hence 
                    it is not a marker interface
                </td>
            </tr> 
            <tr>
                <td>Serializable implemented class not required to contain public no argument constructor</td>
                <td>Externalizable implemented class should compulsory contain public no argument constructor 
                    o/w we will get RE saying InvalidClassException
                </td>
            </tr> 
            <tr>
                <td>transient keyword will play role in Serialization</td>
                <td>transient keyword wont play any role in Externalization ofcourse it wont be required</td>
            </tr>  
        </tbody>
    </table>
    
    <h3>6. SerialVersionUID</h3>
    <p>In Serialization both sender and receiver need not be same person, need not to use 
        same machine and need not be from the same location. The persons may be different, the machines may 
        be different and locations may be different</p>
    
    <p>In Serialization both sender and receiver should has .class file at the beginning only just 
        state of object is travelling from sender to receiver.</p>
       
    <p>At the time of Serialization with every object sender side JVM will save a unique identifier.
        JVM is responsible to generate this unique identifier based on .class file</p>
    
    <p>At the time of deserialization receiver side JVM will compare unique identifier associated with the object 
        with the local class unique identifier. If both are matched then only deserialization will be performed 
        o/w we will get RE : InvalidClassException. This unique identifier is nothing but SerialVersionUID.
    </p>
    
    <h6>Problems of depending on default SerialVersionUID generated by JVM</h6>
    <p>1. Both sender and receiver should use same JVM wrt vendor and platorm and version o/w receiver 
        unable to deserialize because of different SerialVersionUIDs</p>
    
    <p>2. Both sender and receiver should use same .class file version. After Serialization if there is any change 
        in .class file at receiver side then receiver unable to deserialize.
    </p>
    
    <p>3. To generate SerialVersionUID internally JVM may use complex algorithm which may create performance problems</p>
    
    <p>We can solve above problems by configuring our own SerialVersionUID.</p>
    <p>We can configure our own SerialVersionUID as follows</p>
    <pre><code>
        private static final long serialVersionUID = 1l;
    </code></pre>
    <p>Example : </p>
    <pre><code>
        class Dog1 implements Serializable {
            private static final long serialVersionUID = 1l;
            int i = 10;
            int j = 20; 
        }
    
        class Sender {
            public static void main(String[] args) throws Exception {
                Dog1 d1 = new Dog1();
                FileOutputStream fileOutputStream = new FileOutputStream("abc.ser");
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
                objectOutputStream.writeObject(d1);
            }
        }
    
        class Receiver {
            public static void main(String[] args) throws Exception { {
                FileInputStream fileInputStream = new FileInputStream("abc.ser");
                ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
                Dog d2 = (Dog)objectInputStream.readObject();
                System.out.println(d2.i + "..." + d2.j);
            }
        }
    </code></pre>
    
    <p>In the above program after Serialization if we perform any change to the .class file at receiver 
        side we wont get any problem at the time of deserialization.</p>
    <p>In this case sender and receiver not required to maintain same JVM versions</p>
    <mark>Note : Some IDEs prompt Programmer to enter SerialVersionUID explicitly</mark>
    <br><br><p>Some IDEs may generate SerialVersionUID automatically</p>
    
    
    <h1>Regular Expressions</h1>
    <p>If we want to represent a group of Strings according to a particular pattern then 
        we should go for Regular Expressions.</p>
    <p>Example 1 : We can write a Regular Expressions to represent all valid mobile numbers</p>
    <p>Example 2 : We can write a Regular Expressions to represent all mail ids</p>
    
    <p>The main important application areas of Regular Expressions are</p>
    <p>1. To develop validation frameworks</p>
    <p>2. To develop pattern matching applications(ctrl-F in windows and Grep in UNIX)</p>
    <p>3. To develop translators like assemblers, compilers, interpreters etc</p>
    <p>4. To develop digital circuits</p>
    <p>5. To develop communication protocols like TCP/IP, UDP etc</p>

<pre><code>
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    public class RegExDemo {
    
        public static void main(String[] args) {
            int count = 0;
            Pattern p = Pattern.compile("ab");
            Matcher m = p.matcher("abbabba");
            while (m.find()) {
                ++count;
                System.out.println(m.start() + "..." + m.end() + "..." + m.group());
            }
            System.out.println("The total number of occurences : " + count);
        }
    
    }
    
</code></pre>

<pre><output>
    0...2...ab
    3...5...ab
    The total number of occurences : 2    
</output></pre>
    
<h6>Pattern</h6>
<p>A Pattern object is a compiled version of Regular Expression i.e it is a java equivalent 
    object of Pattern</p>
<p>We can Pattern object by using compile method of Pattern class</p>
<pre><code>
    public static Pattern compile(String re)
</code></pre>

<p>Example : </p>
<pre><code>
    Pattern p = Pattern.compile("ab");
</code></pre>

<h6>Matcher</h6>
<p>We can use Matcher object to check the given Pattern in the target String</p>
<p>We can create a Matcher object by using matcher method of Pattern class</p>
<pre><code>
    public Matcher matcher(String target)
</code></pre>
<p>Example : </p>
<pre><code>
    Matcher m = p.matcher("abbabba");
</code></pre>

<h6>Important methods of Matcher class</h6>
<pre><code>
    1. boolean find()
    - It attempts to find the next match and returns true 
    if it is available

    2. int start()
    - It returns start index of the match

    3. int end()
    - returns end + 1 index of the match

    4. String group()
    - It returns the match pattern
</code></pre>

<mark>Note : Pattern and Matcher classes present in java.util.regex package and introduced in 
    1.4v</mark><br><br>

<h6>Character classes</h6>
<p>[abc] = either 'a' or 'b' or 'c'</p>
<p>[^abc] = except 'a' and 'b' and 'c'</p>
<p>[a-z] = Any lower case alphabet symbol from a to z</p>
<p>[A-Z] = Any upper case alphabet symbol from A to Z</p>
<p>[a-zA-Z] = Any alphabet symbol</p>
<p>[0-9] = Any digit from 0 to 9</p>
<p>[0-9a-zA-Z] = Any alphanumeric symbol</p>
<p>[^0-9a-zA-Z] = Except alphanumeric symbol(special symbol)</p>

<pre><code>
    public class RegExDemo {

        public static void main(String[] args) {
            Pattern p = Pattern.compile("[abc]");
            Matcher m = p.matcher("a3b#k@9z");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
        }
    }    
</code></pre>

<pre><output>
    0...a
    2...b
</output></pre>

<pre><code>
    public class RegExDemo {

        public static void main(String[] args) {
            Pattern p = Pattern.compile("[^abc]");
            Matcher m = p.matcher("a3b#k@9z");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
        }
    }
    
</code></pre>

<pre><output>
    1...3
    3...#
    4...k
    5...@
    6...9
    7...z    
</output></pre>

<pre><code>
    public class RegExDemo {

        public static void main(String[] args) {
            Pattern p = Pattern.compile("[a-z]");
            Matcher m = p.matcher("a3b#k@9z");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
        }
    }
    </code></pre>

<pre><output>
    0...a
    2...b
    4...k
    7...z    
</output></pre>

<pre><code>
    public class RegExDemo {

        public static void main(String[] args) {
            Pattern p = Pattern.compile("[0-9]");
            Matcher m = p.matcher("a3b#k@9z");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
        }
    }
    
</code></pre>

<pre><output>
    1...3
    6...9    
</output></pre>

<pre><code>
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("[a-zA-Z0-9]");
            Matcher m = p.matcher("a3b#k@9z");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
          }
    }    
</code></pre>

<pre><output>
    0...a
    1...3
    2...b
    4...k
    6...9
    7...z    
</output></pre>

<pre><code>
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("[a-zA-Z0-9]");
            Matcher m = p.matcher("a3b#k@9z");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
        }
    }    
</code></pre>

<pre><output>
    3...#
    5...@    
</output></pre>

<h6>Predefined character classes</h6>
<p>\s = space character<br>
    \S = except space character<br>
    \d = Any digit from 0 to 9[0-9]<br>
    \D = except digit, any character<br>
    \w = Any word character[0-9a-zA-Z]<br>
    \W = except word characters[special characters]<br>
    . = Any character</p> 

<pre><code>
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("\\s");
            Matcher m = p.matcher("a7b k@9z");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
        }
    }
</code></pre>

<pre><output>
    3... 
</output></pre>

<pre><code>
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("\\S");
            Matcher m = p.matcher("a7b k@9z");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
        }
    }
</code></pre>

<pre><output>
    0...a
    1...7
    2...b
    4...k
    5...@
    6...9
    7...z    
</output></pre>

<pre><code>
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("\\d");
            Matcher m = p.matcher("a7b k@9z");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
        }
    }
</code></pre>

<pre><output>
    1...7
    6...9     
</output></pre>

<pre><code>
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("\\D");
            Matcher m = p.matcher("a7b k@9z");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
        }
    }
</code></pre>

<pre><output>
    0...a
    2...b
    3... 
    4...k
    5...@
    7...z    
</output></pre>

<pre><code>
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("[\\w]");
            Matcher m = p.matcher("a7b k@9z");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
        }
    }
</code></pre>

<pre><output>
    0...a
    1...7
    2...b
    4...k
    6...9
    7...z    
</output></pre>

<pre><code>
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("\\W");
            Matcher m = p.matcher("a7b k@9z");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
        }
    }
</code></pre>

<pre><output>
    3... 
    5...@    
</output></pre>

<pre><code>
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile(".");
            Matcher m = p.matcher("a7b k@9z");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
        }
    }
</code></pre>

<pre><output>
    0...a
    1...7
    2...b
    3... 
    4...k
    5...@
    6...9
    7...z    
</output></pre>

<h6>Quantifiers</h6>
<p>We can use Quantifiers to specify number of occurences to match.</p>
<pre><code>
    a   = Exactly one 'a'
    a+  = Atleast one 'a'
    a*  = any number of a's including zero number 
    a?  = atmost one 'a'
</code></pre>

<pre><code>
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("a");
            Matcher m = p.matcher("abaabaaab");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
        }
    }    
</code></pre>

<pre><output>
    0...a
    2...a
    3...a
    5...a
    6...a
    7...a    
</output></pre>

<pre><code>
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("a+");
            Matcher m = p.matcher("abaabaaab");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
        }
    }    
</code></pre>

<pre><output>
    0...a
    2...aa
    5...aaa        
</output></pre>
<pre><code>
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("a*");
            Matcher m = p.matcher("abaabaaab");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
        }
    }    
</code></pre>

<pre><output>
    0...a
    1...
    2...aa
    4...
    5...aaa
    8...
    9...        
</output></pre>
<pre><code>
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("a?");
            Matcher m = p.matcher("abaabaaab");
            while (m.find()) {
                System.out.println(m.start() + "..." + m.group());
            }
        }
    }    
</code></pre>

<pre><output>
    0...a
    1...
    2...a
    3...a
    4...
    5...a
    6...a
    7...a
    8...
    9...      
</output></pre>

<p>Pattern class split() method</p>
<p>We can use Pattern class split() method to split the target string according to a particular pattern.
    </p>

<pre><code>
    import java.util.regex.Pattern;

    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("\\s");
            String[] s = p.split("Durga Software Solutions");
            for(String s1 : s) {
                System.out.println(s1);
            }
        }
    }    
</code></pre>

<pre><output>
    Durga
    Software
    Solutions    
</output></pre>


<pre><code>
    import java.util.regex.Pattern;

    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("a");
            String[] s = p.split("Durga Software Solutions");
            for(String s1 : s) {
                System.out.println(s1);
            }
        }
    }    
</code></pre>

<pre><output>
    Durg
    Softw
   re Solutions      
</output></pre>

<pre><code>
    import java.util.regex.Pattern;

    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("o");
            String[] s = p.split("Durga Software Solutions");
            for(String s1 : s) {
                System.out.println(s1);
            }
        }
    }    
</code></pre>

<pre><output>
    Durga S
    ftware S
    luti
    ns    
</output></pre>

<pre><code>
    import java.util.regex.Pattern;

    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile(".");
            String[] s = p.split("Durga Software Solutions");
            for(String s1 : s) {
                System.out.println(s1);
            }
        }
    }    
</code></pre>

<pre><output>
 No output
</output></pre>


<pre><code>
    import java.util.regex.Pattern;

    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("\\.");
            String[] s = p.split("www.durgajobs.com");
            for(String s1 : s) {
                System.out.println(s1);
            }
        }
    }      
</code></pre>

<pre><output>
    www
    durgajobs
    com     
</output></pre>

<pre><code>
    import java.util.regex.Pattern;

    public class RegExDemo {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("[.]");
            String[] s = p.split("www.durgajobs.com");
            for(String s1 : s) {
                System.out.println(s1);
            }
        }
    }      
</code></pre>

<pre><output>
    www
    durgajobs
    com     
</output></pre>

<p>String class also contains split() method to split the target String according to a particular pattern</p>

<pre><code>
    public class RegExDemo {

        public static void main(String[] args) {
            String s = "Durga Software Solutions";
            String[] s1 = s.split("\\s");
            for(String s2 : s1) {
                System.out.println(s2);
            }
        }
    }    
</code></pre>

<pre><output>
    Durga
    Software
    Solutions    
</output></pre>

<mark>Note : Pattern class split() method can take target String as argument whereas String class split() method
    can take Pattern as argument</mark>

    <br><br>
<h6>String Tokenizer</h6>
<p>It is a specially designed class for tokenization activity. String tokenizer present in java.util package</p>
<p>Example 1 : </p>
<pre><code>
    import java.util.StringTokenizer;

    public class StringTokenizerDemo {
    
        public static void main(String[] args) {
            StringTokenizer stringTokenizer = new StringTokenizer("Durga Software Solutions");
            while (stringTokenizer.hasMoreTokens()) {
                System.out.println(stringTokenizer.nextToken());
            }
        }
    }
</code></pre>

<pre><output>
    Durga
    Software
    Solutions    
</output></pre>

<mark> Note : The default Regular Expressions for StringTokenizer is space</mark>
<pre><code>
    import java.util.StringTokenizer;

    public class StringTokenizerDemo {
    
        public static void main(String[] args) {
            //"19-09-2014" is target String and "-" is Regular Expression
            //or Pattern or Delimitor
            StringTokenizer stringTokenizer = new StringTokenizer("19-09-2014", "-");
            while (stringTokenizer.hasMoreTokens()) {
                System.out.println(stringTokenizer.nextToken());
            }
        }
    }
</code></pre>

<pre><output>
    19
    09
    2014    
</output></pre>

<p>Write a regular Expression to represent all valid 10 digit mobile numbers</p>
<p>Rules : </p>
<p>1. Every number should contain exactly 10 digits</p>
<p>2. The first digit should be 7 or 8 or 9</p>

<pre><code>
    [789][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]
            or 
    [7-9][0-9]{9}
</code></pre>

<pre><code>
    10-digit or 11-digit 

    0?[7-9][0-9]{9}
</code></pre>

<pre><code>
    10-digit or 11-digit or 12-digit 
    (0|91)?[7-9][0-9]{9}
</code></pre>

<p>Write a regular Expression to represent all valid mail ids</p>
<pre><code>
    [a-zA-Z0-9][a-zA-Z0-9_.]*@[a-zA-Z0-9]+([.][a-zA-Z]+)+
</code></pre>

<p>Only gmail id's</p>
<pre><code>
    [a-zA-Z0-9][a-zA-Z0-9_.]*@gmail[.]com
</code></pre>

<p>Write a regular Expression to represent all Yava language identifiers</p>
<p>Rules : </p>
<p>Allowed characters are a to z, A to Z, 0 to 9, #, $</p>
<p>Length of each identifier should be atleast two</p>
<p>The first character should be lower case alphabet symbol from a to k</p>
<p>Second character should be a digit divisible by (0, 3, 6, 9)</p>

<pre><code>
    [a-k][0369][a-zA-Z0-9#$]*
</code></pre>

<h6>WAP to check whether the given number is a valid mobile number or not</h6>

<pre><code>
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    class CheckMobileNumber {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("(0|91)?[7-9][0-9]{9}");
            Matcher m = p.matcher(args[0]);
            if (m.find() && m.group().equals(args[0])) {
                System.out.println("Valid mobile number");
            } else {
                System.out.println("Invalid mobile number");
            }
        }
    }
</code></pre>

<pre><output>
    java CheckMobileNumber 7854125478
    Valid mobile number
    
    java CheckMobileNumber
    Invalid mobile number
</output></pre>

<h6>WAP to check whether the given mail id is valid or not</h6>
<p>In the above program we have to replace mobile number Regular Expression with 
    mail id regular Expression</p>
<pre><code>
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    class CheckMailId {
    
        public static void main(String[] args) {
            Pattern p = Pattern.compile("[a-zA-Z0-9][a-zA-Z0-9_.]*@[a-zA-Z0-9]+([.][a-zA-Z]+)+");
            Matcher m = p.matcher(args[0]);
            if (m.find() && m.group().equals(args[0])) {
                System.out.println("Valid mail id");
            } else {
                System.out.println("Invalid mail id");
            }
        }
    }
</code></pre>

<pre><output>
    java CheckMailId durga@gmail.com
    Valid mail id 
    
    java CheckMailId durga@ 
    Invalid mobile number
</output></pre>  

<h6>WAP to read all mobile numbers present in the given input file where mobile numbers 
    are mixed with normal text data.</h6>

<pre><code>
    import java.io.BufferedReader;
    import java.io.FileReader;
    import java.io.IOException;
    import java.io.PrintWriter;
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    class MobileExtractor {
    
        public static void main(String[] args) throws IOException {
            
            PrintWriter printWriter = new PrintWriter("output.txt");
            Pattern pattern = Pattern.compile("(0|91)?[7-9][0-9]{9}");
            BufferedReader bufferedReader = new BufferedReader(new FileReader("input.txt"));
            String line = bufferedReader.readLine();
             
            while(line != null) {
                Matcher matcher = pattern.matcher(line);
                while(matcher.find() && ) {
                    printWriter.println(matcher.group());
                }
                line = bufferedReader.readLine();
            }
            printWriter.flush();
        }
    }
</code></pre>
<pre><output>
    input.txt ------------------------------
    Hii there my mobile number is 7854125478
    9854128965 is someone elses 
    
    Ankita - 9878452145
    Saurav - 7854215478
    Armaan - 8854215478

    output.txt -------------------------------
    7854125478
    9854128965
    9878452145
    7854215478
    8854215478    
</output></pre>


<h6>WAP to extract all mail ids present in the given input file where mail ids are mixed with 
    normal text data</h6>

<p>In the above program we have to replace mobile number regular Expression with mail id regular Expression</p>

<pre><code>
    import java.io.BufferedReader;
    import java.io.FileReader;
    import java.io.IOException;
    import java.io.PrintWriter;
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    class MobileExtractor {
    
        public static void main(String[] args) throws IOException {
            
            PrintWriter printWriter = new PrintWriter("output.txt");
            Pattern pattern = Pattern.compile("[a-zA-Z0-9][a-zA-Z0-9_.]*@[a-zA-Z0-9]+([.][a-zA-Z]+)+");
            BufferedReader bufferedReader = new BufferedReader(new FileReader("input.txt"));
            String line = bufferedReader.readLine();
             
            while(line != null) {
                Matcher matcher = pattern.matcher(line);
                while(matcher.find() && ) {
                    printWriter.println(matcher.group());
                }
                line = bufferedReader.readLine();
            }
            <span style="color: red;">printWriter.flush();</span>
        }
    }
</code></pre>
<pre><output>
    input.txt ------------------------------
    Hii there my mobile number is 7854125478
    9854128965 is someone elses 
    
    Ankita - 9878452145
    Saurav - 7854215478
    Armaan - 8854215478
    
    Mail ids
    
    Ankita - ankita@gmail.com
    Saurav - saurav123@gmail.com
    Armaan - 124Armaan@gmail.com
    
    Invalid mail ids
    
    Sauron - Sauron@gmail.com
    Saruman - saru.man_123@gmail.com

    output.txt -------------------------------
    ankita@gmail.com
    saurav123@gmail.com
    124Armaan@gmail.com
    Sauron@gmail.com
    saru.man_123@gmail.com
     
</output></pre>

<h6>WAP to display all .mp4 file names present in F:\\New folder</h6>
<pre><code>
    import java.io.File;
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    public class FileNameExtractor {
    
        public static void main(String[] args) {
            int count = 0;
            Pattern pattern = Pattern.compile("[a-zA-Z0-9_$.].+[.]mp4");
            File file = new File("F:\\New Folder");
            String[] fileNames = file.list();
            for (String fileName : fileNames) {
                Matcher matcher = pattern.matcher(fileName);
                if (matcher.find() && matcher.group().equals(fileName)) {
                    count++;
                    System.out.println(fileName);
                }
            }
            System.out.println(count);
        }
    
    }
      
</code></pre>

<pre><output>
    Black.Panther.2018.1080p.BluRay.x264-[YTS.AM].mp4
    BRIGHT.mp4
    Expelled (2014) - HDRip_high_(coolmoviez.co).mp4
    Get Out.mp4
    MAZE RUNNER the scorch trial.mp4
    Mollys.Game.2017.1080p.WEB-DL.6CH.MkvCage.mkv.mp4
    mother.mp4
    SKY HIGH.mp4
    SUB.1.360p.mp4
    The Man from U.N.C.L.E (2015) 1080p BluRay [DayT.se].mp4
    The.Shape.Of.Water.2017.1080p.BluRay.x264-[YTS.AM].mp4
    The.Wolf.of.Wall.Street.2013.720p.BluRay.x264.YIFY.mp4
    Watch Bleeding Steel (2017) Full Movie - Openload Movies.mp4
    Watch Forever_#039;s End (2013) Full Movie - Openload Movies.mp4
    Watch Status Update (2018) Full Movie - Openload Movies.mp4
    Watch The Reunion (2011) Full Movie - Openload Movies.mp4
    16
    </output></pre>


    <h1>Collections</h1>
    <p>An array is an indexed collection of fixed number of homogeneous data elements. The main advantage
    of arrays is we can represent multiple values by using single variable so that readibility of the code will 
    be improved</p>
    <h6>Limitations of arrays</h6>
    <p>1. Arrays are fixed in size i.e once we creates an array there is no chance of increasing or decreasing the size 
        based on our requirement due to this, to use arrays concept compulsory we should know the size in advance which may 
        not possible always.</p>
    <p>2. Array can hold only homogeneous data type elements.</p>
    <h6>Example : </h6>
    <pre><code>
        Student[] s = new Student[10000];
        s[0] = new Student();           &#10004
        s[1] = new Customer();          &#10060

        CE : incompatible types 
            found : Customer 
            required : Student
    </code></pre>
            
    <p>We can solve this problem by using Object type arrays.</p>
    <pre><code>
        Object[] a = new Object[10000];
        a[0] = new Student();   &#10004
        a[1] = new Customer();  &#10004
    </code></pre>
    <p>3. Arrays concept is not implemented based on some standard data structure and hence 
        readymade method support is not available. For every requirement we have to write the code 
        explicitly which increases the complexity of programming.</p>
    <p>To overcome above problems of arrays we should go for collections concept.</p>
    <p>1. Collections are growable in nature i.e based on our requirement we can increase or decrease the size.</p> 
    <p>2. Collections can hold both homogeneous and heterogeneous objects.</p>
    <p>3. Every collection class is implemented based on some standard data structure hence for every requirement 
        readymade method support is available. Being a programmer we are responsible to use those methods. And 
        we are not responsible to implement those methods.</p>
    <h6>Differences between Arrays and Collections</h6>
    
<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>Arrays</th>
            <th>Collections</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>Arrays are fixed in size i.e once we creates an array we cant increase or decrease the size based on our requirement.</td>
            <td>Collections are growable in nature i.e based on our requirement we can increase or decrease the size</td>
        </tr>
        <tr>
            <td>With respect to memory arrays are not recommended to use.</td>
            <td>With respect to memory collections are recommended to use.</td>
        </tr>
        <tr>
            <td>With respect to performance arrays are recommended to use.</td>
            <td>With respect to performance collections are not recommended to use.</td>
        </tr>
        <tr>
            <td>Arrays can hold only homogeneous data type elements.</td>
            <td>Collections can hold both homogeneous and heterogeneous elements.</td>
        </tr>
        <tr>
            <td>There is no underlying data structure for arrays and hence readymade method support is not available.
            For every requirement we have to write the code explicitly which increases complexity of programming.</td>
            <td>Every collection class is implemented based on some standard data structure and hence for every requirement readymade method support is available.
            Being a programmer we can use these methods directly and we are not responsible to implement those methods.</td>
        </tr>

        <tr>
            <td>Arrays can hold both primitives and objects.</td>
            <td>Collections can hold only object types but not primitives.</td>
        </tr>
    </tbody>
</table>

<h6>Collection</h6>
<p>If we want to represent a group of individual objects as a single entity then we should go for collection.</p>

<h6>Collection framework</h6>
<p>It contains several classes and interfaces which can be used to represent a group of individual objects as a single entity.</p>


<h6>Equivalent terminology in Java and C++</h6>
<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>Java</th>
            <th>C++</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>Collection</td>
            <td>Container</td>
        </tr>
        <tr>
            <td>Collection framework</td>
            <td>STL(Standard Template Library)</td>
        </tr>   
    </tbody>
</table>

<h3>9 key interfaces of Collection framework</h3>
<pre><code>
    1. Collection
    2. List 
    3. Set 
    4. SortedSet 
    5. NavigableSet 
    6. Queue 
    7. Map 
    8. SortedMap 
    9. NaviableMap
</code></pre>
<h5>1. Collection(I)</h5>
<p>1. If we want to represent a group of individual objects as a single entity then we should go for collection.</p>
<p>2. Collection(I) defines the most common methods which are applicable for any Collection object. </p>
<p>3. In general Collection interface is considered as root interfaces of Collection framework</p>

<p>There is no concrete class which implements collection interface directly.</p>

<h6>Difference between Collection and Collections</h6>

<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>Collection</th>
            <th>Collections</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>Collection is an interface. If we want to represent a group of individual objects as a single entity then we should 
                go for Collection.
            </td>
            <td>Collections is an utility class present in java.util package to define several utility methods for Collection objects like 
                sorting, searching etc.
            </td>
        </tr>  
    </tbody>
</table>

<h5>2. List(I)</h5>
<p>It is the child interface of Collection</p>
<p>If we want to represent a group of individual objects as a single entity where duplicates are allowed and insertion order must be preserved then 
    we should go for List.</p>
    <img src="images/ss140.png" alt="ss12" width="700" height="600">
<br><br>
<mark>Note : In 1.2v vector and stack classes are re-engineered to implement List interface.</mark>
<br><br>

<h5>3. Set(I)</h5>
<p>It is the child interface of Collection</p>
<p>If we want to represent a group of individual objects as a single entity where duplicates are not allowed and insertion order not required then 
    we should go for Set interface.</p>

    <img src="images/ss141.png" alt="ss12" width="400" height="500">

<h5>4. SortedSet(I)</h5>
<p>It is the child interface of Set(I)</p>
<p>If we want to represent a group of individual objects as a single entity where duplicates are not allowed and all objects should be 
    inserted according to some sorting order then we should go for SortedSet.</p>

<h5>5. NavigableSet(I)</h5>
<p>It is the child interface of SortedSet</p>
<p>It contains several methods for navigation purposes</p>
<img src="images/ss142.png" alt="ss12" width="500" height="500">

<h6>Differences between List and Set</h6>

<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>List</th>
            <th>Set</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>Duplicates are allowed.</td>
            <td>Duplicates are not allowed.</td>
        </tr>  
        <tr>
            <td>Insertion order preserved.</td>
            <td>Insertion order not preserved.</td>
        </tr>  
    </tbody>
</table>
<h5>6. Queue(I)</h5>
<p>It is the child interface of Collection</p>
<p>If we want to represent a group of individual objects prior to processing then we should go for Queue</p>
<p>Usually Queue follows FIFO order but based on our requirement we can implement our own priority order also.</p>

<p>Example :</p>
<p>Before sending a mail all mail ids we have to store in some data structure. In which order we added mail ids 
    in the same order only mail should be delivered, for this requirement Queue is best choice</p>

    <img src="images/ss143.png" alt="ss12" width="500" height="600">
<br><br>
<mark>Note : All the above interfaces Collection, List, Set, SortedSet, NavigableSet and Queue meant for representing 
    a group of individual objects. If we want to represent a group of object as key value pairs then we should 
    go for Map.</mark>
<br><br>


<h5>7. Map(I)</h5>
<p>1. Map is <span style="color: red;">not</span> child interface of collection</p>
<p>2. If we want to represent a group of objects as key value pairs then we should go for Map</p>
<img src="images/ss144.png" alt="ss12" width="300" height="300">

<p>Both key and value are objects only. Duplicate keys are not allowed but values can be duplicated.</p>
<img src="images/ss145.png" alt="ss12" width="700" height="600">

<h5>8. SortedMap(I)</h5>
<p>It is the child interface of Map(I)</p>
<p>If we want to represent a group of key value pairs according to some <span style="color: red;">sorting order of keys</span> then we should go for SortedMap</p>
<p>In SortedMap the sorting should be based on key but not based on value.</p>

<h5>9. NavigableMap(I)</h5>
<p>It is the child interface of SortedMap</p>
<p>It defines several methods for navigation purposes.</p>

<img src="images/ss146.png" alt="ss12" width="400" height="400">
<br><br>
<mark>Note : The following are legacy characters present in Collection framework</mark>
<br><br>
<h5>Legacy characters</h5>
<pre><code>
    Enumeration(I) 
    Dictionary(AC)
    vector(C)
    Stack(C) 
    Hashtable(C)
    Properties(C)
</code></pre>

<img src="images/ss147.png" alt="ss12" width="900" height="500">
<img src="images/ss148.png" alt="ss12" width="800" height="500">

<h5>Sorting</h5>
<pre><code>
    1. Comparable(I)
    2. Comparator(I)
</code></pre>

<h5>Cursors</h5>
<pre><code>
    1. Enumeration(I)
    2. Iterator(I)
    3. ListIterator(I)
</code></pre>

<h5>Utility classes</h5>
<pre><code>
    1. Collections
    2. Arrays
</code></pre>


<h3>Collection(I)</h3>
<p>If we want to represent a group of individual objects as a single entity then we should go for 
    Collection</p>
<p>Collection interfaces defines the most common methods which are applicable for any Collection object</p>

<pre><code>
    1. boolean add(Object o)
    2. boolean addAll(Collection c)
    3. boolean remove(Object o)
    4. boolean removeAll(Collection c)
    5. boolean retainAll(Collection c)
    - To remove all objects except those present in c 
    6. void clear() 
    7. boolean contains(Object o)
    8. boolean containsAll(Collection c)
    9. boolean isEmpty()
    10. int size();
    11. Object[] toArray();
    12. Iterator iterator()
</code></pre>

<mark>Note : There is no concrete class which implements Collection interface directly.</mark>
<br><br>
<h3>List(I)</h3>
<p>It is the child interface of Collection</p>

<p>If we want to represent a group of individual objects as a single entity where duplicates are allowed and insertion
     order must be preserved then we should go for List.</p>

<p>We can preserve insertion order via index and we can differentiate duplicate objects by using index. 
    Hence index will play very important role in List.</p>
<p>List interface defines the following specific methods</p>
<pre><code>
    1. void add(int index, Object o)
    2. boolean addAll(int index, Collection c)
    3. Object get(int index)
    4. Object remove(int index)

    5. Object set(int index, Object new)
    - to replace the element present at specified index with provided 
    Object and returns old object.

    6. int indexOf(Object o)
    - returns index of first occurence of 'o'

    7. int lastIndexOf(Object o)
    8. ListIterator listIterator();
</code></pre>
<img src="images/ss140.png" alt="ss12" width="600" height="500">

<h5>ArrayList</h5>
<p>1. The underlying data structure is resizable array or growable array</p>
<p>2. Duplicate objects are allowed</p>
<p>3. Insertion order is preserved</p>
<p>4. Heterogeneous objects are allowes(except treeSet and treeMap everywhere heterogeneous objects are allowed)</p>
<p>5. null insertion is possible</p>

<h6>Constructors</h6>
<pre><code>
    1. ArrayList l = new ArrayList();
    - creates an empty ArrayList object with default initial capacity 10. 
    Once ArrayList reaches its max capacity then a new ArrayList object will be 
    created with 
    <span class="bg-primary text-white">New capacity = (current capacity * (3 / 2)) + 1</span>
</code></pre>

<pre><code>
    2. ArrayList l = new ArrayList(int initialcapacity);
    - creates an empty ArrayList object with specified initialcapacity
</code></pre>

<pre><code>
    3. ArrayList l = new ArrayList(Collection c)
    - creates an equivalent ArrayList object for the given Collection
</code></pre>

<pre><code>
    import java.util.ArrayList;

    public class ArrayListDemo {
    
        public static void main(String[] args) {
            ArrayList l = new ArrayList();
            l.add("A");
            l.add(10);
            l.add("A");
            l.add(null);
            System.out.println(l);
            l.remove(2);
            System.out.println(l);
            l.add(2, "M");
            l.add("N");
            System.out.println(l);
        }
    }
</code></pre>

<pre><output>
    [A, 10, A, null]
    [A, 10, null]
    [A, 10, M, null, N]
</output></pre>

<p>Usually we can use Collections to hold and transfer objects from one location to another location(container) 
    . To provide support for this requirement every Collection class by default implements Serializable and Cloneable 
    interfaces.</p>

<p>ArrayList and Vector classes implements random access interface so that any random element we can access with the same 
    speed.</p>
<h6>RandomAccess</h6>
<p>RandomAccess interface present in java.util package and it doesnt contain any methods. It is a marker interface where 
    required ability will be provided automatically by the JVM.</p>

<pre><code>
    ArrayList l1 = new ArrayList();
    LinkedList l2 = new LinkedList();
    System.out.println(l1 instanceof Serializable);
    System.out.println(l2 instanceof Cloneable);
    System.out.println(l1 instanceof RandomAccess);
    System.out.println(l2 instanceof RandomAccess);
</code></pre>

<pre><output>
    true 
    true 
    true 
    false
</output></pre>

<p>ArrayList is the best choice if our frequent operation is retrieval operation 
    (because ArrayList implements RandomAccess interface)</p>
<p>ArrayList is the worst choice if our frequent operation is insertion or deletion 
    in the middle.</p>

<h6>Differences between ArrayList and Vector</h6>
<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>ArrayList</th>
            <th>Vector</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>Every method present in the ArrayList is non synchronized</td>
            <td>Every method present in the Vector is synchronized</td>
        </tr>  
        <tr>
            <td>At a time multiple threads are allowed to operate on ArrayList object and 
                hence it is not thread safe. 
            </td>
            <td>At a time only one thread is allowed to operate on vector object and hence 
                it is thread safe
            </td>
        </tr>
        <tr>
            <td>Relatively performance is high because threads are not required to wait to operate 
                on ArrayList object
            </td>
            <td>Relatively performance is low because threads are required to wait to operate 
                on vector object
            </td>
        </tr>
        <tr>
            <td>Introduced in 1.2v and it is non legacy</td>
            <td>Introduced in 1.0v and it is legacy</td>
        </tr>
    </tbody>
</table>

<div class="container">
    <p class="bg-warning text-white">How to get synchronized version of ArrayList object?</p>
    <p>By default ArrayList is non synchronized but we can get synchronized version of ArrayList object 
        by using synchronizedList() method of Collections class.</p>
        <pre><code>
            public static List synchronizedList(List l)
        </code></pre> 
        <p>Example : </p>
        <pre><code>
            ArrayList l = new ArrayList();
            List l1 = Collections.synchronizedList(l);
        </code></pre>
        <img src="images/ss149.png" alt="ss12" width="600" height="200">
</div>

<p>Similarily we can get synchronized version of Set and Map objects by using the following methods of 
    Collections class</p>
    <pre><code>
        public static Set synchronizedSet(Set s)
        public static Map synchronizedMap(Map m)
    </code></pre>


<h5>LinkedList</h5>
<p>1. The underlying data structure is double linked list.</p>
<p>2. Insertion order is preserved</p>
<p>3. Duplicate objects are allowed.</p>
<p>4. Heterogeneous objects are allowed</p>
<p>5. null insertion is possible</p>
<p>6. LinkedList implements Serializable and Cloneable interfaces but not RandomAccess</p>
<p>7. LinkedList is the best choice if our frequent operation is insertion or deletion in the middle</p>
<p>8. LinkedList is the worst choice if our frequent operation is retrieval operation</p>

<h6>Constructors</h6>
<pre><code>
    1. LinkedList l = new LinkedList();
    - creates an empty LinkedList object
</code></pre>
<pre><code>
    2. LinkedList l = new LinkedList(Collection c);
    - creates an equivalent LinkedList object for the given Collection
</code></pre>

<h6>LinkedList class specific methods-</h6>
<p>Usually we can use LinkedList to develop stacks and queues. To provide support 
    for this requirement LinkedList class defines the following specific methods</p>
    <pre><code>
        1. void addFirst(Object o)
        2. void addLast(Object o)
        3. Object getFirst()
        4. Object getLast()
        5. Object removeFirst()
        6. Object removeLast()
    </code></pre> 

<pre><code>
    import java.util.LinkedList;

    public class LinkedListDemo {
    
        public static void main(String[] args) {
            LinkedList l = new LinkedList();
            l.add("durga");
            l.add(30);
            l.add(null);
            l.add("durga");
            System.out.println(l);
            
            l.set(0, "Software");
            System.out.println(l);
            
            l.add(0, "venky");
            System.out.println(l);
            
            l.removeLast();
            System.out.println(l);
    
            l.addFirst("CCC");
            System.out.println(l);
        }
    
    }
</code></pre>

<pre><output>
    [durga, 30, null, durga]
    [Software, 30, null, durga]
    [venky, Software, 30, null, durga]
    [venky, Software, 30, null]
    [CCC, venky, Software, 30, null]    
</output></pre>

<h6>Differences between ArrayList and LinkedList</h6>
<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>ArrayList</th>
            <th>LinkedList</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>ArrayList is the best choice if our frequent operation is retrieval operation</td>
            <td>LinkedList is the best choice if our frequent operation is insertion or deletion in the middle</td>
        </tr> 
        <tr>
            <td>ArrayList is the worst choice if our frequent operation is insertion or deletion in the middle 
                because internally several shift operations are performed
            </td>
            <td>LinkedList is the worst choice if our frequent operation is retrieval operation</td>
        </tr>
        <tr>
            <td>In ArrayList elements will be stored in consecutive memory locations and hence retrieval operation will become easy</td>
            <td>In LinkedList the elements wont be stored in consecutive memory locations and hence retrieval operation will become 
                difficult or complex.
            </td>
        </tr>   
    </tbody>
</table>

<h5>Vector</h5>
<p>1. The underlying data structure is resizable array or growable array.</p>
<p>2. Insertion order is preserved</p>
<p>3. Duplicate objects are allowed.</p>
<p>4. Heterogeneous objects are allowed</p>
<p>5. null insertion is possible</p>
<p>6. It implements Serializable, Cloneable and RandomAccess interfaces</p>
<p>7. Every method present in a Vector is synchronized and hence Vector object is thread safe</p>

<h6>Constructors</h6>
<pre><code>
    1. Vector v = new Vector()
    - creates an empty Vector object with default initial capacity 10
    Once Vector reaches its max capacity then a new Vector object will be created with 
    <span class="bg-primary text-white">New Capacity = currentcapacity * 2</span>

    2. Vector v = new Vector(int initialcapacity);
    - creates an empty Vector object with specified initialcapacity

    3. Vector v = new Vector(int initialcapacity, int incrementalcapacity);
    
    4. Vector v = new Vector(Collection c);
    - creates an equivalent Vector object forthe given Collection
    This Constructor meant for interconversion betweem Collection objects
</code></pre>

<h6>Vector specified methods</h6>
<p style="color: brown;"> To add objects</p>
<pre><code>
    1. add(Object o)    --------Collection method 

    2. add(int index, Object o) -------List interface method
    
    3. addElement(Object o) -------Vector specific method
</code></pre>

<p style="color: brown;"> To remove objects</p>
<pre><code>
    1. remove(Object o)             ---------Collection specific
    2. removeElement(Object o)      ---------Vector specific
    3. remove(int index)            ---------LinkedList specific
    4. removeElementAt(int index)   ---------Vector specific
    5. clear()                      ---------Collection specific 
    6. removeAllElements()          ---------Vector specific
</code></pre>

<p style="color: brown;"> To get objects</p>
<pre><code>
    1. Object get(int index)        ---------LinkedList specific 
    2. Object elementAt(int index)  ---------Vector specific
    3. Object firstElement()        ---------Vector specific
    4. Object lastElement()         ---------Vector specific
</code></pre>

<p style="color: brown;">Other methods</p>
 <pre><code>
     1. int size()
     2. int capacity()
     3. Enumeration elements()
</code></pre>

<pre><code>
    import java.util.Vector;

    public class ArrayListDemo {
    
        public static void main(String[] args) {
            Vector v = new Vector();
            System.out.println("Initial capacity : " + v.capacity());
            for (int i = 1; i <= 10; i++) {
                v.addElement(i);
            }
            System.out.println(v.capacity());
            v.addElement("A");
            System.out.println(v.capacity());
            System.out.println(v);
        }
    }  
</code></pre>
<pre><output>
    Initial capacity : 10
    10
    20
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, A]    
</output></pre>


<pre><code>
    import java.util.Vector;

    public class VectorDemo {
    
        public static void main(String[] args) {
            Vector v = new Vector(10, 5);
            System.out.println("Initial capacity : " + v.capacity());
            for (int i = 1; i <= 10; i++) {
                v.addElement(i);
            }
            System.out.println(v.capacity());
            v.addElement("A");
            System.out.println(v.capacity());
            System.out.println(v);
        }
    }    
</code></pre>

<pre><output>
    Initial capacity : 10
    10
    15
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, A]    
</output></pre>

<h5>Stack</h5>
<p>It is the child class of Vector</p>
<p>It is a speciallly designed class for LIFO order</p>

<h6>Constructor</h6>
<pre><code>
    Stack s = new Stack();
</code></pre>

<h6>Methods</h6>
<pre><code>
    1. Object push(Object o)
    - to insert an object into the stack 

    2. Object pop() 
    - to remove and return top of the stack
     
    3. Object peek() 
    - to return top of the stack without removal 

    4. boolean empty() 
    - returns true if the stack is empty 

    5. int search(Object o)
    returns offset if the element is available Otherwise return -1
</code></pre>
<pre><code>
    import java.util.Stack;

    public class StackDemo {
    
        public static void main(String[] args) {
            Stack s = new Stack();
            s.push("A");
            s.push("B");
            s.push("C");
            System.out.println(s);
            System.out.println(s.search("A"));
            System.out.println(s.search("Z"));
        }
    }    
</code></pre>

<pre><output>
    [A, B, C]
    3
    -1    
</output></pre>

<img src="images/ss150.png" alt="ss12" width="400" height="300">

<h3>The three Cursors of java</h3>
<p>If we want to get objects one by one from the collection then we should go for Cursor</p>
<p>There are three types of Cursors available in java</p>
<pre><code>
    1. Enumeration
    2. Iterator
    3. ListIterator
</code></pre>

<h5>Enumeration</h5>
<p>We can use Enumeration to get objects one by one from legacy Collection object</p>
<p>We can create Enumeration object by using elements method of Vector class</p>

<pre><code>
    public Enumeration elements();

    eg : 
    Enumeration e = v.elements();
</code></pre>

<h6>Methods</h6>
<pre><code>
    1. public boolean hasMoreElements();
    2. public Object nextElement();
</code></pre>
<pre><code>
    import java.util.Enumeration;
    import java.util.Vector;
    
    public class EnumerationDemo {
    
        public static void main(String[] args) {
            Vector v = new Vector();
            for (int i = 0; i <= 10; i++) {
                v.addElement(i);
            }
            System.out.println(v);
            Enumeration e = v.elements();
            while(e.hasMoreElements()) {
                Integer I = (Integer)e.nextElement();
                if(I % 2 == 0) {
                    System.out.println(I);
                }
            }
            System.out.println(v);
        }
    }    
</code></pre>

<pre><output>
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    0
    2
    4
    6
    8
    10
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]    
</output></pre>

<h6>Limitations of Enumeration</h6>
<p>We can apply Enumeration concept only for legacy classes and it is not a universal cursor</p>
<p>By using Enumeration we can get only read access and we cant perform remove operation</p>
<p>To overcome above Limitations we should go for Iterator</p>

<h6>Iterator(I)</h6>
<p>We can apply Iterator concept for any Collection object and hence it is universal cursor. By using Iterator 
    we can perform both read and remove operations.</p>
<p>We can create Iterator object by using Iterator method of Collection interface</p>
<pre><code>
    public Iterator iterator()
</code></pre>
<p>Example : </p>
<pre><code>
    Iterator itr = c.iterator();    //c is any Collection object
</code></pre>

<h6>Methods</h6>
<pre><code>
    1. public boolean hasNext()
    2. public Object next()
    3. public void remove()
</code></pre>

<pre><code>
    import java.util.ArrayList;
    import java.util.Iterator;
    
    public class IteratorDemo {
    
        public static void main(String[] args) {
            ArrayList l = new ArrayList();
            for (int i = 0; i <= 10; i++) {
                l.add(i);
            }
            System.out.println(l);
            
            Iterator iterator = l.iterator();
            while(iterator.hasNext()) {
                Integer I = (Integer)iterator.next();
                if(I % 2 == 0) {
                    System.out.println(I);
                } else {
                    iterator.remove();
                }
            }
            System.out.println(l);
        }
    }
</code></pre>

<pre><output>
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    0
    2
    4
    6
    8
    10
    [0, 2, 4, 6, 8, 10]    
</output></pre>

<h6>Limitations of Iterator</h6>
<p>1. By using Enumeration and Iterator we can always move only towards forward direction 
    and we can not move towards backward direction. These are single direction cursors but not 
    bidirectional cursor
</p>
<p>2. By using Iterator we can perform only read and remove operations and we can not perform 
    replacement and addition of new objects</p>
<p>To overcome above Limitations we should go for ListIterator</p>

<h5>ListIterator(I)</h5>
<p>1. By using List Iterator we can move either to the forward direction or to the backward direction and 
    hence it is bidirectional cursor</p>
<p>2. By using ListIterator we can perform replacement and addition of new objects in addition to 
    read and remove operations.</p>

<p>We can create ListIterator by using ListIterator method of List interface</p>
<pre><code>
    public ListIterator listIterator()

    eg : 

    ListIterator listIterator = l.listIterator();   //l is any List object
</code></pre>

<h6>Methods</h6>
<p>ListIterator is the child interface of Iterator and hence all methods present in Iterator by default available 
    to the ListIterator</p>
    <img src="images/ss151.png" alt="ss12" width="200" height="300">

<p>ListIterator defines the following nine methods</p>
<p style="color: brown;">Forward movement</p>
<pre><code>
    1. public boolean hasNext()
    2. public Object next() 
    3. public int nextIndex()
</code></pre>
<p style="color: brown;">Backward movement</p>
<pre><code>
    1. public boolean hasPrevious()
    2. public Object previous()
    3. public int previousIndex()
</code></pre>
<p style="color: brown;">Extra operations</p>
<pre><code>
    1. public void remove() 
    2. public void add(Object o)
    3. public void set(Object o)
</code></pre>

<pre><code>
    import java.util.LinkedList;
    import java.util.ListIterator;
    
    public class ListIteratorDemo {
    
        public static void main(String[] args) {
            LinkedList l = new LinkedList();
            l.add("balakrishna");
            l.add("venki");
            l.add("chiru");
            l.add("nag");
    
            System.out.println(l);
    
            ListIterator listIterator = l.listIterator();
            while (listIterator.hasNext()) {
                String s = (String) listIterator.next();
    
                if (s.equals("venki")) {
                    listIterator.remove();  //[balakrishna, chiru, nag]
                } else if (s.equals("nag")) {   
                    listIterator.add("chaitu"); //[balakrishna, chiru, nag, chaitu]
                } else if (s.equals("chiru")) {
                    listIterator.set("charan"); ////[balakrishna, charan, nag, chaitu]
                }
            }
            System.out.println(l);  //[balakrishna, charan, nag, chaitu]
        }
    }
</code></pre>

<pre><output>
    [balakrishna, venki, chiru, nag]
    [balakrishna, charan, nag, chaitu]    
</output></pre>

<mark>Note : The most powerful cursor is ListIterator but its Limitation is it is applicable 
    only for List objects
</mark><br><br>

<h6>Comparison table of three Cursors</h6>
<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>Property</th>
            <th>Enumeration</th>
            <th>Iterator</th>
            <th>ListIterator</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>Where we can apply?</td>
            <td>Only for legacy classes</td>
            <td>For any Collection object</td>
            <td>Only for List objects</td>
        </tr>  
        <tr>
            <td>Is it legacy?</td>
            <td>Yes(1.0v)</td>
            <td>No(1.2v)</td>
            <td>No(1.2v)</td>
        </tr>  
        <tr>
            <td>Movement</td>
            <td>Single direction(Only forward direction)</td>
            <td>Single direction(Only forward direction)</td>
            <td>Bidirectional</td>
        </tr>  
        <tr>
            <td>Allowed operations</td>
            <td>Only read</td>
            <td>Read and remove</td>
            <td>Read, Remove, Replace and Add</td>
        </tr> 
        <tr>
            <td>How we can get?</td>
            <td>By using elements() method of vector class</td>
            <td>By using iterator() method of Collection(I)</td>
            <td>By using listIterator() method of List(I)</td>
        </tr> 
        <tr>
            <td>Methods</td>
            <td>2 methods(hasMoreElements() and nextElement())</td>
            <td>3 methods(hasNext(), next() and remove())</td>
            <td>9 methods</td>
        </tr>    
    </tbody>
</table>

<h6>Internal implementation of cursors</h6>

<pre><code>
    import java.util.Enumeration;
    import java.util.Iterator;
    import java.util.ListIterator;
    import java.util.Vector;
    
    public class CursorsDemo {
    
        public static void main(String[] args) {
            Vector v = new Vector();
            Enumeration enumeration = v.elements();
            Iterator iterator = v.iterator();
            ListIterator listIterator = v.listIterator();
    
            System.out.println(enumeration.getClass().getName());
            System.out.println(iterator.getClass().getName());
            System.out.println(listIterator.getClass().getName());
        }
    }
</code></pre>

<pre><output>
    java.util.Vector$1
    java.util.Vector$Itr
    java.util.Vector$ListItr    
</output></pre>


<h3>Set(I)</h3>
<p>1. Set is child interface of Collection </p>
<p>2. If we want to represent a group of individual objects as a single entity where duplicates are 
    not allowed and insertion order not preserved</p>
<p>Set interface doesnt contain any new method and we have to use only Collection interface methods</p>

<img src="images/ss152.png" alt="ss12" width="600" height="600">

<h5>HashSet</h5>
<p>1. The underlying data structure is Hashtable</p>
<p>2. Duplicate objects are not allowed</p>
<p>3. Insertion order is not preserved and it is based on hashCode of objects</p>
<p>4. null insertion is possible(only once)</p>
<p>5. Heterogeneous objects are allowed</p>
<p>6. Implements Serializable and Cloneable but not RandomAccess interface</p>
<p>7. HashSet is the best choice if our frequent operation is search operation</p>

<mark>&#10040&#10040&#10040Note : In HashSet duplicates are not allowed, if we are trying to insert duplicates then we wont get any 
    compile time or run time error and add method simply returns false</mark><br><br>

    <pre><code>
        Example 

        HashSet h = new HashSet();
        System.out.println(h.add("A"));
        System.out.println(h.add("A"));
    </code></pre>
    
    <pre><output>
        true 
        false
    </output></pre>    

<h6>Constructors</h6>
<pre><code>
    1. HashSet h = new HashSet();
    - creates an empty HashSet object with default initialcapacity 16 and 
    default fill ratio 0.75

    2. HashSet h = new HashSet(int initialcapacity);
    - creates an empty HashSet object with specified initialcapacity and default fill ratio 0.75

    3. HashSet h = new HashSet(int initialcapacity, float fillRatio);
    
    4. HashSet h = new HashSet(Collection c);
    - creates an equivalent HashSet for the given Collection
    This Constructor meant for interconversion between Collection objects
</code></pre>

<h6>Fill ratio or Load Factor</h6>
<p>After filling how much ratio a new HashSet object will be created, this ratio is called fill ratio or 
    load factor. For Example Fill ratio 0.75 means after filling 75% ratio a new HashSet object will be created</p>
<pre><code>
    import java.util.HashSet;

    public class HashSetDemo {
    
        public static void main(String[] args) {
            HashSet h = new HashSet();
            h.add("B");
            h.add("C");
            h.add("D");
            h.add("Z");
            h.add(null);
            h.add(10);
            System.out.println(h.add("Z"));
            System.out.println(h);
        }
    
    }
</code></pre>

<pre><output>
    false
    [null, B, C, D, Z, 10]
</output></pre>

<h5>LinkedHashSet</h5>
<p>It is the child class of HashSet</p>
<p>It is exactly same as HashSet(including Constructors and methods) except the following Differences</p>
<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>HashSet</th>
            <th>LinkedHashSet</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>The underlying data structure is Hashtable</td>
            <td>The underlying data structure is a combination of LinkedList and Hashtable</td>
        </tr> 
        <tr>
            <td>Insertion order not preserved/td>
            <td>Insertion order preserved</td>
        </tr> 
        <tr>
            <td>Introduced in 1.2v</td>
            <td>Introduced in 1.4v</td>
        </tr>  
    </tbody>
</table>
<p>In the above program if we replace HashSet with LinkedHashSet then the output is </p>
<pre><code>
    import java.util.LinkedHashSet;

    public class HashSetDemo {
    
        public static void main(String[] args) {
            LinkedHashSet h = new LinkedHashSet();
            h.add("B");
            h.add("C");
            h.add("D");
            h.add("Z");
            h.add(null);
            h.add(10);
            System.out.println(h.add("Z"));
            System.out.println(h);
        }
    
    }
</code></pre>

<pre><output>
    false
    [B, C, D, Z, null, 10]    
</output></pre>

<mark>Note : In general we can use LinkedHashSet to develop cache based applications 
    where duplicates are not allowed and insertion order preserved</mark>
    <br><br>

<h5>SortedSet</h5>
<p>SortedSet is the child interface of Set</p>
<p>If we want to represent a group of individual objects according to some sorting order 
    without duplicates then we should go for SortedSet/p> 
<p>SortedSet interface defines the following specific methods</p>
<h6>Methods</h6>
<pre><code>
    1. Object first();
    - returns first element of the SortedSet

    2. Object last();
    - returns last element of the SortedSet

    3. SortedSet headSet(Object obj)
    - returns SortedSet whose elements are less than obj 

    4. SortedSet tailSet(Object obj)
    - returns SortedSet whose elements are >= obj 

    5. SortedSet subSet(Object obj1, Object obj2)
    - returns SortedSet whose elements are >= obj1 and < obj2

    6. Comparator comparator()
    - returns Comparator object that describes underlying sorting technique. If we are using 
    default natural sorting order then we will get null.
</code></pre>


<mark>Note : The default natural sorting order for numbers is ascending order and for String objects
    alphabetical order.
</mark>
<br><br>

<p>Example : </p>

<pre><code>
    Set = [100, 101, 104, 106, 110, 115, 120]

first()
last()
headSet(106)
tailSet(106)
subSet(101, 115)
comparator()
</code></pre>

<pre><output>
    100
    120
    [100, 101, 104]
    [106, 110, 115, 120]
    [101, 104, 106, 110]
    null
</output></pre>

<h5>TreeSet</h5>
<p>1. The underlying data structure is Balanced Tree</p>
<p>2. Duplicate objects are not allowed</p>
<p>3. Insertion order not preserved</p>
<p>4. Heterogeneous objects are not allowed o/w we will get RE saying ClassCastException</p>
<p>5. null insertion is possible(only once)</p>
<p>6. TreeSet implements Serializable and Cloneable but not RandomAccess</p>
<p>7. All objects will be inserted based on some sorting order. It may be default 
    natural sorting order or customized sorting order</p>
<h6>Constructors</h6>
<pre><code>
    1. TreeSet t = new TreeSet();
    - creates an empty TreeSet object where the elements will be inserted according to default 
    natural sorting order

    2. TreeSet t = new TreeSet(Comparator c)
    - creates an empty TreeSet object where the elements will be inserted according to customized 
    sorting order specified by Comparator object 

    3. TreeSet t = new TreeSet(Collection c)

    4. TreeSet t = new TreeSet(SortedSet s)
</code></pre>

<pre><code>
    import java.util.TreeSet;

    public class TreeSetDemo {
    
        public static void main(String[] args) {
            TreeSet t = new TreeSet();
            t.add("A");
            t.add("a");
            t.add("B");
            t.add("Z");
            t.add("L");
    
            //t.add(new Integer(10));	//ClassCastException
            //t.add(null);		//NullPointerException
            System.out.println(t);
        }
    
    }
</code></pre>

<pre><output>
    [A, B, L, Z, a]
</output></pre>

<h6>null acceptance</h6>
<p>1. For non empty TreeSet if we are trying to insert null then we will get NullPointerException</p>
<p>2. For empty TreeSet as a first element null is allowed but after inserting that null if we are trying 
    to insert any other then we will get RE saying NullPointerException</p>
<mark>&#10040&#10040&#10040Note : Until 1.6v null is allowed as a first element to the empty TreeSet 
    but from 1.7v onwards null is not allowed even as a first element i.e 'null' such type of story 
    not applicable for TreeSet from 1.7v onwards</mark><br><br>

<pre><code>
    import java.util.TreeSet;

    public class TreeSetDemo {
    
        public static void main(String[] args) {
            TreeSet t = new TreeSet();
            t.add(new StringBuffer("A"));
            t.add(new StringBuffer("Z"));
            t.add(new StringBuffer("L"));
            t.add(new StringBuffer("B"));
    
            System.out.println(t);
        }
    }    
</code></pre>

<pre><output>
    RE : ClassCastException
</output></pre>

    <p>If we are depending on default natural sorting order, compulsory the objects should be homogeneous and 
    Comparable o/w we will get RE saying ClassCastException</p>
<p>An object is said to be Comparable iff corresponding class implements Comparable interface</p>
<p>String class and all Wrapper classes already implements Comparable interface but StringBuffer class doesnt 
    implement Comparable interface hence we got ClassCastException in the above Example</p> 

<h5>Comparable(I)</h5>
<p>It is present in java.lang package and it contains only one method compareTo()</p>
<pre><code>
    public int compareTo(Object obj)
</code></pre>

<p>Example : </p>
<pre><code>
    obj1.compareTo(obj2)

    - returns (-ve) iff obj1 has to come before obj2
    
    - returns (+ve) iff obj1 has to come after obj2 

    - returns 0 iff obj1 & obj2 are equal
</code></pre>

<pre><code>
    public class CompareToDemo {

        public static void main(String[] args) {
            System.out.println("A".compareTo("Z"));
            System.out.println("Z".compareTo("K"));
            System.out.println("A".compareTo("A"));
            System.out.println("A".compareTo(null));
    
        }
    
    }    
</code></pre>

<pre><output>
    -25
    15
    0
    Exception in thread "main" java.lang.NullPointerException   
</output></pre>
<p>If we are depending on default natural sorting order then while adding objects 
    into the TreeSet JVM will call compareTo method</p>

<pre><code>
    TreeSet t = new TreeSet();
    t.add("K");     
    t.add("Z");     //"Z".compareTo("K") - (+ve)
    t.add("A");     //"A".compareTo("K") - (-ve)
    t.add("A");     //"A".compareTo("K") - (-ve)
                      "A".compareTo("A") - (0)
    System.out.println(t);
</code></pre>

<pre><output>
    [A, K, Z]
</output></pre>

<p>obj1 - The object which is to be inserted</p>
<p>obj2 - The object which is already inserted</p>

<mark>Note : If default natural sorting not available or if we are not satisfied with 
    default natural sorting order then we can go for customized sorting by using Comparator</mark>
<br><br>
<mark>&#10040&#10040&#10040Comparable meant for default natural sorting order whereas 
    Comparator meant for customized sorting order</mark>
<br><br>
<h5>Comparator(I)</h5>
<p>Comparator present in java.util package and it defines two methods compare() and equals()</p>

<h6>Methods</h6>
<pre><code>
    1. public int compare(Object obj1, Object obj2)

    - returns (-ve) iff obj1 has to come before obj2
    
    - returns (+ve) iff obj1 has to come after obj2 

    - returns 0 iff obj1 & obj2 are equal

    2. public boolean equals(Object obj)
</code></pre>

<p>Whenever we are implementing Comparator interface compulsory we should provide implementation only for 
    compare method and we are not required to provide implementation for equals() method because 
it is already available to our class from object class through inheritance. </p>


<div class="fluid-container">
	<p class="bg-warning text-white">WAP to insert Integer objects in the TreeSet where the sorting order is descending order</p>
    <pre><code>
import java.util.Comparator;
import java.util.TreeSet;

public class TreeSetDemo {

	public static void main(String[] args) {
		TreeSet t = new TreeSet(new MyComparator()); // line1
		t.add(10);
		t.add(0); // compare(0, 10) (+ve)
		t.add(15); // compare(15, 10) (-ve)
		t.add(5); // compare(5, 10) (+ve)
			// compare(5, 0) (-ve)
		t.add(20); // compare(20, 10) (-ve)
			// compare(20, 15) (-ve)
		t.add(20); // compare(20, 10) (-ve)
			// compare(20, 10) (-ve)
			// compare(20, 20) (0)
		System.out.println(t);
	}
}


class MyComparator implements Comparator {

	@Override
	public int compare(Object obj1, Object obj2) {
		Integer I1 = (Integer) obj1;
		Integer I2 = (Integer) obj2;

		if (I1 < I2)
			return +1;
		else if (I1 > I2)
			return -1;
		else
			return 0;
	}

}
    </code></pre>
    
    <pre><output>
        [20, 15, 10, 5, 0]
    </output></pre>

    <img src="images/ss153.png" alt="ss12" width="400" height="300">
    <p>At line 1 if we are not passing Comparator object then internally JVM will call compareTo() method 
        which is meant for default natural sorting order. In this case the output is 
        </p>
        <pre><code>
            [0, 5, 10, 15, 20]
        </code></pre>
<p>At line1 if we are passing Comparator object then JVM will call compare() method which is meant for customized sorting. 
    In this case output is</p>
    <pre><output>
        [20, 15, 10, 5, 0]
    </output></pre>
    </div> 

<h6>Various possible implementations of compare() method</h6>
<pre><code>
    public int compare(Object obj1, Object obj2) {
		Integer I1 = (Integer) obj1;
		Integer I2 = (Integer) obj2;

        //default natural sorting order[Ascending order][0, 5, 10, 15, 20]
        return I1.compareTo(I2);

        //[Descending order][20, 15, 10, 5, 0]
        return -I1.compareTo(I2);

        //[Descending order][20, 15, 10, 5, 0]
        return I2.compareTo(I1)
        
        [Ascending order][0, 5, 10, 15, 20]
        return -I2.compareTo(I1)

        //[Insertion order][10, 0, 15, 5, 20, 20]
        return +1;

        //[Reverse of insertion order][20, 20, 5, 15, 0, 10]
        return -1;

        //[only first element will be inserted & all remaining are considered as duplicates][10]
        return 0;   
    
    }
</code></pre>

<div class="fluid-container">
	<p class="bg-warning text-white">WAP to insert String objects into the TreeSet where all elements should 
        be inserted according to reverse of alphabetical order.
    </p>
<pre><code>
    import java.util.Comparator;
    import java.util.TreeSet;
    
    public class TreeSetDemo {
    
        public static void main(String[] args) {
            TreeSet t = new TreeSet(new MyComparator()); 
            t.add("Roja");
            t.add("ShobhaRani");
            t.add("RajaKumari");
            t.add("GangaBhavani");
            t.add("Ramulamma");
    
            System.out.println(t);
        }
    }
    
    class MyComparator implements Comparator {
    
        @Override
        public int compare(Object obj1, Object obj2) {
            String s1 = obj1.toString();
            String s2 = (String) obj2;
            return s2.compareTo(s1);
            // return -s1.compareTo(s2);
        }
    }
</code></pre>

<pre><output>
    [ShobhaRani, Roja, Ramulamma, RajaKumari, GangaBhavani]
</output></pre>
</div> 

<div class="container">
	<p class="bg-warning text-white">WAP to insert StringBuffer objects into the TreeSet where 
        sorting order is alphabetical order.
    </p>
<pre><code>
    import java.util.Comparator;
    import java.util.TreeSet;
    
    public class TreeSetDemo {
    
        public static void main(String[] args) {
            TreeSet t = new TreeSet(new MyComparator()); 
            t.add(new StringBuffer("A"));
            t.add(new StringBuffer("Z"));
            t.add(new StringBuffer("K"));
            t.add(new StringBuffer("L"));
    
            System.out.println(t);
        }
    }
    
    class MyComparator implements Comparator {
    
        @Override
        public int compare(Object obj1, Object obj2) {
            String s1 = obj1.toString();
            String s2 = obj2.toString();
            return s1.compareTo(s2);
        }
    }
</code></pre>

<pre><output>
    [A, K, L, Z]
</output></pre>
</div> 

<mark>Note : If we are depending on default natural sorting order compulsory objects should be 
    homogeneous and Comparable o/w we will get RE saying ClassCastException<br><br>
    If we are defining our own sorting by comparator then objects need not be Comparable and homogeneous 
    i.e we can add heterogeneous non comparable objects also.
</mark>
<br><br>

<div class="fluid-container">
	<p class="bg-warning text-white">WAP to insert String and StringBuffer objects into TreeSet where sorting 
        order is increasing length order. If two objects having same length then consider their alphabetical order.
    </p>
<pre><code>
    import java.util.Comparator;
    import java.util.TreeSet;
    
    public class TreeSetDemo {
    
        public static void main(String[] args) {
            TreeSet t = new TreeSet(new MyComparator());
            t.add("A");
            t.add(new StringBuffer("ABC"));
            t.add(new StringBuffer("AA"));
            t.add("XX");
            t.add("ABCD");
            t.add("A");
    
            System.out.println(t);
        }
    }
    
    class MyComparator implements Comparator {
    
        @Override
        public int compare(Object obj1, Object obj2) {
            String s1 = obj1.toString();
            String s2 = obj2.toString();
            int l1 = s1.length();
            int l2 = s2.length();
    
            if (l1 < l2)
                return -1;
            else if (l1 > l2)
                return 1;
            else
                return s1.compareTo(s2);
        }
    }
</code></pre>

<pre><output>
    [A, AA, XX, ABC, ABCD]
</output></pre>
</div> 


<h6>Comparable vs Comparator</h6>
<p>1. For predefined Comparable classes default natural sorting order 
    already available. If we are not satisfied with that default natural sorting
    order then we can define our own sorting by using Comparator</p>
<p>2. For predefined non Comparable classes (like StringBuffer) default natural sorting order 
    not already available. We can define our own sorting by using Comparator</p>

<p>3. For our own classes like Employee, the person who is writing the class is responsible to define 
    default natural sorting order by implementing Comparable interface.</p>

<p>The person who is using our class, if he is not satisfied with default natural sorting order 
    then he can define his own sorting by using Comparator</p>
    <img src="images/ss154.png" alt="ss12" width="600" height="600">

<pre><code>
    import java.util.Comparator;
    import java.util.TreeSet;
    
    class Employee implements Comparable {
    
        String name;
        int eid;
    
        public Employee(String name, int eid) {
            super();
            this.name = name;
            this.eid = eid;
        }
    
        @Override
        public String toString() {
            return name + "--" + eid;
        }
    
        @Override
        public int compareTo(Object obj) {
            int eid1 = this.eid;
            Employee e = (Employee) obj;
            int eid2 = e.eid;
    
            if (eid1 < eid2) {
                return -1;
            } else if (eid1 > eid2) {
                return 1;
            } else
                return 0;
        }
    
    }
    
    public class ComparableComparator {
    
        public static void main(String[] args) {
            Employee e1 = new Employee("nag", 100);
            Employee e2 = new Employee("balaiah", 200);
            Employee e3 = new Employee("chiru", 50);
            Employee e4 = new Employee("venki", 150);
            Employee e5 = new Employee("nag", 100);
    
            TreeSet t = new TreeSet();
            t.add(e1);
            t.add(e2);
            t.add(e3);
            t.add(e4);
            t.add(e5);
        
            System.out.println(t);
            
            TreeSet t1 = new TreeSet(new MyComparator());
            t1.add(e1);
            t1.add(e2);
            t1.add(e3);
            t1.add(e4);
            t1.add(e5);
        
            System.out.println(t1);
        }
    
    }
    
    class MyComparator implements Comparator{
    
        @Override
        public int compare(Object obj1, Object obj2) {
            Employee e1 = (Employee)obj1;
            Employee e2 = (Employee)obj2;
            String s1 = e1.name;
            String s2 = e2.name;
            return s1.compareTo(s2);
        }
        
    }
</code></pre>

<pre><output>
    [chiru--50, nag--100, venki--150, balaiah--200]
    [balaiah--200, chiru--50, nag--100, venki--150]
</output></pre>

<h6>Comparison of Comparable and Comparator</h6>
<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>Comparable</th>
            <th>Comparator</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>It is meant for default natural sorting order</td>
            <td>It is meant for customized sorting order</td>
        </tr>
        <tr>
            <td>Present in java.lang package</td>
            <td>Present in java.util package</td>
        </tr>
        <tr>
            <td>It defines only one method compareTo()</td>
            <td>It defines two methods compare() and equals()</td>
        </tr>
        <tr>
            <td>String and all Wrapper classes implements Comparable interface</td>
            <td>The only implemented classes of Comparator are Collator and RuleBasedCollator</td>
        </tr>  
    </tbody>
</table>

<h5>Comparison table of Set implemented classes</h5>
<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>Property</th>
            <th>HashSet</th>
            <th>LinkedHashSet</th>
            <th>TreeSet</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>Underlying data structure</td>
            <td>Hashtable</td>
            <td>Combination of LinkedList and Hashtable</td>
            <td>Balanced tree</td>
        </tr>
        <tr>
            <td>Duplicate objects</td>
            <td>Not allowed</td>
            <td>Not allowed</td>
            <td>Not allowed</td>
        </tr>
        <tr>
            <td>Insertion order</td>
            <td>Not preserved</td>
            <td>Preserved</td>
            <td>Not preserved</td>
        </tr>
        <tr>
            <td>Sorting order</td>
            <td>Not applicable</td>
            <td>Not applicable</td>
            <td>Applicable</td>
        </tr>
        <tr>
            <td>Heterogeneous objects</td>
            <td>Allowed</td>
            <td>Allowed</td>
            <td>Not allowed</td>
        </tr>
        <tr>
            <td>null acceptance</td>
            <td>Allowed</td>
            <td>Allowed</td>
            <td>For empty TreeSet as first element null is allowed</td>
        </tr>  
    </tbody>
</table>
<br><br>
<mark>Note : For empty TreeSet as the first element null is allowed but this rule is applicable until 
    1.6v only. From 1.7v onwards null is not allowed even as the first element.
</mark><br><br>

<h3>Map(I)</h3>
<img src="images/ss148.png" alt="ss12" width="800" height="500">

<p>Map is <span style="color: red;">not</span> child interface of Collection</p>
<p>If we want to represent a group of objects as key value pairs then we should go for Map</p>
<img src="images/ss144.png" alt="ss12" width="300" height="300">

<p>Both keys and values are objects only</p>
<p>Duplicate keys are not allowed but values can be duplicated</p>
<p>Each key value pair is called entry hence Map is considered as a Collection of entry objects.</p>

<h6>Map interface methods</h6>
<pre><code>
    1. Object put(Object key, Object value)
    - to add one key value pair to the Map. If the key is already present 
    then old value will be replaced with new value and returns old value
</code></pre>

<pre><code>
    m.put(101, "durga");    //returns null
    m.put(102, "shiva");    //returns null
    m.put(101, "Ravi");     //returns durga
</code></pre>

<img src="images/ss155.png" alt="ss12" width="400" height="200">

<pre><code>
    2. void putAll(Map m)

    3. Object get(Object key)
    - returns the value associated with specified key
      
    4. Object remove(Object key)
    - removes the entry associated with specified key

    5. boolean containsKey(Object key)

    6. boolean containsValue(Object value)

    7. boolean isEmpty() 

    8. int size() 

    9. void clear()
</code></pre>

<pre><code>
    1. Set keySet()
    2. Collection values()
    3. Set entrySet()
</code></pre>

<p>These 3 methods are by default considered as <span style="color: red;">Collection views of Map</span></p>

<h5>Entry(I)</h5>
<p>A Map is a group of key value pairs and each key value pair is called an entry hence Map 
    is considered as a Collection of entry objects. Without existing Map object there is no chance 
    of existing entry object hence Entry(I) is defined inside Map interface</p>

<pre><code>
    interface Map {
        interface Entry {
            Object getKey();
            Object getValue();
            Object setValue(Object newObject);
        }
    }
</code></pre>

<p>These 3 methods are Entry specific methods and we can apply only on Entry object</p>

<h5>HashMap</h5>
<p>1. The underlying data structure is Hashtable</p>
<p>2. Insertion order is not preserved and it is based on hashCode of keys</p>
<p>3. Duplicate keys are not allowed but values can be duplicated</p>
<p>4. Heterogeneous objects are allowed for both key and value</p>
<p>5. null is allowed for key(only once)</p>
<p>6. null is allowed for values(any number of times)</p>
<p>7. HashMap implements Serializable and Cloneable interfaces but not RandomAccess</p>
<p>8. HashMap is the best choice if our frequent operation is serach operation</p>

<h6>Constructors</h6>
<pre><code>
    1. HashMap m = new HashMap();
    - creates an empty HashMap object with default initialcapacity 16 and 
    default fill ratio 0.75

    2. HashMap m = new HashMap(int initialcapacity);
    - creates an empty HashMap object with specified initialcapacity and 
    default fill ratio 0.75

    3. HashMap m = new HashMap(int initialcapacity, float fillRatio);
    
    4. HashMap m = new HashMap(Map m);
    
</code></pre>

<pre><code>
    import java.util.Collection;
    import java.util.HashMap;
    import java.util.Iterator;
    import java.util.Map;
    import java.util.Set;
    
    public class HashMapDemo {
    
        public static void main(String[] args) {
            HashMap m = new HashMap();
            m.put("chiranjeevi", 700);
            m.put("balaiah", 800);
            m.put("venkatesh", 200);
            m.put("nagarjuna", 500);
    
            System.out.println(m);
    
            System.out.println(m.put("chiranjeevi", 1000));
    
            Set s = m.keySet();
            System.out.println(s);
    
            Collection c = m.values();
            System.out.println(c);
    
            Set s1 = m.entrySet();
            System.out.println(s1);
    
            Iterator iterator = s1.iterator();
            while (iterator.hasNext()) {
                Map.Entry m1 = (Map.Entry) iterator.next();
    
                System.out.println(m1.getKey() + "......" + m1.getValue());
    
                if (m1.getKey().equals("nagarjuna")) {
                    m1.setValue(10000);
                }
            }
            System.out.println(m);
        }
    
    }
</code></pre>

<pre><output>
    {balaiah=800, chiranjeevi=700, venkatesh=200, nagarjuna=500}
    700
    [balaiah, chiranjeevi, venkatesh, nagarjuna]
    [800, 1000, 200, 500]
    [balaiah=800, chiranjeevi=1000, venkatesh=200, nagarjuna=500]
    balaiah......800
    chiranjeevi......1000
    venkatesh......200
    nagarjuna......500
    {balaiah=800, chiranjeevi=1000, venkatesh=200, nagarjuna=10000}    
</output></pre>

<h6>Differences between HashMap and Hashtable</h6>
<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>HashMap</th>
            <th>Hashtable</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>Every method present in HashMap is not synchronized</td>
            <td>Every method present in Hashtable is synchronized</td>
        </tr>  
        <tr>
            <td>At a time multiple threads are allowed to operate on HashMap object and hence it is not thread safe</td>
            <td>At a time only one thread is allowed to operate on Hashtable and hence it is thread safe</td>
        </tr>  
        <tr>
            <td>Relatively performance is high because threads are not required to wait to operate on HashMap object</td>
            <td>Relatively performance is low because threads are required to wait to operate on Hashtable object</td>
        </tr>  
        <tr>
            <td>null is allowed for both key and value</td>
            <td>null is not allowed for keys and values o/w we will get NullPointerException</td>
        </tr>  
        <tr>
            <td>Introduced in 1.2v and it is not legacy</td>
            <td>Introduced in 1.0v and it is legacy</td>
        </tr>  
    </tbody>
</table>

<div class="container">
	<p class="bg-warning text-white">How to et synchronized version of HashMap?</p>
    <p>By default HashMap is non synchronized but we can get synchronized version of HashMap. 
        By using synchronizedMap() method of Collections class </p>
    <pre><code>
        HashMap m = new HashMap();
        Map m1 = Collections.synchronizedMap();
    </code></pre>
    <img src="images/ss156.png" alt="ss12" width="500" height="200">
</div> 

<h3>LinkedHashMap</h3>
<p>It is the child class of HashMap. It is exactly same as HashMap(including methods and Constructors)
    except the following differences</p>
    <table class="table table-striped">
        <thead class="thead-dark">
            <tr>
                <th>HashMap</th>
                <th>LinkedHashMap</th>
            </tr>
        </thead> 
        <tbody>
            <tr>
                <td>The underlying data structure is Hashtable</td>
                <td>The underlying data structure is a combination of LinkedList and Hashtable(hybrid data structure)</td>
            </tr>  
            <tr>
                <td>Insertion order is not preserved and it is based on hashCode of keys</td>
                <td>Insertion order is preserved</td>
            </tr>  
            <tr>
                <td>Introducedin 1.2v</td>
                <td>Introduced in 1.4v</td>
            </tr>  
        </tbody>
    </table> 

<p>In the above HashMap program if we replace HashMap with LinkedHashMap then output is </p>
<pre><code>
    import java.util.Collection;
    import java.util.LinkedHashMap;
    import java.util.Iterator;
    import java.util.Map;
    import java.util.Set;
    
    public class HashMapDemo {
    
        public static void main(String[] args) {
            LinkedHashMap m = new LinkedHashMap();
            m.put("chiranjeevi", 700);
            m.put("balaiah", 800);
            m.put("venkatesh", 200);
            m.put("nagarjuna", 500);
    
            System.out.println(m);
    
            System.out.println(m.put("chiranjeevi", 1000));
    
            Set s = m.keySet();
            System.out.println(s);
    
            Collection c = m.values();
            System.out.println(c);
    
            Set s1 = m.entrySet();
            System.out.println(s1);
    
            Iterator iterator = s1.iterator();
            while (iterator.hasNext()) {
                Map.Entry m1 = (Map.Entry) iterator.next();
    
                System.out.println(m1.getKey() + "......" + m1.getValue());
    
                if (m1.getKey().equals("nagarjuna")) {
                    m1.setValue(10000);
                }
            }
            System.out.println(m);
        }
    
    }    
</code></pre>

<pre><output>
    {chiranjeevi=700, balaiah=800, venkatesh=200, nagarjuna=500}
    700
    [chiranjeevi, balaiah, venkatesh, nagarjuna]
    [1000, 800, 200, 500]
    [chiranjeevi=1000, balaiah=800, venkatesh=200, nagarjuna=500]
    chiranjeevi......1000
    balaiah......800
    venkatesh......200
    nagarjuna......500
    {chiranjeevi=1000, balaiah=800, venkatesh=200, nagarjuna=10000}
</output></pre>

 <p>i.e insertion order is preserved</p>
 <mark> Note : LinkedHashSet and LinkedHashMap are commonly used for developing cache based 
     applications</mark><br><br>

<h6>Difference between == operator and .equlas() method</h6>
<p>In general == operator meant for reference comparison(address comparison) whereas .equals() 
    method meant for content comparison</p>
    <pre><code>
        Integer I1 = new Integer(10);
        Integer I2 = new Integer(10);
        SOP(I1 == I2);
        SOP(I1.equals(I2));
    </code></pre>
    
    <pre><output>
        false
        true
    </output></pre> 

<h3>IdentityHashMap</h3>
<p>It is exactly same as HashMap(including methods and Constructors) except the following difference</p>
<p>In the case of normal HashMap JVM will use .equals() method to identify duplicate keys, which is meant
    for content comparison </p>
<p>But in the case of IdentityHashMap JVM will use == operator to identify duplicate keys which is meant for reference 
    comparison(address comparison)
</p>

<pre><code>
    import java.util.HashMap;

    public class HashMapEqualsDemo {
    
        public static void main(String[] args) {
            HashMap m = new HashMap();
            Integer I1 = new Integer(10);
            Integer I2 = new Integer(10);
    
            m.put(I1, "pawan");
            m.put(I2, "kalyan");
    
            System.out.println(m);
    
        }
    
    }    
</code></pre>

<pre><output>
    {10=kalyan}
</output></pre>

<img src="images/ss157.png" alt="ss12" width="300" height="200">

<p>I1 and I2 are duplicate keys because I1.equals(I2) returns true</p>

<p>If we replace HashMap with IdentityHashMap then I1 and I2 are not duplicate keys because 
    I1 == I2 returns false. In this case output is
</p>

<pre><code>
    import java.util.IdentityHashMap;

    public class IdentityHashMapDemo {
    
        public static void main(String[] args) {
            IdentityHashMap m = new IdentityHashMap();
            Integer I1 = new Integer(10);
            Integer I2 = new Integer(10);
    
            m.put(I1, "pawan");
            m.put(I2, "kalyan");
    
            System.out.println(m);
    
        }
    }    
</code></pre>

<pre><output>
    {10=pawan, 10=kalyan}
</output></pre>

<h3>WeakHashMap</h3>
<p>It is exactly same as HashMap excpet the following difference</p>
<p>In the case of HashMap even though object doesnt have any difference it is not eligible for GC 
    if it is associated with HashMap i.e HashMap dominates GC</p>
<p>But in the case of WeakHashMap if object doesnt contain any references it is eligible for GC even though 
    object associated with WeakHashMap i.e Garbage Collector dominates WeakHashMap</p>

<pre><code>
    import java.util.HashMap;

    public class WeakHashMapDemo {
        public static void main(String[] args) throws InterruptedException {
            HashMap m = new HashMap();
            Temp t = new Temp();
            m.put(t, "durga");
            System.out.println(m);
            t = null;
            System.gc();
            Thread.sleep(5000);
            System.out.println(m);
        }
    }
    
    class Temp {
        public String toString() {
            return "temp";
        }
    
        public void finalize() {
            System.out.println("Finalize method called.");
        }
    }
</code></pre>

<p>In the above example Temp object not eligible for GC because it is associated with HashMap. In 
    this case output is</p>
<pre><output>
    {temp=durga}
    {temp=durga}    
</output></pre>

<p>In the above program if we replace HashMap with WeakHashMap then Temp object eligible for GC. In this case output is</p>
<pre><code>
    import java.util.WeakHashMap;

    public class WeakHashMapDemo {
        public static void main(String[] args) throws InterruptedException {
            WeakHashMap m = new WeakHashMap();
            Temp t = new Temp();
            m.put(t, "durga");
            System.out.println(m);
            t = null;
            System.gc();
            Thread.sleep(5000);
            System.out.println(m);
        }
    }
    
    class Temp {
        public String toString() {
            return "temp";
        }
    
        public void finalize() {
            System.out.println("Finalize method called.");
        }
    }
</code></pre>

<pre><output>
    {temp=durga}
    Finalize method called.
    {}    
</output></pre>

<h3>SortedMap(I)</h3>
<p>It is the child interface of Map. </p>
<p>If we want to represent a group of key value pairs according to some sorting order of keys then 
    we should go for SortedMap</p>
<p>Sorting is based on the key but not based on value</p>
<p>SortedMap defines the following specific methods</p>
<pre><code>
    1. Object firstKey();
    2. Object lastKey();
    3. SortedMap headMap(Object key)
    4. SortedMap tailMap(Object key)
    5. SortedMap subMap(Object key1, Object key2)
    6. Comparator comparator()
</code></pre>
<img src="images/ss158.png" alt="ss12" width="200" height="300">
<pre><code>
    firstKey()          -       101
    lastKey()           -       136
    hashMap(107)        -       {101 = A, 103 = B, 104 = C}
    tailMap(107)        -       {107 = D, 125 = E, 136 = F}
    subMap(103, 125)    -       {103 = B, 104 = C, 107 = D}
    comparator()        -       null
</code></pre>

<h3>TreeMap</h3>
<p>The underlying data structure is RED-BLACK tree</p>
<p>Insertion order is not preserved and it is based on some sorting order of keys</p>
<p>Duplicate keys are not allowed but values can be duplicated</p>
<p>If we are depending on default natural sorting order then keys should be homogeneous and Comparable o/w 
    we will get RE saying ClassCastException</p>
<p>If we are defining our own sorting by Comparator then keys need not be homogeneous and Comparable, we can 
    take heterogeneous non comparable objects also</p>
    
<p>Whether we are depending on default natural sorting order or customized sorting order there are no restrictions 
    for values we can take heterogeneous non comparable objects also</p>

<h6>null acceptance</h6>
<p>1. For non empty TreeMap if we are trying to insert an entry with null key then we will get RE : saying NullPointerException
    </p>
    <p>2. For empty TreeMap as a first entry with null key is allowed but after inserting that entry if we are trying to insert 
        any other entry then we will get RE saying NullPointerException
    </p>
<mark>Note : The above null acceptance rule is applicable until 1.6v only. From 1.7v onwards null is not allowed for key</mark>
<br><br>
<p>But for values we can use null any number of times there is no restrictions Whether it is 1.6v or 1.7v</p>

<h6>Constructors</h6>
<pre><code>
    1. TreeMap t = new TreeMap();
    - for default natural sorting order

    2. TreeMap t = new TreeMap(Comparator c)
    - for customized sorting order

    3. TreeMap t = new TreeMap(SortedMap m);

    4. TreeMap t = new TreeMap(Map m)
</code></pre>

<h6>Demo program for default natural sorting order</h6>
<pre><code>
    import java.util.TreeMap;

    public class TreeMapDemo {
    
        public static void main(String[] args) {
            TreeMap m = new TreeMap();
            m.put(100, "ZZZ");
            m.put(103, "YYY");
            m.put(101, "XXX");
            m.put(104, "106");
            //m.put("FFFF", "XXX");		//ClassCastException
            //m.put(null, "XXX");		//NullPointerException
            System.out.println(m);
            
        }
    
    }    
</code></pre>

<pre><output>
    {100=ZZZ, 101=XXX, 103=YYY, 104=106}
</output></pre>

<h6>Demo program for customized sorting</h6>
<pre><code>
    import java.util.Comparator;
    import java.util.TreeMap;
    
    public class TreeMapDemo {
    
        public static void main(String[] args) {
            TreeMap m = new TreeMap(new MyComparator());
            m.put("XXX", 10);
            m.put("AAA", 20);
            m.put("ZZZ", 30);
            m.put("LLL", 40);
            System.out.println(m);
            
        }
    }
    class MyComparator implements Comparator {
        public int compare (Object obj1, Object obj2) {
            String s1 = obj1.toString();
            String s2 = obj2.toString();
            return s2.compareTo(s1);
        }
    }
</code></pre>


<pre><output>
    {ZZZ=30, XXX=10, LLL=40, AAA=20}
</output></pre>

<h3>Hashtable</h3>
<p>1. The underlying data structure for Hashtable is Hashtable</p>
<p>2. Insertion order is not preserved and it is based on <span style="color: red;">hashCode of keys</span></p>
<p>3. Duplicate keys are not allowed and values can be duplicated</p>
<p>4. Heterogeneous objects are allowed for both keys and values</p>
<p>5. null is not allowed for both key and value o/w we will get RE saying NullPointerException</p>
<p>6. It implements Serializable and Cloneable interfaces but not RandomAccess</p>
<p>7. Every method present in Hashtable is synchronized and hence Hashtable object is thread safe</p>
<p>8. Hashtable is the best choice if our frequent option is search operation</p>

<h6>Constructors</h6>
<pre><code>
    1. Hashtable h = new Hashtable();
    - creates an empty Hashtable object with default initialcapacity 
    11 and default fill ratio 0.75

    2. Hashtable h = new Hashtable(int initialcapacity);
    
    3. Hashtable h = new Hashtable(int initialcapacity, float fillRatio);

    4. Hashtable h = new Hashtable(Map m);
</code></pre>

<pre><code>
    import java.util.Hashtable;

    public class HashtableDemo {
    
        public static void main(String[] args) {
            Hashtable h = new Hashtable();
            h.put(new Temp(5), "A");
            h.put(new Temp(2), "B");
            h.put(new Temp(6), "C");
            h.put(new Temp(15), "D");
            h.put(new Temp(23), "E");
            h.put(new Temp(16), "F");
            //h.put("durga", null);	//NPE
            System.out.println(h);
        }
    
    }
    class Temp {
        int i;
        public Temp(int i) {
            this.i = i;
        }
        @Override
        public int hashCode() {
            return i;
        }
        @Override
        public String toString() {
            return i + "";
        }	
    }
</code></pre>

<pre><output>
    {6=C, 16=F, 5=A, 15=D, 2=B, 23=E}
</output></pre>

<img src="images/ss159.png" alt="ss12" width="400" height="600">

<p>If we change hashCode() method of Temp class as</p>
<pre><code>
    import java.util.Hashtable;

    public class HashtableDemo {
    
        public static void main(String[] args) {
            Hashtable h = new Hashtable();
            h.put(new Temp(5), "A");
            h.put(new Temp(2), "B");
            h.put(new Temp(6), "C");
            h.put(new Temp(15), "D");
            h.put(new Temp(23), "E");
            h.put(new Temp(16), "F");
            //h.put("durga", null);	//NPE
            System.out.println(h);
        }
    
    }
    class Temp {
        int i;
        public Temp(int i) {
            this.i = i;
        }
        @Override
        public int hashCode() {
            return i % 9;
        }
        @Override
        public String toString() {
            return i + "";
        }	
    }
</code></pre>

<pre><output>
    {16=F, 15=D, 6=C, 23=E, 5=A, 2=B}
</output></pre>

<img src="images/ss160.png" alt="ss12" width="400" height="600">

<p>If we configure initialcapacity as 25 i.e </p>
<pre><code>
    Hashtable h = new Hashtable(25);
</code></pre>

<pre><output>
    {23=E, 16=F, 15=D, 6=C, 5=A, 2=B}
</output></pre>
<img src="images/ss161.png" alt="ss12" width="400" height="650">

<h3>Properties</h3>
<p>In our program if anything which changes frequently (like username, password, mail id, mobile number etc)
    are not recommended to hardcode in java program because if there is any change, to reflect that change recompilation, 
    rebuild and redeploy application are required. Even sometimes server restart also required which creates 
    a big business impact to the client</p>
<p>We can overcome this problem by using properties file. Such type of variable things we have to configure in the properties file. 
    From that properties file we have to read into java program and we can use those properties. 
</p>
<p>The main advantage of this approach is if there is a change in properties file, to reflect that change just redeployment is enough
    which wont create any business impact to the client</p>

<p>We can use java properties object to hold properties which are coming from properties file.</p>
<p>In normal Map(like HashMap, Hashtable, TreeMap) key and value can be any type but in the case of properties key and value should be String type</p>

<h6>Constructor</h6>
<pre><code>
    Properties p = new Properties();
</code></pre>

<h6>Methods</h6>
<pre><code>
    1. String setProperty(String pname, String pvalue)
    - to set a new Property
    If the specified property already available then old value will be 
    replaced with new value and returns old value.

    2. String getProperty(String pname);
    - to get value associated with the specified property 
    If the specified property not available then this method returns null

    3. Enumeration propertyNames()
    - returns all property names present in Properties object
</code></pre>

<pre><code>
    1. void load(InputStream is)
    - to load properties from properties file into java properties object

    2. void store(OutputStream os, String comment) 
    - to store properties from java properties object into properties file
</code></pre>

<img src="images/ss162.png" alt="ss12" width="500" height="400">

<pre><code>
    import java.io.FileInputStream;
    import java.io.FileOutputStream;
    import java.io.IOException;
    import java.util.Properties;
    
    public class PropertiesDemo {
    
        public static void main(String[] args) throws IOException {
            Properties p = new Properties();
            FileInputStream fis = new FileInputStream("abc.properties");
            p.load(fis);
            System.out.println(p);
            
            String s = p.getProperty("venki");
            System.out.println(s);
            p.setProperty("nag", "88888");
            
            FileOutputStream fos = new FileOutputStream("abc.properties");
            p.store(fos, "Updated by Nc");
        }
    
    }
</code></pre>

<pre><output>
    abc.properties Before------------------------
    venki=9999
    pwd=tiger123
    user=scott

    abc.properties after-------------------------
    #Updated by Nc
    #Thu Oct 08 14:08:55 IST 2020
    venki=9999
    nag=88888
    pwd=tiger123
    user=scott
        
    Output-
    {venki=9999, nag=88888, pwd=tiger123, user=scott}
    9999    
</output></pre>

<pre><code>
    public class PropertiesDemo {

        public static void main(String[] args) throws IOException, SQLException {
            Properties p = new Properties();
            FileInputStream fis = new FileInputStream("db.properties");
            p.load(fis);
            
            String url = p.getProperty("url");
            String user = p.getProperty("user");
            String pwd = p.getProperty("pwd");
            
            Connection con = DriverManager.getConnection(url, user, pwd);
        }
    }
</code></pre>

<h3>1.5v enhancements(Queue(I))</h3>
<p>It is the child interface of Collection</p>

<img src="images/ss163.png" alt="ss12" width="700" height="600">
<p>If we want to represent a group of individual objects prior to processing then we should 
    go for queue.</p>
<p>For example - Before sending SMS message all mobile numbers we have store in some data structure. In which 
    we added mobile numbers in the same order only message should be delivered, for this FIFO requirement Queue is 
    the best choice</p>
<p>Usually Queue follow FIFO order but based on our requirement we can implement our own priority 
    order also(PriorityQueue)
</p>
<p>From 1.5v onwards LinkedList class also implements Queue interface</p>
<p>LinkedList based implementation of Queue always follows FIFO order</p>

<h6>Queue interface specific methods</h6>
<pre><code>
    1. boolean offer(Object o)
    - to add an object into the queue

    2. Object peek() 
    - to return head element of the queue. If the queue is empty then this
    method returns null 

    3. Object element() 
    - to return head element of the queue. If queue is empty then this 
    method raises RE: NoSuchElementException

    4. Object poll() 
    - to remove and return head element of the queue. If queue is empty 
    then this method returns null

    5. Object remove() 
    - to remove and return head element of the queue. If queue is empty 
    then this method raises RE : NoSuchElementException
</code></pre>

<h5>PriorityQueue</h5>
<p>1. If we want to represent a group of individual objects prior to processing according
    to some priority then we should go for PriorityQueue</p>
<p>2. The priority can be either default natural sorting order or customized sorting order 
    defined by Comparator</p>
<p>3. Insertion order is not preserved and it is based on some priority</p>
<p>4. Duplicate objects are not allowed/p>
<p>5. If we are depending on default natural sorting order compulsory the objects should be 
    homogeneous and Comparable o/w we will get RE saying ClassCastException
</p>
<p>6. If we are defining our own sorting by Comparator then objects need not be homogeneous 
    and Comparable
</p>
<p>7. null is not allowed even as the first element also</p>

<h6>Constructors</h6>
<pre><code>
1. PriorityQueue q = new PriorityQueue();
- creates an empty PriorityQueue with default initialcapacity 11 and all 
objects will be inserted according to default natural sorting order

2. PriorityQueue q = new PriorityQueue(int initialcapacity);

3. PriorityQueue q = new PriorityQueue(int initialcapacity, Comparator c);

4. PriorityQueue q = new PriorityQueue(SortedSet s);

5. PriorityQueue q = new PriorityQueue(Collection c);
</code></pre>

<pre><code>
    import java.util.PriorityQueue;

    public class PriorityQueueDemo {
    
        public static void main(String[] args) {
            PriorityQueue q = new PriorityQueue();
            System.out.println(q.peek());
    
            //System.out.println(q.element()); //NoSuchElementException
        
            for (int i = 0; i <= 10; i++) {
                q.offer(i);
            }
            
            System.out.println(q);
            System.out.println(q.poll());
            System.out.println(q);
        }
    
    }
</code></pre>

<pre><output>
    null
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    0
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]    
</output></pre>

<mark>Note : Some platforms wont provide proper support for thread priorities and 
    PriorityQueue</mark><br><br>

<pre><code>
    import java.util.Comparator;
    import java.util.PriorityQueue;
    
    public class CustomizedPriorityQueue {
    
        public static void main(String[] args) {
            PriorityQueue q = new PriorityQueue(15, new MyComparator());
            q.offer("A");
            q.offer("Z");
            q.offer("L");
            q.offer("B");
            System.out.println(q);
        }
    
    }
    class MyComparator implements Comparator {
        public int compare(Object obj1, Object obj2) {
            String s1 = (String)obj1; 
            String s2 = obj2.toString();
            return s2.compareTo(s1);
        }
    }    
</code></pre>

<pre><output>
    [Z, L, B, A]
</output></pre>

<h3>1.6v enhancements in Collection framework NavigableSet</h3>
<p>As a part of 1.6v the following two concepts Introduced in Collection framework</p>
<p>1. NavigableSet(I)</p>
<p>2. NavigableMap(I)</p>

<h3>NavigableSet(I)</h3>

<p>It is the child interface of SortedSet and it defines several methods for navigation purposes.</p>
<img src="images/ss142.png" alt="ss12" width="400" height="500">

<h6>NavigableSet defines the following methods</h6>
<pre><code>
1. floor(e)
- it returns highest element which is <= e 

2. lower(e) 
- it returns highest element which is < e 

3. ceiling(e) 
- it returns lowest element which is >= e 

4. higher(e)
- it returns lowest element which is > e 

5. pollFirst() 
- remove and return first element

6. pollLast() 
- remove and return last element

7. descendingSet() 
- it returns NavigableSet in reverse set
</code></pre>


<pre><code>
    import java.util.TreeSet;

    public class NavigableSetDemo {
    
        public static void main(String[] args) {
            TreeSet<Integer> t = new TreeSet<Integer>();
            t.add(1000);
            t.add(2000);
            t.add(3000);
            t.add(4000);
            t.add(5000);
            
            System.out.println(t);
            System.out.println(t.ceiling(2000));
            System.out.println(t.higher(2000));
            System.out.println(t.floor(3000));
            System.out.println(t.lower(3000));
            System.out.println(t.pollFirst());
            System.out.println(t.pollLast());
            System.out.println(t.descendingSet());
            System.out.println(t);
        }
    
    }
</code></pre>

<pre><output>
    [1000, 2000, 3000, 4000, 5000]
    2000
    3000
    3000
    2000
    1000
    5000
    [4000, 3000, 2000]
    [2000, 3000, 4000]    
</output></pre>

<h3>NavigableMap(I)</h3>
<p>NavigableMap is the child interface of SortedMap</p>
<p>It defines several methods for navigation purposes</p>

<img src="images/ss146.png" alt="ss12" width="400" height="500">

<h6>NavigableMap defines the following methods</h6>
<pre><code>
1. floorKey() 
2. lowerKey()
3. ceilingKey()
4. higherKey()
5. pollFirstEntry()
6. pollLastEntry()
7. descendingMap()
</code></pre>
<pre><code>
    import java.util.TreeMap;

    public class NavigableMapDemo {
    
        public static void main(String[] args) {
            TreeMap<String, String> t = new TreeMap<String, String>();
            t.put("b", "banana");
            t.put("c", "cat");
            t.put("a", "apple");
            t.put("d", "dog");
            t.put("g", "gun");
            
            System.out.println(t);
            System.out.println(t.ceilingKey("c"));
            System.out.println(t.higherKey("e"));
            System.out.println(t.floorKey("e"));
            System.out.println(t.lowerKey("e"));
            System.out.println(t.pollFirstEntry());
            System.out.println(t.pollLastEntry());
            System.out.println(t.descendingMap());
            System.out.println(t);
        }
    
    }
</code></pre>

<pre><output>
    {a=apple, b=banana, c=cat, d=dog, g=gun}
    c
    g
    d
    d
    a=apple
    g=gun
    {d=dog, c=cat, b=banana}
    {b=banana, c=cat, d=dog}    
</output></pre>

<h3>Collections</h3>
<p>Collections class defines several utility methods for Collection objects like sorting, 
    searching, reversing etc.
</p>

<h6>Sorting elements of List</h6>
<p>Collections class defines the following two sort methods</p>
<pre><code>
    1. public static void sort(List l)
    - to sort based on default natural sorting order
    In this case List should compulsory contain homogeneous and Comparable objects o/w 
    we will get RE saying ClassCastException
    List should not contain null o/w we will get NullPointerException

    2. public static void sort(List l, Comparator c)
    - to sort based on customized sorting order


</code></pre>

<h6>Demo program for sorting elements of List according to default natural sorting order</h6>
<pre><code>
    import java.util.ArrayList;
    import java.util.Collections;
    
    public class CollectionsSortDemo {
    
        public static void main(String[] args) {
            ArrayList l = new ArrayList();
            l.add("Z");
            l.add("A");
            l.add("K");
            l.add("N");
            
            //l.add(new Integer(10));	//ClassCastException
            //l.add(null);	//NullPointerException
            
            System.out.println("Before sorting : " + l);
            Collections.sort(l);
            System.out.println("After sorting : " + l);
        }
    
    }
</code></pre>

<pre><output>
    Before sorting : [Z, A, K, N]
    After sorting : [A, K, N, Z]    
</output></pre>

<pre><code>
    import java.util.ArrayList;
    import java.util.Collections;
    import java.util.Comparator;
    
    public class CollectionsSortDemo {
    
        public static void main(String[] args) {
            ArrayList l = new ArrayList();
            l.add("Z");
            l.add("A");
            l.add("K");
            l.add("N");
            
            //l.add(new Integer(10));	//ClassCastException
            //l.add(null);	//NullPointerException
            
            System.out.println("Before sorting : " + l);
            Collections.sort(l, new MyComparator());
            System.out.println("After sorting : " + l);
        }
    
    }
    
    class MyComparator implements Comparator {
    
        @Override
        public int compare(Object o1, Object o2) {
            String s1 = (String)o1;
            String s2 = o2.toString();
            return s2.compareTo(s1);
        }
        
    }
</code></pre>

<pre><output>
    Before sorting : [Z, A, K, N]
    After sorting : [Z, N, K, A]    
</output></pre>

<h3>Searching elements of List</h3>
<p>Collections class defines the following binary search methods</p>
<pre><code>
1. public static int binarySearch(List l, Object target);
- If the List is sorted according to default natural sorting order then we have to 
use this method 

2. public static int binarySearch(List l, Object target, Comparator c);
- We have to use this method if the List is sorted according to customized sorting order
</code></pre>

<h6>Conclusions</h6>
<p>1. The above search methods internally will use binary search algorithm </p>
<p>2. Successful search returns index</p>
<p>3. Unsuccessful search returns insertion point</p>
<p>4. Insertion point is the location where we can place target element in sorted List</p>
<p>5. Before calling binary search method compulsory List should be sorted o/w we will get 
    unpredictable results
</p>
<p>6. If the List is sorted according to Comparator then at the time of search operation also 
    we have to pass same Comparator object o/w we will get unpredictable results</p>

<pre><code>
    import java.util.ArrayList;
    import java.util.Collections;
    
    public class CollectionsSearchDemo {
    
        public static void main(String[] args) {
            ArrayList l = new ArrayList();
            l.add("Z");
            l.add("A");
            l.add("M");
            l.add("K");
            l.add("a");
            
            System.out.println(l);
            Collections.sort(l);
            System.out.println(l);
            System.out.println(Collections.binarySearch(l, "Z"));
            System.out.println(Collections.binarySearch(l, "J"));
        }
    
    }
</code></pre>

<pre><output>
    [Z, A, M, K, a]
    [A, K, M, Z, a]
    3
    -2    
</output></pre>

<img src="images/ss164.png" alt="ss12" width="400" height="300">

<pre><code>
    import java.util.ArrayList;
    import java.util.Collections;
    import java.util.Comparator;
    
    public class CollectionsSearchDemo {
    
        public static void main(String[] args) {
            ArrayList l = new ArrayList();
            l.add(15);
            l.add(0);
            l.add(20);
            l.add(10);
            l.add(5);
    
            System.out.println(l);
            Collections.sort(l, new MyComparator());
            System.out.println(l);
            System.out.println(Collections.binarySearch(l, 10, new MyComparator()));
            System.out.println(Collections.binarySearch(l, 13, new MyComparator()));
            System.out.println(Collections.binarySearch(l, 17));// unpredictable
        }
    
    }
    
    class MyComparator implements Comparator {
    
        @Override
        public int compare(Object o1, Object o2) {
            Integer i1 = (Integer) o1;
            Integer i2 = (Integer) o2;
            return i2.compareTo(i1);
        }
    
    }    
</code></pre>

<pre><output>
    [15, 0, 20, 10, 5]
    [20, 15, 10, 5, 0]
    2
    -3
    -6   //unpredictable 
</output></pre>

<img src="images/ss165.png" alt="ss12" width="400" height="300">
<br><br>
<mark>Note : For the list of n elements in the case of binary search method </mark>
<pre><code>
    1. Successful search result range : 0 to n-1 
    2. Unsuccessful search result range : n+1 to -1 
    3. Total result range : -(n+1) to n-1
</code></pre>

<p>Example : </p>
<img src="images/ss166.png" alt="ss12" width="400" height="300">

<h6>Reversing elements of List</h6>
<p>Collections class defines the following reverse method to reverse elements of List</p>
<pre><code>
    public static void reverse(List l);
</code></pre>
<pre><code>
    import java.util.ArrayList;
    import java.util.Collections;
    
    public class CollectionsReverseDemo {
    
        public static void main(String[] args) {
            ArrayList l = new ArrayList();
            l.add(15);
            l.add(0);
            l.add(20);
            l.add(10);
            l.add(5);
            
            System.out.println(l);
            Collections.reverse(l);
            System.out.println(l);
        }
    }    
</code></pre>

<pre><output>
    [15, 0, 20, 10, 5]
    [5, 10, 20, 0, 15]    
</output></pre>

<h5>reverse() vs reverseOrder()</h5>
<p>We can use reverse() method to reverse order of elements of List whereas we can use 
    reverseOrder() method to get reversed Comparator</p>
    <img src="images/ss167.png" alt="ss12" width="700" height="300">
    
<h3>Arrays</h3>
<p>Arrays class is an utility class to define several utility methods for Array objects</p>
<h5>Sorting elements of Array</h5>
<p>Arrays class defines the following sort methods to sort elements of primitive and object type arrays</p>
<pre><code>
    public static void sort(primitives[] p)
    - To sort according to natural sorting order

    public static void sort(Object[] o)
    - To sort according to natural sorting order 
     
    public static void sort(Object[] o, Comparator c)
    - To sort according to customized sorting order
</code></pre>

<pre><code>
    import java.util.Arrays;
    import java.util.Comparator;
    
    public class ArraysSortDemo {
    
        public static void main(String[] args) {
            int[] a = {10, 5, 20, 11, 6};
    
            System.out.println("Primitive array before sorting");
            for(int a1 : a) {
                System.out.println(a1);
            }
            Arrays.sort(a);
            System.out.println("Primitive array after sorting");
            for(int a1 : a) {
                System.out.println(a1);
            }
            
            String[] s = {"A", "Z", "B"};
            System.out.println("Object array before sorting");
            for(String a2 : s) {
                System.out.println(a2);
            }
            
            Arrays.sort(s);
            System.out.println("Object array after sorting");
            for(String a1 : s) {
                System.out.println(a1);
            }
            
            Arrays.sort(s, new MyComparator());
            System.out.println("Object array after sorting by comparator");
            for(String a1 : s) {
                System.out.println(a1);
            }
        }
    
    }
    class MyComparator implements Comparator {
    
        @Override
        public int compare(Object o1, Object o2) {
            String s1 = o1.toString();
            String s2 = o2.toString();
            return s2.compareTo(s1);
        }
        
    }
</code></pre>

<pre><output>
    Primitive array before sorting
    10
    5
    20
    11
    6
    Primitive array after sorting
    5
    6
    10
    11
    20
    Object array before sorting
    A
    Z
    B
    Object array after sorting
    A
    B
    Z
    Object array after sorting by comparator
    Z
    B
    A
</output></pre>

<mark>Note : We can sort primitive arrays only based on default natural sorting order whereas 
    we can sort object arrays either based on default natural sorting order or based on customized 
    sorting order.
</mark>
<br><br>
<h3>Searching elements of array</h3>
<p>Arrays class defines the following binary search methods</p>
<pre><code>
    1. public static int binarySearch(primitive[] p, primitive target)

    2. public static int binarySearch(Object[] a, Object target)

    3. public static int binarySearch(Object[] a, Object target, Comparator c)
</code></pre>

<mark>Note : All rules of Arrays class binarySearch methods are exactly same as Collections class 
    binary search methods</mark>

<pre><code>
    import java.util.Arrays;
    import java.util.Comparator;
    
    public class ArraysSearchDemo {
    
        public static void main(String[] args) {
            int[] a = {10, 5, 20, 11, 6};
            Arrays.sort(a);
            System.out.println(Arrays.binarySearch(a, 6));
            System.out.println(Arrays.binarySearch(a, 14));
            
            String[] s = {"A", "Z", "B"};
            Arrays.sort(s);
            System.out.println(Arrays.binarySearch(s, "Z"));
            System.out.println(Arrays.binarySearch(s, "S"));
            
            Arrays.sort(s, new MyComparator());
            System.out.println(Arrays.binarySearch(s, "Z", new MyComparator()));
            System.out.println(Arrays.binarySearch(s, "S", new MyComparator()));
            System.out.println(Arrays.binarySearch(s, "N", new MyComparator()));
        }
    
    }
    class MyComparator implements Comparator {
        public int compare(Object o1, Object o2) {
            String s1 = o1.toString();
            String s2 = o2.toString();
            return s2.compareTo(s1);
        }
    }
</code></pre>

<pre><output>
    1
    -5
    2
    -3
    0
    -2
    -2
</output></pre>

<h5>Conversion of Array to List</h5>
<pre><code>
    public static List asList(Object[] a)
    - strictly speaking this method wont create an independent List object. 
    For the existing Array we are getting List view.

    Example : 
    String[] s = {"A", "Z", "B"}
    List l = Arrays.asList(s);
</code></pre>

<img src="images/ss168.png" alt="ss12" width="400" height="200">

<p>By using Array reference if we perform any change automatically that change will be reflected 
    to the List.
</p>Similarily by using List reference if we perform any change that change will be reflected automatically 
to the Array</p>
 <p>By using List reference we cant perform any operation which varies the size o/w we will get RE saying 
     Unsupported operation Exception
 </p>
 <pre><code>
     l.add("M");
     l.remove(1);
</code></pre>
<pre><output>
    RE : UnsupportedOperationException
</output></pre>

<pre><code>
    l.set(1, "N");
</code></pre>

<pre><output>
    valid
</output></pre>

<p>By using List reference we are not allowed to replace with heterogeneous objects o/w we will get RE 
    saying ArrayStoreException
</p>

<pre><code>
    l.set(l, new Integer(10));

    RE: ArrayStoreException
</code></pre>

<pre><code>
    import java.util.Arrays;
    import java.util.List;
    
    public class ArraysAsListDemo {
    
        public static void main(String[] args) {
            String[] s = {"A", "Z","B"};
            List l = Arrays.asList(s);
            System.out.println(l);
            s[0] = "K";
            System.out.println(l);
            l.set(1, "L");
            for(String s1 : s) {
                System.out.print(s1 + " ");
            }
            //l.add("durga");	//UnsupportedOperationExcepton
            //l.remove(2);		//UnsupportedOperationExcepton
            //l.set(1, new Integer(10));	//ArrayStoreException
        }
    
    }    
</code></pre>

<pre><output>
    [A, Z, B]
    [K, Z, B]
    K L B 
</output></pre>




<h1>Concurrent Collections</h1>
    <h3>Need of Concurrent Collections</h3>
    <p>1. Tradition Collection object (like ArrayList, HashMap etc) can be accessed 
        by multiple threads simultaneously and there may be a chance of data inconsistency 
        problems and hence these are not thread safe.
    </p>
    <p>2. Already existing thread safe Collections (Vector, Hashtable, synchronizedList(), synchronizedSet(),
        synchronizedMap()) performance wise not upto the mark</p>
    <p>3. Because for every operation even for read operation alse total Collection will be 
        loaded by only one thread at a time and it increases waiting time of threads
    </p>
    <pre><code>
        import java.util.ArrayList;
        import java.util.Iterator;
        
        public class MyThread extends Thread {
            static ArrayList l = new ArrayList();
            public void run() {
                try {
                    Thread.sleep(2000);
                } catch(InterruptedException e) {
                    
                }
                System.out.println("Child Thread updating list");
                l.add("D");
            }
            public static void main(String[] args) throws InterruptedException {
                l.add("A");
                l.add("B");
                l.add("C");
                MyThread t = new MyThread();
                t.start();
                Iterator iterator = l.iterator();
                while(iterator.hasNext()) {
                    String s1 = (String)iterator.next();
                    System.out.println("Main thread iterating list and current object is : " + s1);
                    Thread.sleep(3000);
                }
                System.out.println(l);
            }
        
        }
    </code></pre>
    
    <pre><output>
        Main thread iterating list and current object is : A
        Child Thread updating list
        Exception in thread "main" java.util.ConcurrentModificationException        
    </output></pre>

    <p>Another big problem with Traditional Collections is while one thread iterating Collection, the other threads are not 
        allowed to modify Collection Object simultaneously if we are trying to modify then we will get ConcurrentModificationException
    </p>
    <p>Hence these Traditional Collection objects are not suitable for scalable multi threaded 
        applications.
    </p>
    <p>To overcome these problems SUN people introdued Concurrent Collections in 1.5 version</p>

<h6>Difference between Traditional and Concurrent Collections</h6>
<p>1. Concurrent Collections are always thread safe</p>
<p>2. When compared with Traditional thread safe Collections performance is more because of different locking mechanism</p>
<p>3. While one thread interacting Collection the other threads are allowed to modify Collection in safe manner</p>


<p>Hence Concurrent Collections never threw ConcurrentModificationException</p>
<p>The important Concurrent classes are</p>
<p>1. ConcurrentHashMap</p>
<p>2. CopyOnWriteArrayList</p>
<p>3. CopyOnWriteArraySet</p>

<h3>ConcurrentMap(I)</h3>
<img src="images/ss169.png" alt="ss12" width="400" height="300">

<h6>Methods</h6>
<p>It defines the following 3 specific methods</p>
<pre><code>
    Object putIfAbsent(Object key, Object value)
    - To add entry to the Map if the specified key is not already available
</code></pre>

<pre><code>
    1. Object putIfAbsent(Object key, Object value) 
    if(!map.containsKey(key)) {
        map.put(key, value);
    } else {
        return map.get(key);
    }
</code></pre>

<h6>Difference between put() and putIfAbsent()</h6>
<table class="table table-striped">
    <thead class="thead-dark">
        <tr>
            <th>put()</th>
            <th>putIfAbsent()</th>
        </tr>
    </thead> 
    <tbody>
        <tr>
            <td>If the key is already available, old value will be replaced with new value and returns old value</td>
            <td>If the key is already present then entry wont be added and returns old associated value. If 
                the key is not available then only entry will be added.
            </td>
        </tr>  
    </tbody>
</table>

<pre><code>
    import java.util.concurrent.ConcurrentHashMap;

    public class ConcurrentMapDemo {
    
        public static void main(String[] args) {
            ConcurrentHashMap m = new ConcurrentHashMap();
            m.put(101, "Durga");
            m.put(101, "Ravi");
            
            System.out.println(m);
            
            m.putIfAbsent(101, "Shiva");
            System.out.println(m);
        }
    }
    
</code></pre>

<pre><output>
    {101=Ravi}
    {101=Ravi}    
</output></pre>


<pre><code>
    2. boolean remove(Object key, Object value)
    - removes the entry if the key associated with specified value only

    if(map.containsKey(key) && map.get(key).equals(value)) {
        map.remove(key);
        return true;
    } else {
        return false;
    }
</code></pre>

<pre><code>
    import java.util.concurrent.ConcurrentHashMap;

    public class ConcurrentMapDemo {
    
        public static void main(String[] args) {
            ConcurrentHashMap m = new ConcurrentHashMap();
            m.put(101, "Durga");
            m.remove(101, "Ravi");
            
            System.out.println(m);
            
            m.remove(101, "Durga");
            System.out.println(m);
        }
    }    
</code></pre>
<pre><output>
    {101=Durga}
    {}    
</output></pre>

<pre><code>
    3. boolean replace(Object key, Object oldValue, Object newValue)

    if(map.containsKey(key) && map.get(key).equals(oldValue)) {
        map.put(key, newValue);
        return true;
    } else {
        return false;
    }
</code></pre>

<pre><code>
    import java.util.concurrent.ConcurrentHashMap;

    public class ConcurrentMapDemo {
    
        public static void main(String[] args) {
            ConcurrentHashMap m = new ConcurrentHashMap();
            m.put(101, "Durga");
            m.replace(101, "Ravi", "Shiva");
            
            System.out.println(m);
            
            m.replace(101, "Durga", "Ravi");
            System.out.println(m);
        }
    }    
</code></pre>

<pre><output>
    {101=Durga}
    {101=Ravi}    
</output></pre>

<h3>ConcurrentHashMap</h3>
<p>1. Underlying data structure is Hashtable</p>
<p>2. ConcurrentHashMap allows Concurrent read and thread safe update operations</p>
<p>3. To perform read operation thread wont require any lock. But to perform update 
    operation thread requires lock but it is the lock of only a particular part of Map 
    (Bucket level lock)
</p>
<p>4. Instead of whole Map Concurrent update achieved by internally dividing Map into smaller
    portion which is defined by Concurrency level.
</p>
<p>5. The default Concurrency level is 16</p>
<p>6. That is ConcurrentHashMap allows simultaneous read operation and simultaneously 16 write 
    (update) operations
</p>
<p>7. null is not allowed for both keys and values</p>
<p>8. While one thread iterating the other thread can perform update operation and ConcurrentHashMap 
    never throw ConcurrentModificationException
</p>

<h6>Constructors</h6>
<p>1. ConcurrentHashMap m = new ConcurrentHashMap();</p>
<p>- creates an empty ConcurrentHashMap with default initial capacity 16 and default fill 
    ratio 0.75 and default Concurrency level 16.
</p>

<p>2. ConcurrentHashMap m = new ConcurrentHashMap(InitialCapacity);</p>

<p>3. ConcurrentHashMap m = new ConcurrentHashMap(InitialCapacity, float fillRatio);</p>

<p>4. ConcurrentHashMap m = new ConcurrentHashMap(InitialCapacity, float fillRatio, intconcurrencyLevel)</p>

<p>5. ConcurrentHashMap m = new ConcurrentHashMap(Map m)</p>
</body>
</html>

</body>
</html>

